{"meta":{"title":"山西小魔头技术博客","subtitle":"没有压力的生命就会黯淡","description":"失落时悄悄徘徊，伤感时默默遐想","author":"WangQingLei","url":"http://www.yipinxieli.com","root":"/"},"pages":[{"title":"关于","date":"2021-05-16T13:08:59.000Z","updated":"2021-06-02T15:20:40.704Z","comments":true,"path":"about/index.html","permalink":"http://www.yipinxieli.com/about/index.html","excerpt":"","text":"个人简历 个人信息 中文名：王清雷 英文名：WangQL 昵称：山西小魔头 性别：男 类别：高级灵长类动物 职业：JAVA BUG开发工程师 学校：中北大学 爱好：活着 性格：善良、阳光、勤奋 专业技能 ​ 2021.06.02记录自己的不专业，努力学习，充实技能列表 自我评价 ​ 本人性格开朗，待人友善，真诚谦虚。工作积极进取，态度认真。"},{"title":"categories","date":"2021-05-16T13:16:04.000Z","updated":"2021-06-05T06:18:39.167Z","comments":true,"path":"categories/index.html","permalink":"http://www.yipinxieli.com/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-05-16T13:19:43.000Z","updated":"2021-05-16T13:19:43.768Z","comments":true,"path":"contact/index.html","permalink":"http://www.yipinxieli.com/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-16T13:16:41.000Z","updated":"2021-05-16T13:16:41.265Z","comments":true,"path":"friends/index.html","permalink":"http://www.yipinxieli.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-06-03T13:16:25.000Z","updated":"2021-06-03T16:19:16.232Z","comments":true,"path":"tags/index.html","permalink":"http://www.yipinxieli.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 虚拟机进程状态工具jps","slug":"jvm-command-jstat","date":"2022-03-28T09:48:06.000Z","updated":"2022-03-27T16:43:17.160Z","comments":true,"path":"2022/03/28/jvm-command-jstat/","link":"","permalink":"http://www.yipinxieli.com/2022/03/28/jvm-command-jstat/","excerpt":"利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对进程的classloader，compiler，gc情况；可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量，以及加载类的数量。","text":"利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对进程的classloader，compiler，gc情况；可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量，以及加载类的数量。 Java 虚拟机进程状态工具JPS 语法 jstat [option vmid [interval [s|ms][count]] [count]] ] options work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -options -class -compiler -gc -gccapacity -gccause -gcmetacapacity -gcnew -gcnewcapacity -gcold -gcoldcapacity -gcutil -printcompilation jstat工具主要选项 选项 作用 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -compiler 输出JIT编译器编译过的方法、耗时等信息 -gc 监视Java堆状况，包括Eden区、两个survivor区、老年代、元空间的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gccause 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因 -gcmetacapacity 输出元数据用到的最大、最小空间 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 -gcold 监视老年代状况 -gcoldcapacity 监视内容与-gcold基本相同，输出主要关注用到的最大、最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -printcompilation 输出已经被JIT编译的方法 示例： 以下输出空间单位都是KB，时间单位都是s 类加载统计 Loaded:加载class的数量 Bytes：所占用空间大小 Unloaded：未加载数量 Bytes:未加载占用空间 Time：时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -class 47 Loaded Bytes Unloaded Bytes Time 12225 23448.0 0 0.0 16.53 编译统计 Compiled：编译数量。 Failed：失败数量 Invalid：不可用数量 Time：时间 FailedType：失败类型 FailedMethod：失败的方法 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -compiler 47 Compiled Failed Invalid Time FailedType FailedMethod 14158 1 0 71.73 1 com&#x2F;mysql&#x2F;jdbc&#x2F;AbandonedConnectionCleanupThread run 垃圾回收统计 S0C：第一个幸存区的大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 OC：老年代大小 OU：老年代使用大小 MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gc 47 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 17024.0 17024.0 0.0 22.7 136320.0 60520.6 460416.0 88295.8 76212.0 74725.3 8392.0 8040.4 223 1.986 4 0.277 2.263 堆内存统计 NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 EC：伊甸园区的大小 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC:当前老年代大小 MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代gc次数 FGC：老年代GC次数 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gccapacity 47 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC 170368.0 170368.0 170368.0 17024.0 17024.0 136320.0 460416.0 460416.0 460416.0 460416.0 0.0 1118208.0 76212.0 0.0 1048576.0 8392.0 223 4 新生代垃圾回收统计 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 TT:对象在新生代存活的次数 MTT:对象在新生代存活的最大次数 DSS:期望的幸存区大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gcnew 47 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 17024.0 17024.0 0.0 22.7 6 6 8512.0 136320.0 63300.2 223 1.986 新生代内存统计 NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0CMX：最大幸存1区大小 S0C：当前幸存1区大小 S1CMX：最大幸存2区大小 S1C：当前幸存2区大小 ECMX：最大伊甸园区大小 EC：当前伊甸园区大小 YGC：年轻代垃圾回收次数 FGC：老年代回收次数 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gcnewcapacity 47 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 170368.0 170368.0 170368.0 17024.0 17024.0 17024.0 17024.0 136320.0 136320.0 223 4 老年代垃圾回收统计 MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 OC：老年代大小 OU：老年代使用大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gcold 47 MC MU CCSC CCSU OC OU YGC FGC FGCT GCT 76212.0 74725.3 8392.0 8040.4 460416.0 88295.8 223 4 0.277 2.263 老年代内存统计 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC：老年代大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gcoldcapacity 47 OGCMN OGCMX OGC OC YGC FGC FGCT GCT 460416.0 460416.0 460416.0 460416.0 223 4 0.277 2.263 元数据空间统计 MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gcmetacapacity 47 MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC FGCT GCT 0.0 1118208.0 76212.0 0.0 1048576.0 8392.0 223 4 0.277 2.263 总结垃圾回收统计 S0：幸存1区当前使用比例 S1：幸存2区当前使用比例 E：Eden区使用比例 O：老年代使用比例 M：元数据区使用比例 CCS：压缩使用比例 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 work@authority-schedule-v1-fbf4cfd6d-86zhw:~$ jstat -gcutil 47 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.13 55.01 19.18 98.05 95.81 223 1.986 4 0.277 2.263 分析jstat输出的工具 jstat的挑战之一是您需要手动分析生成的统计信息。 正如您看到的那样，仅了解/解释一行内容将花费很长时间，这将很繁琐。 您可以使用GCeasy工具 ，该工具可以解析jstat输出并生成具有洞察力的图形和指标。 jstat局限性 它没有提供有关GC活动的丰富详细信息。 它仅提供足够的信息。 例如，从jstat您将不知道： 如果一次样本中报告了多个GC事件，那么我们将不知道每个GC事件的暂停时间是多少。 用户（即Java层），系统（即内核）和用户花费了多少时间。 有多少个GC线程正在工作，并占用了多少时间？ 一个GC事件具有几个子阶段（例如初始标记，清理，备注，并发标记……）。 无法提供信息分类。 每个GC事件回收多少字节。 有时，jstat报告的数据也会产生误导 。 如果您想进行准确的GC分析，GC日志是更可靠的方法。 引用 【JVM】jstat命令详解—JVM的统计监测工具","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"mysql-isolation-level","slug":"mysql-isolation-level","date":"2022-03-26T11:30:44.000Z","updated":"2022-03-26T16:18:06.041Z","comments":true,"path":"2022/03/26/mysql-isolation-level/","link":"","permalink":"http://www.yipinxieli.com/2022/03/26/mysql-isolation-level/","excerpt":"Mysql数据库隔离级别 未完待续","text":"Mysql数据库隔离级别 未完待续 MYSQL事务隔离级别 InnoDB解决幻读的方案–LBCC&amp;MVCC InnoDB默认的事务隔离级别是RR，它为了解决该隔离级别下的幻读的并发问题，提出了LBCC和MVCC两种方案。其中LBCC解决的是当前读情况下的幻读，MVCC解决的是普通读（快照读）的幻读。 知识点 InnoDB的RR隔离级别并没有完全解决幻读的问题。如果在同一个事务里面，只是总是执行普通的select快照读，是不会产生幻读的。 但是如果在这个事务里面通过当前读或者先更新然后快照读的形式来读取数据，就会产生幻读。 测试用表 -- auto-generated definition create table test_read ( id bigint auto_increment comment &#39;主键&#39; primary key, name varchar(32) default &#39;&#39; null comment &#39;姓名&#39; ) comment &#39;幻读测试表&#39;; 初始化数据 insert into test_read (id, name) values (1, &#39;wang&#39;); insert into test_read (id, name) values (2, &#39;zhang&#39;); 幻读情形1 打开两个终端，连上mysql，分别启动事务1和事务2。 事务1 事务2 start transaction; start transaction; insert into test_read (name) values (‘zhao’); – select * from test_read; select * from test_read; 查询出来的结果如下： 事务1： 1,wang 2,zhang 3,zhao 事务2： 1,wang 2,zhang 很明显事务2没有查询到事务1未提交的新插入数据。原因也很简单，因为普通的select语句是快照读，而事务b启动时，它的快照数据就已经被版本锁定了。 如果事务2进行当前读是否能够读取到事务1未提交的新插入数据呢？ 我们在事务2里面执行如下命令来看看执行结果： select * from test_read lock in share mode; 执行完成之后我们发现事务b此时会block住，原因是事务1的insert语句排它锁住了id为3的新插入数据，而事务2想请求所有行的共享锁，肯定是需要等待的。 事务1提交之后，事务2依然无法读取到事务a新插入的数据，因为事务b还是读取到的是快照数据，所以不包含事务a提交之后的新数据。 如果此时事务b使用当前读，能否获取到事务a已提交的新插入数据呢？ 事务1 事务2 start transaction; start transaction; insert into test_read (name) values (‘zhao’); – select * from test_read; select * from test_read; commit; – – select * from test_read lock in share mode; 查询出来的结果如下： 1,wang 2,zhang 3,zhao 可以查询到事务a已提交的新数据，所以此时使用当前读就产生了幻读。 幻读情形2 事务1 事务2 start transaction; start transaction; insert into test_read (name) values (‘zhao’); – select * from test_read; select * from test_read; commit; – – update test_read set name=’bbb’ where id = 3; – select * from test_read; 第一条命令使用update更新了事务a已提交的新数据，第二条命令通过普通的select语句查看快照数据。 查询出来的结果如下： 1,wang 2,zhang 3,bbb 可以看到事务a已提交的新数据被事务b使用update语句更新了，并且通过普通的select语句给查询出来了，很显然，出现了幻读。 引用 InnoDB解决幻读的方案–LBCC&amp;MVCC","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.yipinxieli.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.yipinxieli.com/tags/mysql/"}]},{"title":"synchronized锁升级与降级","slug":"java-synchronized","date":"2022-03-19T16:17:31.000Z","updated":"2022-03-20T04:01:31.139Z","comments":true,"path":"2022/03/20/java-synchronized/","link":"","permalink":"http://www.yipinxieli.com/2022/03/20/java-synchronized/","excerpt":"针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。","text":"针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。 Synchronized锁升级与降级 对象的内存布局 在HotSpot虚拟机中，对象的内存布局可以划分为三部分：对象头（header）、实例对象（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机对象的对象头包含两类信息。第一类是用于存储对象本身的运行时数据，如哈希码、GC分代年龄、锁状态标志等，官方称之为（Mark Word）。对象头的另一部分为类型指针（klass word），即指向它的类型元数据的指针，JAVA虚拟机通过这个指针来确定该对象是哪个类的实例。此外，如果对象是一个数组，那么对象头里边还必须有一块用于记录数组长度的数据。 实例数据部分是对象真正存储的有效信息，即我们在程序中定义的各种类型的字段内容。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。 对象的第三部分为对齐填充，这并不是必然存在的，仅起占位符的作用，因为虚拟机要求对象的起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 对象信息查看分析 POM文件中引入JOL包 &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt; &lt;version&gt;0.16&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 测试类 package com.rrc.util; import org.openjdk.jol.info.ClassLayout; public class ObjectSee &#123; public static void main(String[] args) &#123; ObjectSee a &#x3D; new ObjectSee(); System.out.println(ClassLayout.parseInstance(a).toPrintable()); &#125; &#125; 打印结果： com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 从打印日志我们发现整个对象一共16B，其中对象头（Object header）12B，还有4B是对齐的字节（因为在64位虚拟机上对象的大小必 须是8的倍数）, 由于这个对象里面没有任何字段，故而对象的实例数据为0B。 为对象增加boolean类型属性 package com.rrc.util; import org.openjdk.jol.info.ClassLayout; public class ObjectSee &#123; private boolean flag; public static void main(String[] args) &#123; ObjectSee a &#x3D; new ObjectSee(); &#x2F;&#x2F;System.out.println(Integer.toHexString(a.hashCode())); System.out.println(ClassLayout.parseInstance(a).toPrintable()); &#125; &#125; 打印结果： com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total 整个对象的大小还是没有改变一共16B，其中对象头（Object header）12B，boolean字段flag（对象的实例数据）占 1B、剩下的3B就是对齐字节。 由此我们可以认为一个对象的布局大体分为三个部分分别是:对象头（Object header）、 对象的实例数据和字节对齐 对象头信息查看分析 根据上述利用JOL打印的对象头信息可以知道一个对象头是12B，其中8B是mark word 那么剩下的4B就是klass word了，和锁相关的就是mark word了。 手动计算HashCode package com.rrc.util; import sun.misc.Unsafe; import java.lang.reflect.Field; public class HashUtil &#123; public static void countHash(Object object) throws NoSuchFieldException, IllegalAccessException &#123; &#x2F;&#x2F; 手动计算HashCode Field field &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); Unsafe unsafe &#x3D; (Unsafe) field.get(null); long hashCode &#x3D; 0; for (long index &#x3D; 7; index &gt; 0; index--) &#123; &#x2F;&#x2F; 取Mark Word中的每一个Byte进行计算 hashCode |&#x3D; (unsafe.getByte(object, index) &amp; 0xFF) &lt;&lt; ((index - 1) * 8); &#125; String code &#x3D; Long.toHexString(hashCode); System.out.println(&quot;util-----------0x&quot;+code); &#125; &#125; package com.rrc.util; import org.openjdk.jol.info.ClassLayout; public class ObjectSee &#123; private boolean flag; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; ObjectSee b &#x3D; new ObjectSee(); System.out.println(&quot;befor hash&quot;); &#x2F;&#x2F;没有计算HASHCODE之前的对象头 System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#x2F;&#x2F;JVM 计算的hashcode System.out.println(&quot;jvm------------0x&quot;+Integer.toHexString(b.hashCode())); HashUtil.countHash(b); &#x2F;&#x2F;当计算完hashcode之后，我们可以查看对象头的信息变化 System.out.println(&quot;after hash&quot;); System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; &#125; 运行结果为： befor hash com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total jvm------------0x7a92922 util-----------0x7a92922 after hash com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 22 29 a9 (00000001 00100010 00101001 10101001) (-1456922111) 4 4 (object header) 07 00 00 00 (00000111 00000000 00000000 00000000) (7) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total 分析结果： 没有进行hashcode之前的对象头信息，可以看到的56bit没有值，打印完hashcode之后就有值了，为什 么是1-7B，不是0-6B呢？因为是小端存储。 两行打印的hashcode结果相同，所以可以确定java对象头当中的mark work里面的后七个字节存储的是hashcode信息。 那么第一个字节当中的八位分别存的就是分带年龄、偏向锁信息，和对象状态，这个8bit分别表示的信息如下图（其实上图也有信息），这个图会随着对象状态改变而改变， 下图是无锁状态下 关于对象状态一共分为五种状态，分别是无锁、偏向锁、轻量锁、重量锁、GC标记， 那么2bit，如何能表示五种状 态（2bit最多只能表示4中状态分别是：00,01,10,11）， jvm做的比较好的是把偏向锁和无锁状态表示为同一个状态，然 后根据图中偏向锁的标识再去标识是无锁还是偏向锁状态。 从上面打印的信息可以看到无锁状态下的信息00000001(无锁不可偏向)。 Synchronized锁 从JDK6开始，就对synchronized的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。 在 JDK 1.6 中默认是开启偏向锁的。 可以通过-XX:-UseBiasedLocking来禁用偏向锁。使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。重量级锁：有实际竞争，且锁竞争时间长。 偏向锁默认配置 work@call-center-portal-v1-77466db6dc-cbw8d:~$ java -XX:+PrintFlagsFinal -version | grep &quot;BiasedLocking&quot; intx BiasedLockingBulkRebiasThreshold &#x3D; 20 &#123;product&#125; intx BiasedLockingBulkRevokeThreshold &#x3D; 40 &#123;product&#125; intx BiasedLockingDecayTime &#x3D; 25000 &#123;product&#125; intx BiasedLockingStartupDelay &#x3D; 4000 &#123;product&#125; bool TraceBiasedLocking &#x3D; false &#123;product&#125; bool UseBiasedLocking &#x3D; true &#123;product&#125; openjdk version &quot;1.8.0_222&quot; OpenJDK Runtime Environment (build 1.8.0_222-b10) OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode) work@call-center-portal-v1-77466db6dc-cbw8d:~$ 如上： BiasedLockingStartupDelay值为4000毫秒，因为JDK1.8 的偏向锁默认延迟4s生效的 UseBiasedLocking=true，表示程序默认开启偏向锁。如果设置为false则程序默认会进入轻量级锁。 -XX:+PrintSafepointStatistics可打印安全点事件,与偏向锁有关的可重点可关注EnableBiasedLocking,RevokeBias和BulkRevokeBias。 选项-XX:+TraceBiasedLocking可以帮助生成一个详细描述jvm做出的偏向锁决策的日志。 JDK1.8锁升级与降级 接下来我们写一个偏向锁的例子看结果。 package com.rrc.util; import org.openjdk.jol.info.ClassLayout; public class ObjectSee &#123; private boolean flag; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; ObjectSee b &#x3D; new ObjectSee(); System.out.println(&quot;befor lock&quot;); System.out.println(ClassLayout.parseInstance(b).toPrintable()); synchronized (b)&#123; System.out.println(&quot;lock ing&quot;); System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; System.out.println(&quot;after lock&quot;); System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; &#125; 运行结果为： com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total lock ing com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 90 b9 7a 0c (10010000 10111001 01111010 00001100) (209369488) 4 4 (object header) 03 00 00 00 (00000011 00000000 00000000 00000000) (3) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total after lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total 上面这个程序只有一个线程去调用sync方法，故而讲道理应该是偏向锁，但是此时却是轻量级锁。 而且你会发现最后输出的结果依然是00000001和无锁的时候一模一样，其实这是因为虚拟机在启动的时候对于偏向锁有延迟。 此时我们选择关闭JDK1.8的默认偏向锁延迟（-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0） 此时运行结果如下： befor lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 00 00 00 (00000101 00000000 00000000 00000000) (5) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total lock ing com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 18 01 e4 (00000101 00011000 00000001 11100100) (-469690363) 4 4 (object header) c9 7f 00 00 (11001001 01111111 00000000 00000000) (32713) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total after lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 18 01 e4 (00000101 00011000 00000001 11100100) (-469690363) 4 4 (object header) c9 7f 00 00 (11001001 01111111 00000000 00000000) (32713) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 1 boolean ObjectSee.flag false 13 3 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total 此时的00000101标识可偏向已锁定 。 延迟偏向是因为JVM启动的时候会有很多操作,运行时存在大量的同步方法,很多都不是偏向锁,而偏向锁升级为轻/重量级锁的很费时间和资源,因此jvm会延迟4秒左右再开启偏向锁。 需要注意的after lock，退出同步后依然保持了偏向信息（Mark Word中保存有线程ID）。 偏向锁使用了一种等到竞争出现才释放锁的机制，即一个线程在执行完同步代码块以后，并不会尝试将MarkWord中的thread ID赋回原值。这样做的好处是：如果该线程需要再次对这个对象加锁，而这个对象之前一直没有被其他线程尝试获取过锁，依旧停留在可偏向的状态下，即可在不修改对象头的情况下，直接认为偏向成功。 轻量级锁（JVM options:-XX:-UseBiasedLocking） package com.rrc.util; import org.openjdk.jol.info.ClassLayout; public class ObjectSee &#123; private static ObjectSee a; public static void main(String[] args) throws Exception &#123; a &#x3D; new ObjectSee(); System.out.println(&quot;befre lock&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable()); synchronized (a)&#123; System.out.println(&quot;lock ing&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable()); &#125; System.out.println(&quot;after lock&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable()); &#125; &#125; 运行结果为： befre lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total lock ing com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 98 59 b6 09 (10011000 01011001 10110110 00001001) (162945432) 4 4 (object header) 03 00 00 00 (00000011 00000000 00000000 00000000) (3) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total after lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 在关闭偏向锁后，使用synchronized加锁后直接升级为轻量级锁。 偏向锁的撤销（Revoke） 操作并不是将对象恢复到无锁可偏向的状态，而是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程，即将内存最低的对应的lock Record的obj置为null，需要注意撤销与释放的区别。 偏向锁的撤销，是轻量级锁的前提。 需要注意的after lock，退出同步后回到了无锁的状态（Mark Word中线程ID消失）。 重量级锁（JVM options:-XX:-UseBiasedLocking）： package com.rrc.util; import org.openjdk.jol.info.ClassLayout; public class ObjectSee &#123; private static ObjectSee a; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;Thread.sleep(5000); a &#x3D; new ObjectSee(); System.out.println(&quot;befre lock&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable());&#x2F;&#x2F;无锁 Thread t1&#x3D; new Thread()&#123; public void run() &#123; synchronized (a)&#123; try &#123; Thread.sleep(5000); System.out.println(&quot;t1 release&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t1.start(); Thread.sleep(1000); System.out.println(&quot;t1 lock ing&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable());&#x2F;&#x2F;轻量锁 sync(); System.out.println(&quot;after lock&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable());&#x2F;&#x2F;重量锁 System.gc(); System.out.println(&quot;after gc()&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable());&#x2F;&#x2F;无锁---gc &#125; public static void sync() throws InterruptedException &#123; synchronized (a)&#123; System.out.println(&quot;t1 main lock&quot;); System.out.println(ClassLayout.parseInstance(a).toPrintable());&#x2F;&#x2F;重量锁 &#125; &#125; &#125; 运行结果如下： befre lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total t1 lock ing com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) b0 d9 d7 09 (10110000 11011001 11010111 00001001) (165140912) 4 4 (object header) 03 00 00 00 (00000011 00000000 00000000 00000000) (3) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total t1 release t1 main lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 4a 7b 81 21 (01001010 01111011 10000001 00100001) (562133834) 4 4 (object header) 8f 7f 00 00 (10001111 01111111 00000000 00000000) (32655) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total after lock com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 4a 7b 81 21 (01001010 01111011 10000001 00100001) (562133834) 4 4 (object header) 8f 7f 00 00 (10001111 01111111 00000000 00000000) (32655) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total after gc() com.rrc.util.ObjectSee object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 09 00 00 00 (00001001 00000000 00000000 00000000) (9) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total after lock之后依然是重量级锁，但是经过gc之后变成了无锁状态。Hotspot 在 1.8 开始有了锁降级。在 STW 期间 JVM 进入安全点时如果发现有闲置的 monitor(重量级锁对象)，会进行锁降级。 由上述实验可总结下图: 批量重偏向和批量撤销 当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。safe point这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。 1 批量重偏向锁：当对某个类的对象偏向锁批量撤销20次，则偏向锁认为，后面的锁需要重新偏向新的线程（批量重偏向） 2 批量撤销：当某个类的对象的偏向锁累计被撤销到阈值40次（从40次开始），则偏向锁认为偏向锁撤销过于频繁，则后面的对象包括新生成的对象（标识为101和001）如果需要使用锁，则直接轻量级锁，不在使用偏向锁（即禁用了偏向锁） 存在如下两种情况： 一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。 存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。 批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。 其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20，jvm参数BiasedLockingBulkRebiasThreshold控制）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。 当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40，jvm参数BiasedLockingBulkRevokeThreshold控制），JVM就认为该class的使用场景存在多线程竞争，执行批量撤销，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。 BiasedLockingDecayTime是开启一次新的批量重偏向距离上次批量重偏向的后的延迟时间，默认25000。也就是开启批量重偏向后，如果经过了一段较长的时间（&gt;=BiasedLockingDecayTime），撤销计数器才超过阈值，那我们会重置计数器。 批量撤销相关DEMO如下： package com.rrc.util; import org.openjdk.jol.info.ClassLayout; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.LockSupport; &#x2F;** * Hello world! * -XX:+PrintFlagsFinal * -Xms1g -Xmx1g -XX:+PrintGCDetails -XX:BiasedLockingStartupDelay&#x3D;0 偏向延迟关闭参数 *&#x2F; public class Test4 &#123; static Thread t1 &#x3D; null; static Thread t2 &#x3D; null; static Thread t3 &#x3D; null; static int count &#x3D; 39;&#x2F;&#x2F;39 则正好是经历了，40次偏向锁撤销，以后新创建的对象为无锁不可偏向标识，那加锁则直接为轻量级锁（撤销了偏向锁这个步骤） public static void main(String[] args) throws InterruptedException &#123; &#x2F;&#x2F; System.out.println(String.format(&quot; 新对象锁标识：%s &quot;, ClassLayout.parseInstance(new B()).toPrintable())); B b2 &#x3D; new B(); &#x2F;&#x2F;保存锁对象列表 List&lt;B&gt; list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;第一个线程 加锁了38次 t1 &#x3D; new Thread() &#123; @Override public void run() &#123; for (int i &#x3D; 0; i &lt; count; i++) &#123; B b &#x3D; new B(); list.add(b); System.out.println(String.format(&quot;线程名称 %s 执行的次数 %d &quot;, Thread.currentThread().getName(), i)); System.out.println(ClassLayout.parseInstance(b).toPrintable()); synchronized (b) &#123; &#x2F;&#x2F;打印第一个线程加锁后 ，对象头变化 System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; LockSupport.unpark(t2); &#125; &#125;; t2 &#x3D; new Thread() &#123; @Override public void run() &#123; LockSupport.park(); System.out.println(&quot;线程2开始执行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); for (int i &#x3D; 0; i &lt; count; i++) &#123; System.out.println(String.format(&quot;线程名称 %s 执行的次数 %d &quot;, Thread.currentThread().getName(), i)); B b &#x3D; list.get(i); System.out.println(ClassLayout.parseInstance(b).toPrintable()); synchronized (list.get(i)) &#123; &#x2F;&#x2F;打印第二个线程对对象加锁，对象头变化（线程前20次为偏向锁升级轻量级锁，从20次开始偏向锁偏向线程t2，发生线程重偏向） System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; LockSupport.unpark(t3); &#125; &#125;; t3 &#x3D; new Thread(() -&gt; &#123; LockSupport.park(); System.out.println(&quot;线程3开始执行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); for (int i &#x3D; 0; i &lt; count; i++) &#123; System.out.println(String.format(&quot;线程名称 %s 执行的次数 %d &quot;, Thread.currentThread().getName(), i)); B b &#x3D; list.get(i); System.out.println(ClassLayout.parseInstance(b).toPrintable()); synchronized (b) &#123; &#x2F;&#x2F;线程从20个开始进行偏向锁撤销直到发生撤销40次到达阈值，则后面的对象发生 偏向锁 批量撤销 System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; System.out.println(ClassLayout.parseInstance(b).toPrintable()); &#125; &#125;); t1.setName(&quot;线程t1 &quot;); t2.setName(&quot;线程t2 &quot;); t3.setName(&quot;线程t3 &quot;); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); System.out.println(&quot;&#x3D; 主线程新&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;发生批量撤销后线程加锁，转换为轻量级锁 System.out.println(String.format(&quot; 新对象锁标识：%s &quot;, ClassLayout.parseInstance(b2).toPrintable())); synchronized (b2) &#123; System.out.println(String.format(&quot; 新对象锁标识：%s &quot;, ClassLayout.parseInstance(b2).toPrintable())); &#125; &#125; &#125; class B &#123; &#125; 部分运行结果如下： 线程t1 count为39次，for循环进行39次（0-38，线程t1最后一次运行结果如下，最开始对象为可偏向无锁状态，进入同步代码块后Mark Word中塞入了线程ID（a8 03 7a bb 7f 00 00），退出同步代码块后依然保持了偏向信息（Mark Word中保存有线程ID）。 count为39， 线程 线程名称 线程t1 执行的次数 38 com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 00 00 00 (00000101 00000000 00000000 00000000) (5) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 a8 03 7a (00000101 10101000 00000011 01111010) (2047059973) 4 4 (object header) bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 a8 03 7a (00000101 10101000 00000011 01111010) (2047059973) 4 4 (object header) bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 线程t2 可以看到进入同步代码块后Mark Word中塞入了t2的线程ID（d9 00 0e 03 00 00 00），锁升级为轻量级锁，在退出同步代码块后锁状态变成不可偏向无锁，Mark Word中线程ID清除。 线程名称 线程t2 执行的次数 0 com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 a8 03 7a (00000101 10101000 00000011 01111010) (2047059973) 4 4 (object header) bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) a8 d9 00 0e (10101000 11011001 00000000 00001110) (234936744) 4 4 (object header) 03 00 00 00 (00000011 00000000 00000000 00000000) (3) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 线程t2执行到第19次时，符合默认的批量重偏向的条件，从对象头中可以看出，加锁后锁依然为偏向锁，但是已不再偏向t1线程。但是为什么对象头中的线程ID与前18次的线程ID不一致呢？ 线程名称 线程t2 执行的次数 19 com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 a8 03 7a (00000101 10101000 00000011 01111010) (2047059973) 4 4 (object header) bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 a1 92 7a (00000101 10100001 10010010 01111010) (2056429829) 4 4 (object header) bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 a1 92 7a (00000101 10100001 10010010 01111010) (2056429829) 4 4 (object header) bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 线程t3执行完毕之后相当于对象b已经经历超过40次的偏向撤销，对应类B的新对象虽然为可偏向无锁定状态（Mark Word中没有线程ID），但是进入同步代码块后将直接变为轻量级锁。 &#x3D; 主线程新&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 新对象锁标识：com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 05 00 00 00 (00000101 00000000 00000000 00000000) (5) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 新对象锁标识：com.rrc.util.B object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 88 e9 9b 0c (10001000 11101001 10011011 00001100) (211544456) 4 4 (object header) 03 00 00 00 (00000011 00000000 00000000 00000000) (3) 8 4 (object header) 05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total 引用 java对象头信息和三种锁的性能对比 synchronized原理和锁优化策略(偏向/轻量级/重量级) Synchronized 锁 批量重偏向 和批量撤销 分析对象内部结构，并详解synchronized锁膨胀升级和降级的过程 java中关于锁知识的整理","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"http://www.yipinxieli.com/tags/Thread/"}]},{"title":"垃圾回收器常用参数","slug":"jvm-param","date":"2022-03-12T16:17:31.000Z","updated":"2022-03-12T17:23:26.207Z","comments":true,"path":"2022/03/13/jvm-param/","link":"","permalink":"http://www.yipinxieli.com/2022/03/13/jvm-param/","excerpt":"垃圾收集器常用参数总结","text":"垃圾收集器常用参数总结 垃圾回收器常用参数 JVM 参数及默认值 Java 每个大版本间，都会有些参数变动，所以在写 JVM 配置前，一定要先看下你选择的参数是否还支持。Oracle 官网文档肯定是个途径，但不是最便捷的。下面这条命令可以立马查看所有参数及其默认值，而且还不用运行应用。 java -XX:+PrintFlagsFinal -version work@permission-center-portal-6df6466c6c-qhhwq:~$ java -XX:+PrintFlagsFinal -version [Global flags] intx ActiveProcessorCount &#x3D; -1 &#123;product&#125; uintx AdaptiveSizeDecrementScaleFactor &#x3D; 4 &#123;product&#125; uintx AdaptiveSizeMajorGCDecayTimeScale &#x3D; 10 &#123;product&#125; uintx AdaptiveSizePausePolicy &#x3D; 0 &#123;product&#125; uintx AdaptiveSizePolicyCollectionCostMargin &#x3D; 50 &#123;product&#125; uintx AdaptiveSizePolicyInitializingSteps &#x3D; 20 &#123;product&#125; uintx AdaptiveSizePolicyOutputInterval &#x3D; 0 &#123;product&#125; uintx AdaptiveSizePolicyWeight &#x3D; 10 &#123;product&#125; uintx AdaptiveSizeThroughPutPolicy &#x3D; 0 &#123;product&#125; uintx AdaptiveTimeWeight &#x3D; 25 &#123;product&#125; bool AdjustConcurrency &#x3D; false &#123;product&#125; bool AggressiveHeap &#x3D; false &#123;product&#125; bool AggressiveOpts &#x3D; false &#123;product&#125; intx AliasLevel &#x3D; 3 &#123;C2 product&#125; bool AlignVector &#x3D; false &#123;C2 product&#125; intx AllocateInstancePrefetchLines &#x3D; 1 &#123;product&#125; intx AllocatePrefetchDistance &#x3D; 192 &#123;product&#125; intx AllocatePrefetchInstr &#x3D; 3 &#123;product&#125; intx AllocatePrefetchLines &#x3D; 4 &#123;product&#125; intx AllocatePrefetchStepSize &#x3D; 64 &#123;product&#125; intx AllocatePrefetchStyle &#x3D; 1 &#123;product&#125; bool AllowJNIEnvProxy &#x3D; false &#123;product&#125; bool AllowNonVirtualCalls &#x3D; false &#123;product&#125; bool AllowParallelDefineClass &#x3D; false &#123;product&#125; bool AllowUserSignalHandlers &#x3D; false &#123;product&#125; bool AlwaysActAsServerClassMachine &#x3D; false &#123;product&#125; bool AlwaysCompileLoopMethods &#x3D; false &#123;product&#125; bool AlwaysLockClassLoader &#x3D; false &#123;product&#125; bool AlwaysPreTouch &#x3D; false &#123;product&#125; bool AlwaysRestoreFPU &#x3D; false &#123;product&#125; bool AlwaysTenure &#x3D; false &#123;product&#125; bool AssertOnSuspendWaitFailure &#x3D; false &#123;product&#125; bool AssumeMP &#x3D; false &#123;product&#125; intx AutoBoxCacheMax &#x3D; 128 &#123;C2 product&#125; uintx AutoGCSelectPauseMillis &#x3D; 5000 &#123;product&#125; intx BCEATraceLevel &#x3D; 0 &#123;product&#125; intx BackEdgeThreshold &#x3D; 100000 &#123;pd product&#125; bool BackgroundCompilation &#x3D; true &#123;pd product&#125; uintx BaseFootPrintEstimate &#x3D; 268435456 &#123;product&#125; intx BiasedLockingBulkRebiasThreshold &#x3D; 20 &#123;product&#125; intx BiasedLockingBulkRevokeThreshold &#x3D; 40 &#123;product&#125; intx BiasedLockingDecayTime &#x3D; 25000 &#123;product&#125; intx BiasedLockingStartupDelay &#x3D; 4000 &#123;product&#125; bool BindGCTaskThreadsToCPUs &#x3D; false &#123;product&#125; bool BlockLayoutByFrequency &#x3D; true &#123;C2 product&#125; intx BlockLayoutMinDiamondPercentage &#x3D; 20 &#123;C2 product&#125; bool BlockLayoutRotateLoops &#x3D; true &#123;C2 product&#125; bool BranchOnRegister &#x3D; false &#123;C2 product&#125; bool BytecodeVerificationLocal &#x3D; false &#123;product&#125; bool BytecodeVerificationRemote &#x3D; true &#123;product&#125; bool C1OptimizeVirtualCallProfiling &#x3D; true &#123;C1 product&#125; bool C1ProfileBranches &#x3D; true &#123;C1 product&#125; bool C1ProfileCalls &#x3D; true &#123;C1 product&#125; bool C1ProfileCheckcasts &#x3D; true &#123;C1 product&#125; bool C1ProfileInlinedCalls &#x3D; true &#123;C1 product&#125; bool C1ProfileVirtualCalls &#x3D; true &#123;C1 product&#125; bool C1UpdateMethodData &#x3D; true &#123;C1 product&#125; intx CICompilerCount :&#x3D; 2 &#123;product&#125; bool CICompilerCountPerCPU &#x3D; true &#123;product&#125; bool CITime &#x3D; false &#123;product&#125; bool CMSAbortSemantics &#x3D; false &#123;product&#125; uintx CMSAbortablePrecleanMinWorkPerIteration &#x3D; 100 &#123;product&#125; intx CMSAbortablePrecleanWaitMillis &#x3D; 100 &#123;manageable&#125; uintx CMSBitMapYieldQuantum &#x3D; 10485760 &#123;product&#125; uintx CMSBootstrapOccupancy &#x3D; 50 &#123;product&#125; bool CMSClassUnloadingEnabled &#x3D; true &#123;product&#125; uintx CMSClassUnloadingMaxInterval &#x3D; 0 &#123;product&#125; bool CMSCleanOnEnter &#x3D; true &#123;product&#125; bool CMSCompactWhenClearAllSoftRefs &#x3D; true &#123;product&#125; uintx CMSConcMarkMultiple &#x3D; 32 &#123;product&#125; bool CMSConcurrentMTEnabled &#x3D; true &#123;product&#125; uintx CMSCoordinatorYieldSleepCount &#x3D; 10 &#123;product&#125; bool CMSDumpAtPromotionFailure &#x3D; false &#123;product&#125; bool CMSEdenChunksRecordAlways &#x3D; true &#123;product&#125; uintx CMSExpAvgFactor &#x3D; 50 &#123;product&#125; bool CMSExtrapolateSweep &#x3D; false &#123;product&#125; uintx CMSFullGCsBeforeCompaction &#x3D; 0 &#123;product&#125; uintx CMSIncrementalDutyCycle &#x3D; 10 &#123;product&#125; uintx CMSIncrementalDutyCycleMin &#x3D; 0 &#123;product&#125; bool CMSIncrementalMode &#x3D; false &#123;product&#125; uintx CMSIncrementalOffset &#x3D; 0 &#123;product&#125; bool CMSIncrementalPacing &#x3D; true &#123;product&#125; uintx CMSIncrementalSafetyFactor &#x3D; 10 &#123;product&#125; uintx CMSIndexedFreeListReplenish &#x3D; 4 &#123;product&#125; intx CMSInitiatingOccupancyFraction &#x3D; -1 &#123;product&#125; uintx CMSIsTooFullPercentage &#x3D; 98 &#123;product&#125; double CMSLargeCoalSurplusPercent &#x3D; 0.950000 &#123;product&#125; double CMSLargeSplitSurplusPercent &#x3D; 1.000000 &#123;product&#125; bool CMSLoopWarn &#x3D; false &#123;product&#125; uintx CMSMaxAbortablePrecleanLoops &#x3D; 0 &#123;product&#125; intx CMSMaxAbortablePrecleanTime &#x3D; 5000 &#123;product&#125; uintx CMSOldPLABMax &#x3D; 1024 &#123;product&#125; uintx CMSOldPLABMin &#x3D; 16 &#123;product&#125; uintx CMSOldPLABNumRefills &#x3D; 4 &#123;product&#125; uintx CMSOldPLABReactivityFactor &#x3D; 2 &#123;product&#125; bool CMSOldPLABResizeQuicker &#x3D; false &#123;product&#125; uintx CMSOldPLABToleranceFactor &#x3D; 4 &#123;product&#125; bool CMSPLABRecordAlways &#x3D; true &#123;product&#125; uintx CMSParPromoteBlocksToClaim &#x3D; 16 &#123;product&#125; bool CMSParallelInitialMarkEnabled &#x3D; true &#123;product&#125; bool CMSParallelRemarkEnabled &#x3D; true &#123;product&#125; bool CMSParallelSurvivorRemarkEnabled &#x3D; true &#123;product&#125; uintx CMSPrecleanDenominator &#x3D; 3 &#123;product&#125; uintx CMSPrecleanIter &#x3D; 3 &#123;product&#125; uintx CMSPrecleanNumerator &#x3D; 2 &#123;product&#125; bool CMSPrecleanRefLists1 &#x3D; true &#123;product&#125; bool CMSPrecleanRefLists2 &#x3D; false &#123;product&#125; bool CMSPrecleanSurvivors1 &#x3D; false &#123;product&#125; bool CMSPrecleanSurvivors2 &#x3D; true &#123;product&#125; uintx CMSPrecleanThreshold &#x3D; 1000 &#123;product&#125; bool CMSPrecleaningEnabled &#x3D; true &#123;product&#125; bool CMSPrintChunksInDump &#x3D; false &#123;product&#125; bool CMSPrintEdenSurvivorChunks &#x3D; false &#123;product&#125; bool CMSPrintObjectsInDump &#x3D; false &#123;product&#125; uintx CMSRemarkVerifyVariant &#x3D; 1 &#123;product&#125; bool CMSReplenishIntermediate &#x3D; true &#123;product&#125; uintx CMSRescanMultiple &#x3D; 32 &#123;product&#125; uintx CMSSamplingGrain &#x3D; 16384 &#123;product&#125; bool CMSScavengeBeforeRemark &#x3D; false &#123;product&#125; uintx CMSScheduleRemarkEdenPenetration &#x3D; 50 &#123;product&#125; uintx CMSScheduleRemarkEdenSizeThreshold &#x3D; 2097152 &#123;product&#125; uintx CMSScheduleRemarkSamplingRatio &#x3D; 5 &#123;product&#125; double CMSSmallCoalSurplusPercent &#x3D; 1.050000 &#123;product&#125; double CMSSmallSplitSurplusPercent &#x3D; 1.100000 &#123;product&#125; bool CMSSplitIndexedFreeListBlocks &#x3D; true &#123;product&#125; intx CMSTriggerInterval &#x3D; -1 &#123;manageable&#125; uintx CMSTriggerRatio &#x3D; 80 &#123;product&#125; intx CMSWaitDuration &#x3D; 2000 &#123;manageable&#125; uintx CMSWorkQueueDrainThreshold &#x3D; 10 &#123;product&#125; bool CMSYield &#x3D; true &#123;product&#125; uintx CMSYieldSleepCount &#x3D; 0 &#123;product&#125; uintx CMSYoungGenPerWorker &#x3D; 67108864 &#123;pd product&#125; uintx CMS_FLSPadding &#x3D; 1 &#123;product&#125; uintx CMS_FLSWeight &#x3D; 75 &#123;product&#125; uintx CMS_SweepPadding &#x3D; 1 &#123;product&#125; uintx CMS_SweepTimerThresholdMillis &#x3D; 10 &#123;product&#125; uintx CMS_SweepWeight &#x3D; 75 &#123;product&#125; bool CheckEndorsedAndExtDirs &#x3D; false &#123;product&#125; bool CheckJNICalls &#x3D; false &#123;product&#125; bool ClassUnloading &#x3D; true &#123;product&#125; bool ClassUnloadingWithConcurrentMark &#x3D; true &#123;product&#125; intx ClearFPUAtPark &#x3D; 0 &#123;product&#125; bool ClipInlining &#x3D; true &#123;product&#125; uintx CodeCacheExpansionSize &#x3D; 65536 &#123;pd product&#125; uintx CodeCacheMinimumFreeSpace &#x3D; 512000 &#123;product&#125; bool CollectGen0First &#x3D; false &#123;product&#125; bool CompactFields &#x3D; true &#123;product&#125; intx CompilationPolicyChoice &#x3D; 3 &#123;product&#125; ccstrlist CompileCommand &#x3D; &#123;product&#125; ccstr CompileCommandFile &#x3D; &#123;product&#125; ccstrlist CompileOnly &#x3D; &#123;product&#125; intx CompileThreshold &#x3D; 10000 &#123;pd product&#125; bool CompilerThreadHintNoPreempt &#x3D; true &#123;product&#125; intx CompilerThreadPriority &#x3D; -1 &#123;product&#125; intx CompilerThreadStackSize &#x3D; 0 &#123;pd product&#125; uintx CompressedClassSpaceSize &#x3D; 1073741824 &#123;product&#125; uintx ConcGCThreads &#x3D; 0 &#123;product&#125; intx ConditionalMoveLimit &#x3D; 3 &#123;C2 pd product&#125; intx ContendedPaddingWidth &#x3D; 128 &#123;product&#125; bool ConvertSleepToYield &#x3D; true &#123;pd product&#125; bool ConvertYieldToSleep &#x3D; false &#123;product&#125; bool CrashOnOutOfMemoryError &#x3D; false &#123;product&#125; bool CreateMinidumpOnCrash &#x3D; false &#123;product&#125; bool CriticalJNINatives &#x3D; true &#123;product&#125; bool DTraceAllocProbes &#x3D; false &#123;product&#125; bool DTraceMethodProbes &#x3D; false &#123;product&#125; bool DTraceMonitorProbes &#x3D; false &#123;product&#125; bool Debugging &#x3D; false &#123;product&#125; uintx DefaultMaxRAMFraction &#x3D; 4 &#123;product&#125; intx DefaultThreadPriority &#x3D; -1 &#123;product&#125; intx DeferPollingPageLoopCount &#x3D; -1 &#123;product&#125; intx DeferThrSuspendLoopCount &#x3D; 4000 &#123;product&#125; bool DeoptimizeRandom &#x3D; false &#123;product&#125; bool DisableAttachMechanism &#x3D; false &#123;product&#125; bool DisableExplicitGC &#x3D; false &#123;product&#125; bool DisplayVMOutputToStderr &#x3D; false &#123;product&#125; bool DisplayVMOutputToStdout &#x3D; false &#123;product&#125; bool DoEscapeAnalysis &#x3D; true &#123;C2 product&#125; bool DontCompileHugeMethods &#x3D; true &#123;product&#125; bool DontYieldALot &#x3D; false &#123;pd product&#125; ccstr DumpLoadedClassList &#x3D; &#123;product&#125; bool DumpReplayDataOnError &#x3D; true &#123;product&#125; bool DumpSharedSpaces &#x3D; false &#123;product&#125; bool EagerXrunInit &#x3D; false &#123;product&#125; intx EliminateAllocationArraySizeLimit &#x3D; 64 &#123;C2 product&#125; bool EliminateAllocations &#x3D; true &#123;C2 product&#125; bool EliminateAutoBox &#x3D; true &#123;C2 product&#125; bool EliminateLocks &#x3D; true &#123;C2 product&#125; bool EliminateNestedLocks &#x3D; true &#123;C2 product&#125; intx EmitSync &#x3D; 0 &#123;product&#125; bool EnableContended &#x3D; true &#123;product&#125; bool EnableTracing &#x3D; false &#123;product&#125; uintx ErgoHeapSizeLimit &#x3D; 0 &#123;product&#125; ccstr ErrorFile &#x3D; &#123;product&#125; ccstr ErrorReportServer &#x3D; &#123;product&#125; double EscapeAnalysisTimeout &#x3D; 20.000000 &#123;C2 product&#125; bool EstimateArgEscape &#x3D; true &#123;product&#125; bool ExitOnOutOfMemoryError &#x3D; false &#123;product&#125; bool ExplicitGCInvokesConcurrent &#x3D; false &#123;product&#125; bool ExplicitGCInvokesConcurrentAndUnloadsClasses &#x3D; false &#123;product&#125; bool ExtendedDTraceProbes &#x3D; false &#123;product&#125; ccstr ExtraSharedClassListFile &#x3D; &#123;product&#125; bool FLSAlwaysCoalesceLarge &#x3D; false &#123;product&#125; uintx FLSCoalescePolicy &#x3D; 2 &#123;product&#125; double FLSLargestBlockCoalesceProximity &#x3D; 0.990000 &#123;product&#125; bool FailOverToOldVerifier &#x3D; true &#123;product&#125; bool FastTLABRefill &#x3D; true &#123;product&#125; intx FenceInstruction &#x3D; 0 &#123;ARCH product&#125; intx FieldsAllocationStyle &#x3D; 1 &#123;product&#125; bool FilterSpuriousWakeups &#x3D; true &#123;product&#125; bool ForceNUMA &#x3D; false &#123;product&#125; bool ForceTimeHighResolution &#x3D; false &#123;product&#125; intx FreqInlineSize &#x3D; 325 &#123;pd product&#125; double G1ConcMarkStepDurationMillis &#x3D; 10.000000 &#123;product&#125; uintx G1ConcRSHotCardLimit &#x3D; 4 &#123;product&#125; uintx G1ConcRSLogCacheSize &#x3D; 10 &#123;product&#125; intx G1ConcRefinementGreenZone &#x3D; 0 &#123;product&#125; intx G1ConcRefinementRedZone &#x3D; 0 &#123;product&#125; intx G1ConcRefinementServiceIntervalMillis &#x3D; 300 &#123;product&#125; uintx G1ConcRefinementThreads &#x3D; 0 &#123;product&#125; intx G1ConcRefinementThresholdStep &#x3D; 0 &#123;product&#125; intx G1ConcRefinementYellowZone &#x3D; 0 &#123;product&#125; uintx G1ConfidencePercent &#x3D; 50 &#123;product&#125; uintx G1HeapRegionSize &#x3D; 0 &#123;product&#125; uintx G1HeapWastePercent &#x3D; 5 &#123;product&#125; uintx G1MixedGCCountTarget &#x3D; 8 &#123;product&#125; intx G1RSetRegionEntries &#x3D; 0 &#123;product&#125; uintx G1RSetScanBlockSize &#x3D; 64 &#123;product&#125; intx G1RSetSparseRegionEntries &#x3D; 0 &#123;product&#125; intx G1RSetUpdatingPauseTimePercent &#x3D; 10 &#123;product&#125; intx G1RefProcDrainInterval &#x3D; 10 &#123;product&#125; uintx G1ReservePercent &#x3D; 10 &#123;product&#125; uintx G1SATBBufferEnqueueingThresholdPercent &#x3D; 60 &#123;product&#125; intx G1SATBBufferSize &#x3D; 1024 &#123;product&#125; intx G1UpdateBufferSize &#x3D; 256 &#123;product&#125; bool G1UseAdaptiveConcRefinement &#x3D; true &#123;product&#125; uintx GCDrainStackTargetSize &#x3D; 64 &#123;product&#125; uintx GCHeapFreeLimit &#x3D; 2 &#123;product&#125; uintx GCLockerEdenExpansionPercent &#x3D; 5 &#123;product&#125; bool GCLockerInvokesConcurrent &#x3D; false &#123;product&#125; uintx GCLogFileSize &#x3D; 8192 &#123;product&#125; uintx GCPauseIntervalMillis &#x3D; 0 &#123;product&#125; uintx GCTaskTimeStampEntries &#x3D; 200 &#123;product&#125; uintx GCTimeLimit &#x3D; 98 &#123;product&#125; uintx GCTimeRatio &#x3D; 99 &#123;product&#125; uintx HeapBaseMinAddress &#x3D; 2147483648 &#123;pd product&#125; bool HeapDumpAfterFullGC &#x3D; false &#123;manageable&#125; bool HeapDumpBeforeFullGC &#x3D; false &#123;manageable&#125; bool HeapDumpOnOutOfMemoryError &#x3D; false &#123;manageable&#125; ccstr HeapDumpPath &#x3D; &#123;manageable&#125; uintx HeapFirstMaximumCompactionCount &#x3D; 3 &#123;product&#125; uintx HeapMaximumCompactionInterval &#x3D; 20 &#123;product&#125; uintx HeapSizePerGCThread &#x3D; 87241520 &#123;product&#125; bool IgnoreEmptyClassPaths &#x3D; false &#123;product&#125; bool IgnoreUnrecognizedVMOptions &#x3D; false &#123;product&#125; uintx IncreaseFirstTierCompileThresholdAt &#x3D; 50 &#123;product&#125; bool IncrementalInline &#x3D; true &#123;C2 product&#125; uintx InitialBootClassLoaderMetaspaceSize &#x3D; 4194304 &#123;product&#125; uintx InitialCodeCacheSize &#x3D; 2555904 &#123;pd product&#125; uintx InitialHeapSize :&#x3D; 16777216 &#123;product&#125; uintx InitialRAMFraction &#x3D; 64 &#123;product&#125; double InitialRAMPercentage &#x3D; 1.562500 &#123;product&#125; uintx InitialSurvivorRatio &#x3D; 8 &#123;product&#125; uintx InitialTenuringThreshold &#x3D; 7 &#123;product&#125; uintx InitiatingHeapOccupancyPercent &#x3D; 45 &#123;product&#125; bool Inline &#x3D; true &#123;product&#125; ccstr InlineDataFile &#x3D; &#123;product&#125; intx InlineSmallCode &#x3D; 2000 &#123;pd product&#125; bool InlineSynchronizedMethods &#x3D; true &#123;C1 product&#125; bool InsertMemBarAfterArraycopy &#x3D; true &#123;C2 product&#125; intx InteriorEntryAlignment &#x3D; 16 &#123;C2 pd product&#125; intx InterpreterProfilePercentage &#x3D; 33 &#123;product&#125; bool JNIDetachReleasesMonitors &#x3D; true &#123;product&#125; bool JavaMonitorsInStackTrace &#x3D; true &#123;product&#125; intx JavaPriority10_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority1_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority2_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority3_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority4_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority5_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority6_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority7_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority8_To_OSPriority &#x3D; -1 &#123;product&#125; intx JavaPriority9_To_OSPriority &#x3D; -1 &#123;product&#125; bool LIRFillDelaySlots &#x3D; false &#123;C1 pd product&#125; uintx LargePageHeapSizeThreshold &#x3D; 134217728 &#123;product&#125; uintx LargePageSizeInBytes &#x3D; 0 &#123;product&#125; bool LazyBootClassLoader &#x3D; true &#123;product&#125; intx LiveNodeCountInliningCutoff &#x3D; 40000 &#123;C2 product&#125; bool LoadExecStackDllInVMThread &#x3D; true &#123;product&#125; intx LoopMaxUnroll &#x3D; 16 &#123;C2 product&#125; intx LoopOptsCount &#x3D; 43 &#123;C2 product&#125; intx LoopUnrollLimit &#x3D; 60 &#123;C2 pd product&#125; intx LoopUnrollMin &#x3D; 4 &#123;C2 product&#125; bool LoopUnswitching &#x3D; true &#123;C2 product&#125; bool ManagementServer &#x3D; false &#123;product&#125; uintx MarkStackSize &#x3D; 4194304 &#123;product&#125; uintx MarkStackSizeMax &#x3D; 536870912 &#123;product&#125; uintx MarkSweepAlwaysCompactCount &#x3D; 4 &#123;product&#125; uintx MarkSweepDeadRatio &#x3D; 5 &#123;product&#125; intx MaxBCEAEstimateLevel &#x3D; 5 &#123;product&#125; intx MaxBCEAEstimateSize &#x3D; 150 &#123;product&#125; uintx MaxDirectMemorySize &#x3D; 0 &#123;product&#125; bool MaxFDLimit &#x3D; true &#123;product&#125; uintx MaxGCMinorPauseMillis &#x3D; 18446744073709551615 &#123;product&#125; uintx MaxGCPauseMillis &#x3D; 18446744073709551615 &#123;product&#125; uintx MaxHeapFreeRatio &#x3D; 70 &#123;manageable&#125; uintx MaxHeapSize :&#x3D; 268435456 &#123;product&#125; intx MaxInlineLevel &#x3D; 9 &#123;product&#125; intx MaxInlineSize &#x3D; 35 &#123;product&#125; intx MaxJNILocalCapacity &#x3D; 65536 &#123;product&#125; intx MaxJavaStackTraceDepth &#x3D; 1024 &#123;product&#125; intx MaxJumpTableSize &#x3D; 65000 &#123;C2 product&#125; intx MaxJumpTableSparseness &#x3D; 5 &#123;C2 product&#125; intx MaxLabelRootDepth &#x3D; 1100 &#123;C2 product&#125; intx MaxLoopPad &#x3D; 11 &#123;C2 product&#125; uintx MaxMetaspaceExpansion &#x3D; 5451776 &#123;product&#125; uintx MaxMetaspaceFreeRatio &#x3D; 70 &#123;product&#125; uintx MaxMetaspaceSize &#x3D; 18446744073709547520 &#123;product&#125; uintx MaxNewSize :&#x3D; 89456640 &#123;product&#125; intx MaxNodeLimit &#x3D; 75000 &#123;C2 product&#125; uint64_t MaxRAM &#x3D; 137438953472 &#123;pd product&#125; uintx MaxRAMFraction &#x3D; 4 &#123;product&#125; double MaxRAMPercentage &#x3D; 25.000000 &#123;product&#125; intx MaxRecursiveInlineLevel &#x3D; 1 &#123;product&#125; uintx MaxTenuringThreshold &#x3D; 15 &#123;product&#125; intx MaxTrivialSize &#x3D; 6 &#123;product&#125; intx MaxVectorSize &#x3D; 32 &#123;C2 product&#125; uintx MetaspaceSize &#x3D; 21807104 &#123;pd product&#125; bool MethodFlushing &#x3D; true &#123;product&#125; uintx MinHeapDeltaBytes :&#x3D; 196608 &#123;product&#125; uintx MinHeapFreeRatio &#x3D; 40 &#123;manageable&#125; intx MinInliningThreshold &#x3D; 250 &#123;product&#125; intx MinJumpTableSize &#x3D; 10 &#123;C2 pd product&#125; uintx MinMetaspaceExpansion &#x3D; 339968 &#123;product&#125; uintx MinMetaspaceFreeRatio &#x3D; 40 &#123;product&#125; uintx MinRAMFraction &#x3D; 2 &#123;product&#125; double MinRAMPercentage &#x3D; 50.000000 &#123;product&#125; uintx MinSurvivorRatio &#x3D; 3 &#123;product&#125; uintx MinTLABSize &#x3D; 2048 &#123;product&#125; intx MonitorBound &#x3D; 0 &#123;product&#125; bool MonitorInUseLists &#x3D; false &#123;product&#125; intx MultiArrayExpandLimit &#x3D; 6 &#123;C2 product&#125; bool MustCallLoadClassInternal &#x3D; false &#123;product&#125; uintx NUMAChunkResizeWeight &#x3D; 20 &#123;product&#125; uintx NUMAInterleaveGranularity &#x3D; 2097152 &#123;product&#125; uintx NUMAPageScanRate &#x3D; 256 &#123;product&#125; uintx NUMASpaceResizeRate &#x3D; 1073741824 &#123;product&#125; bool NUMAStats &#x3D; false &#123;product&#125; ccstr NativeMemoryTracking &#x3D; off &#123;product&#125; bool NeedsDeoptSuspend &#x3D; false &#123;pd product&#125; bool NeverActAsServerClassMachine &#x3D; false &#123;pd product&#125; bool NeverTenure &#x3D; false &#123;product&#125; uintx NewRatio &#x3D; 2 &#123;product&#125; uintx NewSize :&#x3D; 5570560 &#123;product&#125; uintx NewSizeThreadIncrease &#x3D; 5320 &#123;pd product&#125; intx NmethodSweepActivity &#x3D; 10 &#123;product&#125; intx NmethodSweepCheckInterval &#x3D; 5 &#123;product&#125; intx NmethodSweepFraction &#x3D; 16 &#123;product&#125; intx NodeLimitFudgeFactor &#x3D; 2000 &#123;C2 product&#125; uintx NumberOfGCLogFiles &#x3D; 0 &#123;product&#125; intx NumberOfLoopInstrToAlign &#x3D; 4 &#123;C2 product&#125; intx ObjectAlignmentInBytes &#x3D; 8 &#123;lp64_product&#125; uintx OldPLABSize &#x3D; 1024 &#123;product&#125; uintx OldPLABWeight &#x3D; 50 &#123;product&#125; uintx OldSize :&#x3D; 11206656 &#123;product&#125; bool OmitStackTraceInFastThrow &#x3D; true &#123;product&#125; ccstrlist OnError &#x3D; &#123;product&#125; ccstrlist OnOutOfMemoryError &#x3D; &#123;product&#125; intx OnStackReplacePercentage &#x3D; 140 &#123;pd product&#125; bool OptimizeFill &#x3D; true &#123;C2 product&#125; bool OptimizePtrCompare &#x3D; true &#123;C2 product&#125; bool OptimizeStringConcat &#x3D; true &#123;C2 product&#125; bool OptoBundling &#x3D; false &#123;C2 pd product&#125; intx OptoLoopAlignment &#x3D; 16 &#123;pd product&#125; bool OptoScheduling &#x3D; false &#123;C2 pd product&#125; uintx PLABWeight &#x3D; 75 &#123;product&#125; bool PSChunkLargeArrays &#x3D; true &#123;product&#125; intx ParGCArrayScanChunk &#x3D; 50 &#123;product&#125; uintx ParGCDesiredObjsFromOverflowList &#x3D; 20 &#123;product&#125; bool ParGCTrimOverflow &#x3D; true &#123;product&#125; bool ParGCUseLocalOverflow &#x3D; false &#123;product&#125; uintx ParallelGCBufferWastePct &#x3D; 10 &#123;product&#125; uintx ParallelGCThreads &#x3D; 0 &#123;product&#125; bool ParallelGCVerbose &#x3D; false &#123;product&#125; uintx ParallelOldDeadWoodLimiterMean &#x3D; 50 &#123;product&#125; uintx ParallelOldDeadWoodLimiterStdDev &#x3D; 80 &#123;product&#125; bool ParallelRefProcBalancingEnabled &#x3D; true &#123;product&#125; bool ParallelRefProcEnabled &#x3D; false &#123;product&#125; bool PartialPeelAtUnsignedTests &#x3D; true &#123;C2 product&#125; bool PartialPeelLoop &#x3D; true &#123;C2 product&#125; intx PartialPeelNewPhiDelta &#x3D; 0 &#123;C2 product&#125; uintx PausePadding &#x3D; 1 &#123;product&#125; intx PerBytecodeRecompilationCutoff &#x3D; 200 &#123;product&#125; intx PerBytecodeTrapLimit &#x3D; 4 &#123;product&#125; intx PerMethodRecompilationCutoff &#x3D; 400 &#123;product&#125; intx PerMethodTrapLimit &#x3D; 100 &#123;product&#125; bool PerfAllowAtExitRegistration &#x3D; false &#123;product&#125; bool PerfBypassFileSystemCheck &#x3D; false &#123;product&#125; intx PerfDataMemorySize &#x3D; 32768 &#123;product&#125; intx PerfDataSamplingInterval &#x3D; 50 &#123;product&#125; ccstr PerfDataSaveFile &#x3D; &#123;product&#125; bool PerfDataSaveToFile &#x3D; false &#123;product&#125; bool PerfDisableSharedMem &#x3D; false &#123;product&#125; intx PerfMaxStringConstLength &#x3D; 1024 &#123;product&#125; intx PreInflateSpin &#x3D; 10 &#123;pd product&#125; bool PreferContainerQuotaForCPUCount &#x3D; true &#123;product&#125; bool PreferInterpreterNativeStubs &#x3D; false &#123;pd product&#125; intx PrefetchCopyIntervalInBytes &#x3D; 576 &#123;product&#125; intx PrefetchFieldsAhead &#x3D; 1 &#123;product&#125; intx PrefetchScanIntervalInBytes &#x3D; 576 &#123;product&#125; bool PreserveAllAnnotations &#x3D; false &#123;product&#125; bool PreserveFramePointer &#x3D; false &#123;pd product&#125; uintx PretenureSizeThreshold &#x3D; 0 &#123;product&#125; bool PrintAdaptiveSizePolicy &#x3D; false &#123;product&#125; bool PrintCMSInitiationStatistics &#x3D; false &#123;product&#125; intx PrintCMSStatistics &#x3D; 0 &#123;product&#125; bool PrintClassHistogram &#x3D; false &#123;manageable&#125; bool PrintClassHistogramAfterFullGC &#x3D; false &#123;manageable&#125; bool PrintClassHistogramBeforeFullGC &#x3D; false &#123;manageable&#125; bool PrintCodeCache &#x3D; false &#123;product&#125; bool PrintCodeCacheOnCompilation &#x3D; false &#123;product&#125; bool PrintCommandLineFlags &#x3D; false &#123;product&#125; bool PrintCompilation &#x3D; false &#123;product&#125; bool PrintConcurrentLocks &#x3D; false &#123;manageable&#125; intx PrintFLSCensus &#x3D; 0 &#123;product&#125; intx PrintFLSStatistics &#x3D; 0 &#123;product&#125; bool PrintFlagsFinal :&#x3D; true &#123;product&#125; bool PrintFlagsInitial &#x3D; false &#123;product&#125; bool PrintGC &#x3D; false &#123;manageable&#125; bool PrintGCApplicationConcurrentTime &#x3D; false &#123;product&#125; bool PrintGCApplicationStoppedTime &#x3D; false &#123;product&#125; bool PrintGCCause &#x3D; true &#123;product&#125; bool PrintGCDateStamps &#x3D; false &#123;manageable&#125; bool PrintGCDetails &#x3D; false &#123;manageable&#125; bool PrintGCID &#x3D; false &#123;manageable&#125; bool PrintGCTaskTimeStamps &#x3D; false &#123;product&#125; bool PrintGCTimeStamps &#x3D; false &#123;manageable&#125; bool PrintHeapAtGC &#x3D; false &#123;product rw&#125; bool PrintHeapAtGCExtended &#x3D; false &#123;product rw&#125; bool PrintHeapAtSIGBREAK &#x3D; true &#123;product&#125; bool PrintJNIGCStalls &#x3D; false &#123;product&#125; bool PrintJNIResolving &#x3D; false &#123;product&#125; bool PrintOldPLAB &#x3D; false &#123;product&#125; bool PrintOopAddress &#x3D; false &#123;product&#125; bool PrintPLAB &#x3D; false &#123;product&#125; bool PrintParallelOldGCPhaseTimes &#x3D; false &#123;product&#125; bool PrintPromotionFailure &#x3D; false &#123;product&#125; bool PrintReferenceGC &#x3D; false &#123;product&#125; bool PrintSafepointStatistics &#x3D; false &#123;product&#125; intx PrintSafepointStatisticsCount &#x3D; 300 &#123;product&#125; intx PrintSafepointStatisticsTimeout &#x3D; -1 &#123;product&#125; bool PrintSharedArchiveAndExit &#x3D; false &#123;product&#125; bool PrintSharedDictionary &#x3D; false &#123;product&#125; bool PrintSharedSpaces &#x3D; false &#123;product&#125; bool PrintStringDeduplicationStatistics &#x3D; false &#123;product&#125; bool PrintStringTableStatistics &#x3D; false &#123;product&#125; bool PrintTLAB &#x3D; false &#123;product&#125; bool PrintTenuringDistribution &#x3D; false &#123;product&#125; bool PrintTieredEvents &#x3D; false &#123;product&#125; bool PrintVMOptions &#x3D; false &#123;product&#125; bool PrintVMQWaitTime &#x3D; false &#123;product&#125; bool PrintWarnings &#x3D; true &#123;product&#125; uintx ProcessDistributionStride &#x3D; 4 &#123;product&#125; bool ProfileInterpreter &#x3D; true &#123;pd product&#125; bool ProfileIntervals &#x3D; false &#123;product&#125; intx ProfileIntervalsTicks &#x3D; 100 &#123;product&#125; intx ProfileMaturityPercentage &#x3D; 20 &#123;product&#125; bool ProfileVM &#x3D; false &#123;product&#125; bool ProfilerPrintByteCodeStatistics &#x3D; false &#123;product&#125; bool ProfilerRecordPC &#x3D; false &#123;product&#125; uintx PromotedPadding &#x3D; 3 &#123;product&#125; uintx QueuedAllocationWarningCount &#x3D; 0 &#123;product&#125; uintx RTMRetryCount &#x3D; 5 &#123;ARCH product&#125; bool RangeCheckElimination &#x3D; true &#123;product&#125; intx ReadPrefetchInstr &#x3D; 0 &#123;ARCH product&#125; bool ReassociateInvariants &#x3D; true &#123;C2 product&#125; bool ReduceBulkZeroing &#x3D; true &#123;C2 product&#125; bool ReduceFieldZeroing &#x3D; true &#123;C2 product&#125; bool ReduceInitialCardMarks &#x3D; true &#123;C2 product&#125; bool ReduceSignalUsage &#x3D; false &#123;product&#125; intx RefDiscoveryPolicy &#x3D; 0 &#123;product&#125; bool ReflectionWrapResolutionErrors &#x3D; true &#123;product&#125; bool RegisterFinalizersAtInit &#x3D; true &#123;product&#125; bool RelaxAccessControlCheck &#x3D; false &#123;product&#125; ccstr ReplayDataFile &#x3D; &#123;product&#125; bool RequireSharedSpaces &#x3D; false &#123;product&#125; uintx ReservedCodeCacheSize &#x3D; 251658240 &#123;pd product&#125; bool ResizeOldPLAB &#x3D; true &#123;product&#125; bool ResizePLAB &#x3D; true &#123;product&#125; bool ResizeTLAB &#x3D; true &#123;pd product&#125; bool RestoreMXCSROnJNICalls &#x3D; false &#123;product&#125; bool RestrictContended &#x3D; true &#123;product&#125; bool RewriteBytecodes &#x3D; true &#123;pd product&#125; bool RewriteFrequentPairs &#x3D; true &#123;pd product&#125; intx SafepointPollOffset &#x3D; 256 &#123;C1 pd product&#125; intx SafepointSpinBeforeYield &#x3D; 2000 &#123;product&#125; bool SafepointTimeout &#x3D; false &#123;product&#125; intx SafepointTimeoutDelay &#x3D; 10000 &#123;product&#125; bool ScavengeBeforeFullGC &#x3D; true &#123;product&#125; intx SelfDestructTimer &#x3D; 0 &#123;product&#125; uintx SharedBaseAddress &#x3D; 34359738368 &#123;product&#125; ccstr SharedClassListFile &#x3D; &#123;product&#125; uintx SharedMiscCodeSize &#x3D; 122880 &#123;product&#125; uintx SharedMiscDataSize &#x3D; 4194304 &#123;product&#125; uintx SharedReadOnlySize &#x3D; 16777216 &#123;product&#125; uintx SharedReadWriteSize &#x3D; 16777216 &#123;product&#125; bool ShowMessageBoxOnError &#x3D; false &#123;product&#125; intx SoftRefLRUPolicyMSPerMB &#x3D; 1000 &#123;product&#125; bool SpecialEncodeISOArray &#x3D; true &#123;C2 product&#125; bool SplitIfBlocks &#x3D; true &#123;C2 product&#125; intx StackRedPages &#x3D; 1 &#123;pd product&#125; intx StackShadowPages &#x3D; 20 &#123;pd product&#125; bool StackTraceInThrowable &#x3D; true &#123;product&#125; intx StackYellowPages &#x3D; 2 &#123;pd product&#125; bool StartAttachListener &#x3D; false &#123;product&#125; intx StarvationMonitorInterval &#x3D; 200 &#123;product&#125; bool StressLdcRewrite &#x3D; false &#123;product&#125; uintx StringDeduplicationAgeThreshold &#x3D; 3 &#123;product&#125; uintx StringTableSize &#x3D; 60013 &#123;product&#125; bool SuppressFatalErrorMessage &#x3D; false &#123;product&#125; uintx SurvivorPadding &#x3D; 3 &#123;product&#125; uintx SurvivorRatio &#x3D; 8 &#123;product&#125; intx SuspendRetryCount &#x3D; 50 &#123;product&#125; intx SuspendRetryDelay &#x3D; 5 &#123;product&#125; intx SyncFlags &#x3D; 0 &#123;product&#125; ccstr SyncKnobs &#x3D; &#123;product&#125; intx SyncVerbose &#x3D; 0 &#123;product&#125; uintx TLABAllocationWeight &#x3D; 35 &#123;product&#125; uintx TLABRefillWasteFraction &#x3D; 64 &#123;product&#125; uintx TLABSize &#x3D; 0 &#123;product&#125; bool TLABStats &#x3D; true &#123;product&#125; uintx TLABWasteIncrement &#x3D; 4 &#123;product&#125; uintx TLABWasteTargetPercent &#x3D; 1 &#123;product&#125; uintx TargetPLABWastePct &#x3D; 10 &#123;product&#125; uintx TargetSurvivorRatio &#x3D; 50 &#123;product&#125; uintx TenuredGenerationSizeIncrement &#x3D; 20 &#123;product&#125; uintx TenuredGenerationSizeSupplement &#x3D; 80 &#123;product&#125; uintx TenuredGenerationSizeSupplementDecay &#x3D; 2 &#123;product&#125; intx ThreadPriorityPolicy &#x3D; 0 &#123;product&#125; bool ThreadPriorityVerbose &#x3D; false &#123;product&#125; uintx ThreadSafetyMargin &#x3D; 52428800 &#123;product&#125; intx ThreadStackSize &#x3D; 1024 &#123;pd product&#125; uintx ThresholdTolerance &#x3D; 10 &#123;product&#125; intx Tier0BackedgeNotifyFreqLog &#x3D; 10 &#123;product&#125; intx Tier0InvokeNotifyFreqLog &#x3D; 7 &#123;product&#125; intx Tier0ProfilingStartPercentage &#x3D; 200 &#123;product&#125; intx Tier23InlineeNotifyFreqLog &#x3D; 20 &#123;product&#125; intx Tier2BackEdgeThreshold &#x3D; 0 &#123;product&#125; intx Tier2BackedgeNotifyFreqLog &#x3D; 14 &#123;product&#125; intx Tier2CompileThreshold &#x3D; 0 &#123;product&#125; intx Tier2InvokeNotifyFreqLog &#x3D; 11 &#123;product&#125; intx Tier3BackEdgeThreshold &#x3D; 60000 &#123;product&#125; intx Tier3BackedgeNotifyFreqLog &#x3D; 13 &#123;product&#125; intx Tier3CompileThreshold &#x3D; 2000 &#123;product&#125; intx Tier3DelayOff &#x3D; 2 &#123;product&#125; intx Tier3DelayOn &#x3D; 5 &#123;product&#125; intx Tier3InvocationThreshold &#x3D; 200 &#123;product&#125; intx Tier3InvokeNotifyFreqLog &#x3D; 10 &#123;product&#125; intx Tier3LoadFeedback &#x3D; 5 &#123;product&#125; intx Tier3MinInvocationThreshold &#x3D; 100 &#123;product&#125; intx Tier4BackEdgeThreshold &#x3D; 40000 &#123;product&#125; intx Tier4CompileThreshold &#x3D; 15000 &#123;product&#125; intx Tier4InvocationThreshold &#x3D; 5000 &#123;product&#125; intx Tier4LoadFeedback &#x3D; 3 &#123;product&#125; intx Tier4MinInvocationThreshold &#x3D; 600 &#123;product&#125; bool TieredCompilation &#x3D; true &#123;pd product&#125; intx TieredCompileTaskTimeout &#x3D; 50 &#123;product&#125; intx TieredRateUpdateMaxTime &#x3D; 25 &#123;product&#125; intx TieredRateUpdateMinTime &#x3D; 1 &#123;product&#125; intx TieredStopAtLevel &#x3D; 4 &#123;product&#125; bool TimeLinearScan &#x3D; false &#123;C1 product&#125; bool TraceBiasedLocking &#x3D; false &#123;product&#125; bool TraceClassLoading &#x3D; false &#123;product rw&#125; bool TraceClassLoadingPreorder &#x3D; false &#123;product&#125; bool TraceClassPaths &#x3D; false &#123;product&#125; bool TraceClassResolution &#x3D; false &#123;product&#125; bool TraceClassUnloading &#x3D; false &#123;product rw&#125; bool TraceDynamicGCThreads &#x3D; false &#123;product&#125; bool TraceGen0Time &#x3D; false &#123;product&#125; bool TraceGen1Time &#x3D; false &#123;product&#125; ccstr TraceJVMTI &#x3D; &#123;product&#125; bool TraceLoaderConstraints &#x3D; false &#123;product rw&#125; bool TraceMetadataHumongousAllocation &#x3D; false &#123;product&#125; bool TraceMonitorInflation &#x3D; false &#123;product&#125; bool TraceParallelOldGCTasks &#x3D; false &#123;product&#125; intx TraceRedefineClasses &#x3D; 0 &#123;product&#125; bool TraceSafepointCleanupTime &#x3D; false &#123;product&#125; bool TraceSuspendWaitFailures &#x3D; false &#123;product&#125; intx TrackedInitializationLimit &#x3D; 50 &#123;C2 product&#125; bool TransmitErrorReport &#x3D; false &#123;product&#125; bool TrapBasedNullChecks &#x3D; false &#123;pd product&#125; bool TrapBasedRangeChecks &#x3D; false &#123;C2 pd product&#125; intx TypeProfileArgsLimit &#x3D; 2 &#123;product&#125; uintx TypeProfileLevel &#x3D; 111 &#123;pd product&#125; intx TypeProfileMajorReceiverPercent &#x3D; 90 &#123;C2 product&#125; intx TypeProfileParmsLimit &#x3D; 2 &#123;product&#125; intx TypeProfileWidth &#x3D; 2 &#123;product&#125; intx UnguardOnExecutionViolation &#x3D; 0 &#123;product&#125; bool UnlinkSymbolsALot &#x3D; false &#123;product&#125; bool Use486InstrsOnly &#x3D; false &#123;ARCH product&#125; bool UseAES &#x3D; true &#123;product&#125; bool UseAESIntrinsics &#x3D; true &#123;product&#125; intx UseAVX &#x3D; 2 &#123;ARCH product&#125; bool UseAdaptiveGCBoundary &#x3D; false &#123;product&#125; bool UseAdaptiveGenerationSizePolicyAtMajorCollection &#x3D; true &#123;product&#125; bool UseAdaptiveGenerationSizePolicyAtMinorCollection &#x3D; true &#123;product&#125; bool UseAdaptiveNUMAChunkSizing &#x3D; true &#123;product&#125; bool UseAdaptiveSizeDecayMajorGCCost &#x3D; true &#123;product&#125; bool UseAdaptiveSizePolicy &#x3D; true &#123;product&#125; bool UseAdaptiveSizePolicyFootprintGoal &#x3D; true &#123;product&#125; bool UseAdaptiveSizePolicyWithSystemGC &#x3D; false &#123;product&#125; bool UseAddressNop &#x3D; true &#123;ARCH product&#125; bool UseAltSigs &#x3D; false &#123;product&#125; bool UseAutoGCSelectPolicy &#x3D; false &#123;product&#125; bool UseBMI1Instructions &#x3D; true &#123;ARCH product&#125; bool UseBMI2Instructions &#x3D; true &#123;ARCH product&#125; bool UseBiasedLocking &#x3D; true &#123;product&#125; bool UseBimorphicInlining &#x3D; true &#123;C2 product&#125; bool UseBoundThreads &#x3D; true &#123;product&#125; bool UseCLMUL &#x3D; true &#123;ARCH product&#125; bool UseCMSBestFit &#x3D; true &#123;product&#125; bool UseCMSCollectionPassing &#x3D; true &#123;product&#125; bool UseCMSCompactAtFullCollection &#x3D; true &#123;product&#125; bool UseCMSInitiatingOccupancyOnly &#x3D; false &#123;product&#125; bool UseCRC32Intrinsics &#x3D; true &#123;product&#125; bool UseCodeCacheFlushing &#x3D; true &#123;product&#125; bool UseCompiler &#x3D; true &#123;product&#125; bool UseCompilerSafepoints &#x3D; true &#123;product&#125; bool UseCompressedClassPointers :&#x3D; true &#123;lp64_product&#125; bool UseCompressedOops :&#x3D; true &#123;lp64_product&#125; bool UseConcMarkSweepGC &#x3D; false &#123;product&#125; bool UseCondCardMark &#x3D; false &#123;C2 product&#125; bool UseContainerSupport &#x3D; true &#123;product&#125; bool UseCountLeadingZerosInstruction &#x3D; true &#123;ARCH product&#125; bool UseCountTrailingZerosInstruction &#x3D; true &#123;ARCH product&#125; bool UseCountedLoopSafepoints &#x3D; false &#123;C2 product&#125; bool UseCounterDecay &#x3D; true &#123;product&#125; bool UseDivMod &#x3D; true &#123;C2 product&#125; bool UseDynamicNumberOfGCThreads &#x3D; false &#123;product&#125; bool UseFPUForSpilling &#x3D; true &#123;C2 product&#125; bool UseFastAccessorMethods &#x3D; false &#123;product&#125; bool UseFastEmptyMethods &#x3D; false &#123;product&#125; bool UseFastJNIAccessors &#x3D; true &#123;product&#125; bool UseFastStosb &#x3D; true &#123;ARCH product&#125; bool UseG1GC &#x3D; false &#123;product&#125; bool UseGCLogFileRotation &#x3D; false &#123;product&#125; bool UseGCOverheadLimit &#x3D; true &#123;product&#125; bool UseGCTaskAffinity &#x3D; false &#123;product&#125; bool UseHeavyMonitors &#x3D; false &#123;product&#125; bool UseHugeTLBFS &#x3D; false &#123;product&#125; bool UseInlineCaches &#x3D; true &#123;product&#125; bool UseInterpreter &#x3D; true &#123;product&#125; bool UseJumpTables &#x3D; true &#123;C2 product&#125; bool UseLWPSynchronization &#x3D; true &#123;product&#125; bool UseLargePages &#x3D; false &#123;pd product&#125; bool UseLargePagesInMetaspace &#x3D; false &#123;product&#125; bool UseLargePagesIndividualAllocation &#x3D; false &#123;pd product&#125; bool UseLinuxPosixThreadCPUClocks &#x3D; true &#123;product&#125; bool UseLockedTracing &#x3D; false &#123;product&#125; bool UseLoopCounter &#x3D; true &#123;product&#125; bool UseLoopInvariantCodeMotion &#x3D; true &#123;C1 product&#125; bool UseLoopPredicate &#x3D; true &#123;C2 product&#125; bool UseMathExactIntrinsics &#x3D; true &#123;C2 product&#125; bool UseMaximumCompactionOnSystemGC &#x3D; true &#123;product&#125; bool UseMembar &#x3D; false &#123;pd product&#125; bool UseMontgomeryMultiplyIntrinsic &#x3D; true &#123;C2 product&#125; bool UseMontgomerySquareIntrinsic &#x3D; true &#123;C2 product&#125; bool UseMulAddIntrinsic &#x3D; true &#123;C2 product&#125; bool UseMultiplyToLenIntrinsic &#x3D; true &#123;C2 product&#125; bool UseNUMA &#x3D; false &#123;product&#125; bool UseNUMAInterleaving &#x3D; false &#123;product&#125; bool UseNewLongLShift &#x3D; false &#123;ARCH product&#125; bool UseOSErrorReporting &#x3D; false &#123;pd product&#125; bool UseOldInlining &#x3D; true &#123;C2 product&#125; bool UseOnStackReplacement &#x3D; true &#123;pd product&#125; bool UseOnlyInlinedBimorphic &#x3D; true &#123;C2 product&#125; bool UseOprofile &#x3D; false &#123;product&#125; bool UseOptoBiasInlining &#x3D; true &#123;C2 product&#125; bool UsePSAdaptiveSurvivorSizePolicy &#x3D; true &#123;product&#125; bool UseParNewGC &#x3D; false &#123;product&#125; bool UseParallelGC &#x3D; false &#123;product&#125; bool UseParallelOldGC &#x3D; false &#123;product&#125; bool UsePerfData &#x3D; true &#123;product&#125; bool UsePopCountInstruction &#x3D; true &#123;product&#125; bool UseRDPCForConstantTableBase &#x3D; false &#123;C2 product&#125; bool UseRTMDeopt &#x3D; false &#123;ARCH product&#125; bool UseRTMLocking &#x3D; false &#123;ARCH product&#125; bool UseSHA &#x3D; false &#123;product&#125; bool UseSHA1Intrinsics &#x3D; false &#123;product&#125; bool UseSHA256Intrinsics &#x3D; false &#123;product&#125; bool UseSHA512Intrinsics &#x3D; false &#123;product&#125; bool UseSHM &#x3D; false &#123;product&#125; intx UseSSE &#x3D; 4 &#123;product&#125; bool UseSSE42Intrinsics &#x3D; true &#123;product&#125; bool UseSerialGC &#x3D; false &#123;product&#125; bool UseSharedSpaces &#x3D; false &#123;product&#125; bool UseSignalChaining &#x3D; true &#123;product&#125; bool UseSquareToLenIntrinsic &#x3D; true &#123;C2 product&#125; bool UseStoreImmI16 &#x3D; false &#123;ARCH product&#125; bool UseStringDeduplication &#x3D; false &#123;product&#125; bool UseSuperWord &#x3D; true &#123;C2 product&#125; bool UseTLAB &#x3D; true &#123;pd product&#125; bool UseThreadPriorities &#x3D; true &#123;pd product&#125; bool UseTransparentHugePages &#x3D; false &#123;product&#125; bool UseTypeProfile &#x3D; true &#123;product&#125; bool UseTypeSpeculation &#x3D; true &#123;C2 product&#125; bool UseUnalignedLoadStores &#x3D; true &#123;ARCH product&#125; bool UseVMInterruptibleIO &#x3D; false &#123;product&#125; bool UseXMMForArrayCopy &#x3D; true &#123;product&#125; bool UseXmmI2D &#x3D; false &#123;ARCH product&#125; bool UseXmmI2F &#x3D; false &#123;ARCH product&#125; bool UseXmmLoadAndClearUpper &#x3D; true &#123;ARCH product&#125; bool UseXmmRegToRegMoveAll &#x3D; true &#123;ARCH product&#125; bool VMThreadHintNoPreempt &#x3D; false &#123;product&#125; intx VMThreadPriority &#x3D; -1 &#123;product&#125; intx VMThreadStackSize &#x3D; 1024 &#123;pd product&#125; intx ValueMapInitialSize &#x3D; 11 &#123;C1 product&#125; intx ValueMapMaxLoopSize &#x3D; 8 &#123;C1 product&#125; intx ValueSearchLimit &#x3D; 1000 &#123;C2 product&#125; bool VerifyMergedCPBytecodes &#x3D; true &#123;product&#125; bool VerifySharedSpaces &#x3D; false &#123;product&#125; intx WorkAroundNPTLTimedWaitHang &#x3D; 1 &#123;product&#125; uintx YoungGenerationSizeIncrement &#x3D; 20 &#123;product&#125; uintx YoungGenerationSizeSupplement &#x3D; 80 &#123;product&#125; uintx YoungGenerationSizeSupplementDecay &#x3D; 8 &#123;product&#125; uintx YoungPLABSize &#x3D; 4096 &#123;product&#125; bool ZeroTLAB &#x3D; false &#123;product&#125; intx hashCode &#x3D; 5 &#123;product&#125; openjdk version &quot;1.8.0_222&quot; OpenJDK Runtime Environment (build 1.8.0_222-b10) OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode) 加上 grep 立马能看到参数的默认值，比如在我的机器上 ParallelGCThreads 默认值为 0 work@permission-center-portal-6df6466c6c-qhhwq:~$ java -XX:+PrintFlagsFinal -version | grep &quot;ParallelGCThreads&quot; uintx ParallelGCThreads &#x3D; 0 &#123;product&#125; openjdk version &quot;1.8.0_222&quot; OpenJDK Runtime Environment (build 1.8.0_222-b10) OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode) work@permission-center-portal-6df6466c6c-qhhwq:~$ 垃圾回收器相关 CMS -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 显式声明垃圾回收器为CMS+parNew+Serial Old集合，Serial Old收集器将作为CMS回收器出现”Concurrent Mode Failure”失败后的备用收集器。 -XX:CMSInitiatingOccupancyFraction&#x3D;75 -XX:+UseCMSInitiatingOccupancyOnly 这两个设置一般配合使用,一般用于『降低CMS GC频率或者增加频率、减少GC时长』的需求。前一个参数是指设定CMS在对内存占用率达到70%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC);后一个参数只是用设定的回收阈值(上面指定的75%),如果不指定,JVM仅在第一次使用设定值,后续则自动调整。 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction&#x3D;0 CMS GC是并发的垃圾回收器，它采用的是标记清除算法，而不是压缩算法。意味着随着时间的推移，碎片会越来越多，JVM终究会触发内存整理这个动作。 -XX:+UseCMSCompactAtFullCollection 表示开启压缩 -XX:CMSFullGCsBeforeCompaction=0 表示在压缩（compaction）内存之前需要发生多少次不压缩内存的FGC。CMS GC不是FGC，在CMS GC搞不定的时候（比如：concurrent mode failure），会触发完全STW但不压缩内存的FGC（假定命名为NoCompactFGC），或者触发完全STW并且压缩内存的FGC（假定命名为CompactFGC）。所以，这个参数的意思就是，连续多少次NoCompactFGC后触发CompactFGC。如果中间出现了CMS GC，那么又需要重新计数NoCompactFGC发生的次数。 -XX:+CMSScavengeBeforeRemark 在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销—–一般CMS的GC耗时 80%都在remark阶段 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasse 1、只有在使用CMS时才有效。 2、当调用System.gc()时会用CMS这个并行垃圾回收器去进行回收（比如大量使用DirectByteBuffer进行堆外内存操作，需要FGC来回收堆外内存的场景。就可以通过该参数让本来需要FGC才能搞定的事情用CMS GC就可以搞定了）。 3、除了能唤起并行垃圾回收器，还能卸载类。 -XX:ConcGCThreads&#x3D;2 CMS默认启动的并发线程数 ConcGCThreads =（ParallelGCThreads + 3）/4 -XX:+CMSParallelRemarkEnabled 为了减少重新标记第二次暂停的时间，开启并行remark -XX:+CMSScavengeBeforeRemark 如果remark还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark选项，强制remark之前开始一次minor gc，减少remark的暂停时间，但是在remark之后也将立即开始又一次minor gc。 ParNew -XX:ParallelGCThreads&#x3D;2 ParallelGCThreads 是使用 ParNew 收集器时，使用的并行GC线程数。 从OpenJdk 8 源码中可以看出，CPU数量决定了ParallelGCThreads 的取值（如果CPU开启了超线程，ncpus 实际上是逻辑CPU数）： 当CPU数量小于8时，ParallelGCThreads = ncpus 当CPU数量大于8时，ParallelGCThreads = 8 + (ncpus - 8 ) ( 5/8 ) 如果你希望降低这个线程数，可以通过-XX:ParallelGCThreads= N 来调整。 JMM内存参数 堆 -Xmx4g -Xms4g -Xmn1512m 通过堆的最小值参数-Xms参数与堆的最大值参数-Xmx设置为一样4G，避免堆自动扩展。通过-Xmn设置年轻代大概是1.5G，老年代也就是剩余大概是2.5G。 建议：-Xmx=最大物理内存*[0.60.8]。物理内存4G，Xmx为2.4g3.2g为佳。 栈 -Xss256k JDK8默认的线程栈大小为1M，有点偏大。以笔者的经验，绝大部分微服务项目是可以调整为512k，甚至256k的（笔者的项目就是256k，运行的棒棒哒）。 元数据空间 -XX:MaxMetaspaceSize&#x3D;256m -XX:MetaspaceSize&#x3D;256M 如果是微服务架构，那么对于绝大部分应用来说，128M的元数据完全够用。不过，JDK8的元数据空间并不是指定多少就初始化多大的空间。而是按需扩展元数据空间。所以，我们可以设置256M。如果不设置这两个参数的话，元数据空间默认初始化只有20M出头，那么就会在应用启动过程中，Metaspace扩容发生FGC。 -XX:MaxDirectMemorySize -XX:NewRatio -XX:G1NewSizePercent&#x3D;5 -XX:G1MaxNewSizePercent&#x3D;60 GC相关 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:&#x2F;data&#x2F;log&#x2F;gclog&#x2F;gc.log 输出虚拟机中GC的详细情况。 -verbose:gc //在控制台输出GC情况 -XX:+PrintGCDetails //在控制台输出详细的GC情况 -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） -Xloggc: filepath //将GC日志输出到指定文件中 [Full GC 168K-&gt;97K(1984K)， 0.0253873 secs] 解读如下: 箭头前后的数据168K和97K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有168K-97K=71K的对象容量被回收，括号内的数据1984K为堆内存的总容量，收集所需要的时间是0.0253873秒（这个时间在每次执行的时候会有所不同） -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;log&#x2F;jvmdump&#x2F; 设定如下两个参数（需要说明的是，HeapDumpPath参数指定的路径需要提前创建好，JVM没办法在生成dump文件时创建该目录），当JVM内存导致导致JVM进程退出时能自动在该目录下生成dump文件。 -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5 -XX:GCLogFileSize&#x3D;50M -Xloggc:&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;var&#x2F;log&#x2F;gc.log 不推荐 -XX:+UseGCLogFileRotation。打开或关闭GC日志滚动记录功能，要求必须设置 -Xloggc参数 -XX:NumberOfGCLogFiles 设置滚动日志文件的个数，必须大于等于1 -XX:GCLogFileSize 设置滚动日志文件的大小，必须大于8k。当前写日志文件大小超过该参数值时，日志将写入下一个文件 https://zhuanlan.zhihu.com/p/71221926 -XX:ErrorFile&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;var&#x2F;log&#x2F;jvm_err.log 其他 参数校验 校验JVM参数的网址：https://opts.console.heapdump.cn/ 引用 听我的！生产环境的CMS垃圾回收，一定要这样配置参数 JVM认知的常见10个误区 一次帮助云上客户 JVM 调优的记录 JVM GC算法 CMS 详解(转) CMS GC启动参数优化配置","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"CMS垃圾回收器","slug":"jvm-cms","date":"2022-03-12T09:48:06.000Z","updated":"2022-03-12T03:25:06.321Z","comments":true,"path":"2022/03/12/jvm-cms/","link":"","permalink":"http://www.yipinxieli.com/2022/03/12/jvm-cms/","excerpt":"CMS(Concurrent Mark Sweep)收集器，以获取最短回收停顿时间【也就是指Stop The World的停顿时间】为目标，多数应用于互联网站或者B/S系统的服务器端上。其中Concurrent并发是指垃圾收集的线程和用户执行的线程是可以同时执行的。","text":"CMS(Concurrent Mark Sweep)收集器，以获取最短回收停顿时间【也就是指Stop The World的停顿时间】为目标，多数应用于互联网站或者B/S系统的服务器端上。其中Concurrent并发是指垃圾收集的线程和用户执行的线程是可以同时执行的。 CMS 垃圾回收器 CMS垃圾回收特点 cms只会回收老年代和永久带（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻代；cms是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，JDK1.6之后默认是老年代或永久带达到92%； CMS默认启动的回收线程是（处理器核心数量+3 / 4 CMS收集器 CMS是基于“标记-清除”算法实现的，整个过程分为4个步骤：1、初始标记（CMS initial mark）。2、并发标记（CMS concurrent mark）。3、重新标记（CMS remark）。4、并发清除（CMS concurrent sweep）。 注意：“标记”是指将存活的对象和要回收的对象都给标记出来，而“清除”是指清除掉将要回收的对象。 其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。 初始标记只是标记一下GC Roots能直接关联到的对象，速度很快。 并发标记阶段就是从GC Roots开始找到它能引用的所有其它对象的过程。 重新标记阶段则是为了修正并发标记期间因用户程序继续动作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 CMS收集器的动作步骤如下图所示，在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的： 优点：并发收集、低停顿【注意：这里的停顿指的是停止用户线程】 缺点：1、CMS收集器对CPU资源非常敏感2、CMS收集器无法处理浮动垃圾（Floating Garbage，就是指在之前判断该对象不是垃圾，由于用户线程同时也是在运行过程中的，所以会导致判断不准确的， 可能在判断完成之后在清除之前这个对像已经变成了垃圾对象，所以有可能本该此垃圾被回收但是没有被回收，只能等待下一次GC再将该对象回收，所以这种对像就是浮动垃圾）,可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。如果在应用中老年代增长不是太快，可能适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案:临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。3、收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次Full GC。CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后仍然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象空间的平均值作为经验值），则进行一次Full GC。 CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次‘’并发失败‘，这时候虚拟机将不得不启动后备预案：冻结用户县城的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样老年代的停顿时间更长了。 引用 CMS垃圾收集器深入详解 CMS垃圾回收器详解 听我的！生产环境的CMS垃圾回收，一定要这样配置参数 从实际案例聊聊Java应用的GC优化","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"Parallel Scanvenge收集器","slug":"jvm-Parallel Scanvenge","date":"2022-03-06T16:17:31.000Z","updated":"2022-03-06T16:57:46.496Z","comments":true,"path":"2022/03/07/jvm-Parallel Scanvenge/","link":"","permalink":"http://www.yipinxieli.com/2022/03/07/jvm-Parallel%20Scanvenge/","excerpt":"如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。","text":"如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。 Parallel Scanvenge垃圾回收器 Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量 。 吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间) 比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量=(120-1)/120=99.167%。 若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。 可设置参数： -XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， -XX:GC Time Ratio直接设置吞吐量的大小。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"ParNew收集器","slug":"jvm-parNew","date":"2022-03-06T16:17:31.000Z","updated":"2022-03-20T04:01:18.573Z","comments":true,"path":"2022/03/07/jvm-parNew/","link":"","permalink":"http://www.yipinxieli.com/2022/03/07/jvm-parNew/","excerpt":"如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。","text":"如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。 ParNew垃圾回收器 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如图3-7所示。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 可以把这个收集器理解为Serial收集器的多线程版本。 它是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。 ParNew收集器也是使用 -XX: +UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC选项来强制指定它。 优点：在多CPU时，比Serial效率高。 缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。 算法：复制算法 应用：早期运行在Server模式下的虚拟机中首选的新生代收集器","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"Java 虚拟机进程状态工具jps","slug":"jvm-command-jps","date":"2022-03-01T09:48:06.000Z","updated":"2022-03-01T10:27:52.366Z","comments":true,"path":"2022/03/01/jvm-command-jps/","link":"","permalink":"http://www.yipinxieli.com/2022/03/01/jvm-command-jps/","excerpt":"JPS列出目标系统上的Java虚拟机，即Java进程。","text":"JPS列出目标系统上的Java虚拟机，即Java进程。 Java 虚拟机进程状态工具JPS 语法 jps [ options ] [ hostid ] 用于列出HotSpot虚拟机； 需要有访问权限才能显示在列表中； 如果没有指定hostid，列出本机的JVMs； 指定了hostid，则使用指定的协议和端口搜索目标主机上的JVMs； jps命令为搜索到的JVMs会列出本地的JVM标识或者lvmid；如果没有任何指定，则是lmid，加上应用或者jar文件名称的简写（省略包信息或者jar的路径）； jps通过Java启动器来查找main方法的类名和参数，如果JVM是自定义启动器，main方法的类或者jar文件的名称和参数不可用，输出 Unknown； jps列出JVMs受执行该命令的用户权限限制； C:\\Users\\wang&gt;jps 16324 8676 RemoteMavenServer36 19960 Application 22808 Jps 10668 RemoteJdbcServer 12668 22124 RemoteJdbcServer options q禁止输出main方法的类或者jar文件的名称和参数 C:\\Users\\wang&gt;jps -q 16324 8676 19960 10668 12668 22124 6492 m输出main方法的参数，JVM自带参数不会输出 C:\\Users\\wang&gt;jps -m 16324 19060 Jps -m 8676 RemoteMavenServer36 19960 Application 10668 RemoteJdbcServer com.mysql.cj.jdbc.Driver 12668 22124 RemoteJdbcServer com.mysql.jdbc.Driver l输出应用主类的完整包路径名称或者jar文件的全路径名称 C:\\Users\\wang&gt;jps -l 16324 8676 org.jetbrains.idea.maven.server.RemoteMavenServer36 1272 sun.tools.jps.Jps 19960 com.rrcq.authority.api.Application 10668 com.intellij.database.remote.RemoteJdbcServer 12668 22124 com.intellij.database.remote.RemoteJdbcServer v输出JVM的参数 C:\\Users\\wang&gt;jps -v 16324 exit -XX:ReservedCodeCacheSize&#x3D;512m -Xmx2026m -Xms128m -XX:+UseG1GC -XX:SoftRefLRUPolicyMSPerMB&#x3D;50 -XX:CICompilerCount&#x3D;2 -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -ea -Dsun.io.useCanonCaches&#x3D;false -Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot; -Djdk.attach.allowAttachSelf&#x3D;true -Djdk.module.illegalAccess.silent&#x3D;true -Dkotlinx.coroutines.debug&#x3D;off -Djb.vmOptionsFile&#x3D;C:\\Users\\wang\\AppData\\Roaming\\JetBrains\\DataGrip2021.2\\datagrip64.exe.vmoptions -Djava.system.class.loader&#x3D;com.intellij.util.lang.PathClassLoader -Didea.vendor.name&#x3D;JetBrains -Didea.paths.selector&#x3D;DataGrip2021.2 -Didea.platform.prefix&#x3D;DataGrip -Dide.native.launcher&#x3D;true -XX:ErrorFile&#x3D;C:\\Users\\wang\\java_error_in_datagrip64_%p.log -XX:HeapDumpPath&#x3D;C:\\Users\\wang\\java_error_in_datagrip64.hprof 8676 RemoteMavenServer36 -Djava.awt.headless&#x3D;true -Dmaven.defaultProjectBuilder.disableGlobalModelCache&#x3D;true -Didea.version&#x3D;2021.1.3 -Didea.maven.embedder.version&#x3D;3.6.3 -Xmx768m -Dfile.encoding&#x3D;GBK 19960 Application -agentlib:jdwp&#x3D;transport&#x3D;dt_socket,address&#x3D;127.0.0.1:1065,suspend&#x3D;y,server&#x3D;n -XX:TieredStopAtLevel&#x3D;1 -Xverify:none -Dspring.output.ansi.enabled&#x3D;always -javaagent:C:\\Users\\wang\\AppData\\Local\\JetBrains\\IntelliJIdea2021.1\\captureAgent\\debugger-agent.jar -Dcom.sun.management.jmxremote -Dspring.jmx.enabled&#x3D;true -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled&#x3D;true -Dfile.encoding&#x3D;UTF-8 10668 RemoteJdbcServer -Djava.rmi.server.hostname&#x3D;127.0.0.1 -Duser.timezone&#x3D;UTC -Xmx2026m -Xms128m -Dfile.encoding&#x3D;UTF-8 12668 exit -Xms128m -Xmx2026m -XX:ReservedCodeCacheSize&#x3D;512m -XX:+UseG1GC -XX:SoftRefLRUPolicyMSPerMB&#x3D;50 -XX:CICompilerCount&#x3D;2 -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -ea -Dsun.io.useCanonCaches&#x3D;false -Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot; -Djdk.attach.allowAttachSelf&#x3D;true -Djdk.module.illegalAccess.silent&#x3D;true -Dkotlinx.coroutines.debug&#x3D;off -Djb.vmOptionsFile&#x3D;C:\\Users\\wang\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.1\\idea64.exe.vmoptions -Didea.jre.check&#x3D;true -Dide.native.launcher&#x3D;true -Didea.vendor.name&#x3D;JetBrains -Didea.paths.selector&#x3D;IntelliJIdea2021.1 -XX:ErrorFile&#x3D;C:\\Users\\wang\\java_error_in_idea64_%p.log -XX:HeapDumpPath&#x3D;C:\\Users\\wang\\java_error_in_idea64.hprof 22124 RemoteJdbcServer -Djava.rmi.server.hostname&#x3D;127.0.0.1 -Duser.timezone&#x3D;UTC -Xmx2026m -Xms128m -Dfile.encoding&#x3D;UTF-8 9964 Jps -Dapplication.home&#x3D;C:\\Program Files\\Java\\jdk1.8.0_121 -Xms8m 引用 JPS Java自带JVM监控工具jps使用详细说明","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"Serial收集器","slug":"jvm-serial","date":"2022-02-27T16:17:31.000Z","updated":"2022-03-01T06:05:34.681Z","comments":true,"path":"2022/02/28/jvm-serial/","link":"","permalink":"http://www.yipinxieli.com/2022/02/28/jvm-serial/","excerpt":"如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。","text":"如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是具体实现。jvm会结合针对不同的场景及用户的配置使用不同的收集器。 Serial垃圾回收器 现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器。常用的7种收集器，其适用的范围如图所示 年轻代收集器 Serial、ParNew、Parallel Scavenge 老年代收集器 Serial Old、Parallel Old、CMS收集器 特殊收集器 G1收集器[新型，不在年轻、老年代范畴内] Serial Serial 收集器是最基础、历史最悠久的收集器，曾经（JDK1.3.1之前） 是HotSpot 新生代收集器的唯一选择，对应的老年代是 Serial Old 收集器。 Serial:基于复制算法，Serial Old：基于标记-整理算法。 两大特点： 1.使用一个处理器或一条收集线程取完成垃圾收集工作； 2.进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。 缺点： 多线程环境下，效率低下。 优点： 1.简单而高效，迄今为止仍然时HotSpot 虚拟机在客户端模式下的默认新生代收集器； 2.在所有收集器里额外内存消耗最小。 查看JVM使用的默认的垃圾收集器 cmd执行命令： java -XX:+PrintCommandLineFlags -version 输出如下（举例）： C:\\Users\\wang&gt;java -XX:+PrintCommandLineFlags -version -XX:InitialHeapSize&#x3D;265625408 -XX:MaxHeapSize&#x3D;4250006528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC java version &quot;1.8.0_121&quot; Java(TM) SE Runtime Environment (build 1.8.0_121-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode) 自JDK7u4开始的JDK7u系列与JDK8系列，如果指定了：-XX:+UseParallelGC，则会默认开启：XX:+UseParallelOldGC 。 验证默认垃圾回收器 简单的controller代码 @RestController @RequestMapping(&quot;&#x2F;jvm&quot;) @Slf4j public class JvmController &#123; static List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;(); @RequestMapping(&quot;&#x2F;addlist&quot;) public void lust(@RequestParam(&quot;value&quot;) Integer value) throws InterruptedException &#123; byte[] bytes &#x3D; new byte[value * 1024 * 1024]; list.add(bytes); &#125; @RequestMapping(&quot;&#x2F;clearlist&quot;) public void clearlist() throws InterruptedException &#123; list.clear(); &#125; &#125; JVM参数,显式使用-XX:+UseParallelGC -Xms100M -Xmx100M -Xmn70M -XX:PretenureSizeThreshold&#x3D;5M -XX:+UseParallelGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCCause -Xloggc:gc-old.log -verbose:gc 启动SpringBoot项目 C:\\Users\\wang&gt;jps 14864 RemoteJdbcServer 16324 1716 Launcher 21492 Jps 10492 Application 10668 RemoteJdbcServer 10796 RemoteMavenServer36 12668 C:\\Users\\wang&gt;jmap -heap 10492 Attaching to process ID 10492, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.121-b13 using thread-local object allocation. Parallel GC with 8 thread(s) Heap Configuration: MinHeapFreeRatio &#x3D; 0 MaxHeapFreeRatio &#x3D; 100 MaxHeapSize &#x3D; 104857600 (100.0MB) NewSize &#x3D; 73400320 (70.0MB) MaxNewSize &#x3D; 73400320 (70.0MB) OldSize &#x3D; 31457280 (30.0MB) NewRatio &#x3D; 2 SurvivorRatio &#x3D; 8 MetaspaceSize &#x3D; 21807104 (20.796875MB) CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB) MaxMetaspaceSize &#x3D; 17592186044415 MB G1HeapRegionSize &#x3D; 0 (0.0MB) Heap Usage: PS Young Generation Eden Space: capacity &#x3D; 31457280 (30.0MB) used &#x3D; 14946488 (14.254081726074219MB) free &#x3D; 16510792 (15.745918273925781MB) 47.51360575358073% used From Space: capacity &#x3D; 20971520 (20.0MB) used &#x3D; 13754640 (13.117446899414062MB) free &#x3D; 7216880 (6.8825531005859375MB) 65.58723449707031% used To Space: capacity &#x3D; 20971520 (20.0MB) used &#x3D; 0 (0.0MB) free &#x3D; 20971520 (20.0MB) 0.0% used PS Old Generation capacity &#x3D; 31457280 (30.0MB) used &#x3D; 20363760 (19.420394897460938MB) free &#x3D; 11093520 (10.579605102539062MB) 64.73464965820312% used 20519 interned Strings occupying 1861040 bytes. 然后我们不断地调用 http://localhost/jvm/addlist?value=10 很容易就能触发old gc。 此时，查看我们的gc日志，下边红色我标出了ParOldGen字样： 2022-03-01T11:14:24.031+0800: 451.667: [Full GC (Ergonomics) [PSYoungGen: 12566K-&gt;3792K(51712K)] [ParOldGen: 30158K-&gt;30275K(30720K)] 42725K-&gt;34067K(82432K), [Metaspace: 53823K-&gt;53480K(1099776K)], 0.1418099 secs] [Times: user&#x3D;0.70 sys&#x3D;0.00, real&#x3D;0.14 secs] 2022-03-01T11:14:25.402+0800: 453.037: [Full GC (Ergonomics) [PSYoungGen: 25764K-&gt;23188K(51712K)] [ParOldGen: 30275K-&gt;27887K(30720K)] 56039K-&gt;51076K(82432K), [Metaspace: 53480K-&gt;53480K(1099776K)], 0.1561581 secs] [Times: user&#x3D;0.69 sys&#x3D;0.00, real&#x3D;0.16 secs] 2022-03-01T11:14:25.559+0800: 453.194: [Full GC (Allocation Failure) [PSYoungGen: 23188K-&gt;23176K(51712K)] [ParOldGen: 27887K-&gt;27720K(30720K)] 51076K-&gt;50897K(82432K), [Metaspace: 53480K-&gt;53457K(1099776K)], 0.2252083 secs] [Times: user&#x3D;0.91 sys&#x3D;0.00, real&#x3D;0.22 secs] 2022-03-01T11:14:25.986+0800: 453.621: [Full GC (Ergonomics) [PSYoungGen: 30028K-&gt;23978K(51712K)] [ParOldGen: 27720K-&gt;27661K(30720K)] 57749K-&gt;51639K(82432K), [Metaspace: 53928K-&gt;53928K(1099776K)], 0.2050496 secs] [Times: user&#x3D;0.70 sys&#x3D;0.03, real&#x3D;0.20 secs] 说明启用了Parallel Old这个老年代收集器。 使用Jconsole连接该程序，切换到VM概要这个tab，注意下图红圈圈出来的地方： JVM参数 显式使用-XX:+UseSerialGC -Xms100M -Xmx100M -Xmn70M -XX:PretenureSizeThreshold&#x3D;5M -client -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCCause -Xloggc:gc-old.log -verbose:gc gc日志如下: Java HotSpot(TM) 64-Bit Server VM (25.121-b13) for windows-amd64 JRE (1.8.0_121-b13), built on Dec 12 2016 18:21:36 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010) Memory: 4k page, physical 16601588k(5142084k free), swap 26038772k(4551612k free) CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize&#x3D;104857600 -XX:+ManagementServer -XX:MaxHeapSize&#x3D;104857600 -XX:MaxNewSize&#x3D;73400320 -XX:NewSize&#x3D;73400320 -XX:PretenureSizeThreshold&#x3D;5242880 -XX:+PrintGC -XX:+PrintGCCause -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel&#x3D;1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseSerialGC 2022-03-01T11:23:14.044+0800: 1.617: [GC (Allocation Failure) 2022-03-01T11:23:14.044+0800: 1.618: [DefNew: 57344K-&gt;5487K(64512K), 0.0091428 secs] 57344K-&gt;5487K(95232K), 0.0093811 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] 2022-03-01T11:23:14.527+0800: 2.100: [GC (Allocation Failure) 2022-03-01T11:23:14.527+0800: 2.100: [DefNew: 62831K-&gt;5807K(64512K), 0.0139393 secs] 62831K-&gt;8566K(95232K), 0.0139920 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] 2022-03-01T11:23:14.643+0800: 2.216: [Full GC (Metadata GC Threshold) 2022-03-01T11:23:14.643+0800: 2.216: [Tenured: 2758K-&gt;6966K(30720K), 0.0211325 secs] 28297K-&gt;6966K(95232K), [Metaspace: 20450K-&gt;20450K(1067008K)], 0.0212119 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.02 secs] 此时，新生代是DefNew，老年代是Tenured，明显和前面使用了 -XX:+UseParallelGC时候不一样。 引用 JVM经典垃圾回收器之 serial 收集器 和 serialOld 收集器 查看JVM使用的默认的垃圾收集器","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"JAVA内存模型","slug":"jvm-jmm","date":"2022-02-26T16:32:02.000Z","updated":"2022-03-06T16:14:03.684Z","comments":true,"path":"2022/02/27/jvm-jmm/","link":"","permalink":"http://www.yipinxieli.com/2022/02/27/jvm-jmm/","excerpt":"","text":"Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。 5大内存区域 程序计数器 程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。 这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域 Java栈（虚拟机栈） 同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，栈描述的是Java方法执行的内存模型。栈帧大小在编译期已经确定，不受运行期数据影响。 每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。 Java虚拟机栈可能出现两种类型的异常： 线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。 虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。 本地方法栈 本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++。 堆 堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。因此需要重点了解下。java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。 它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError) 方法区(永久代) 方法区同堆一样，是所有线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。 运行时常量池是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。 JDK8真正开始废弃永久代，而使用元空间(Metaspace) 垃圾回收 既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的。 引用计数器法 引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。 缺点：无法解决循环依赖问题 可达性分析算法 可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。 怎么回收垃圾 标记清除算法 缺点：内存碎片化的问题 复制算法 缺点：不用考虑内存碎片等复杂情况，但是空间利用率低 标记整理算法 缺点：标记整理算法一方面在标记清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。 分代收集算法分代收集算法 严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记——整理算法来进行回收。 内存模型与回收策略 Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。 Eden 区 大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。 Survivor 区 Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。 设置两个 Survivor 区最大的好处就是解决内存碎片化与效率问题 我觉得本质问题还是考虑得效率的问题。如果如博主说的，产生内存碎片化问题，那么我单独再采用一次整理算法也可以解决碎片化问题，而为什么没有采用算法，而是采用了使用两块survivor，实际上还是考虑到整理空间所消耗的性能远远大于使用两块survivor通过复制算法解决。两块 Survivor 区可能是经过权衡之后的最佳方案。 Old 区 老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。老年代这里采用的是标记整理算法。 除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。 ★ 大对象 大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。 ★ 长期存活对象 虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。 ★ 动态对象年龄 虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。 引用 咱们从头到尾说一次 Java 的垃圾回收 深入理解JVM-内存模型（jmm）和GC Java内存模型（JMM）总结","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"JWT","slug":"tools-jwt","date":"2022-02-23T14:18:03.000Z","updated":"2022-02-24T03:40:06.717Z","comments":true,"path":"2022/02/23/tools-jwt/","link":"","permalink":"http://www.yipinxieli.com/2022/02/23/tools-jwt/","excerpt":"Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。","text":"Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 JWTjwt由.号分隔的三部分组成，第一部分我们称它为头部（header)，第二部分我们称其为载荷（payload)，第三部分是签名（signature)。 示例：xxxxx.yyyyy.zzzzz Header jwt的头部承载两部分信息： 声明类型：这里是jwt； 声明加密的算法：通常直接使用 HMAC SHA256。 完整的头部就像下面这样的JSON： &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125; 然后进行base64编码，构成了第一部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 Payload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分： 标准中注册的声明； 公共的声明； 私有的声明。 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者； sub: jwt所面向的用户； aud: 接收jwt的一方； exp: jwt的过期时间，这个过期时间必须要大于签发时间； nbf: 定义在什么时间之前，该jwt都是不可用的.； iat: jwt的签发时间； jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ：公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有的声明 ：私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload： &#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true &#125; 然后将其进行base64编码，得到Jwt的第二部分。 TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ Signature jwt的第三部分是一个签名信息，这个签名信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64编码后的header和base64编码后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 生成的Signature为 nuHomjWUwAeeGBK-bDGl_xL7Cx-SjRnZEjSQzbvMZF4 将这三部分用.连接成一个完整的字符串,构成了最终的jwt。 标准携带方式 一般是在请求头里加入Authorization，并加上Bearer 标注： &#39;Authorization&#39;: &#39;Bearer &#39; + token 验证 通过base64解码payload，验证iss（key），为空或不正确返回403； 验证payload中的exp（过期时间戳），为空或过期返回403； 通过对第一二段字符串拼接，再次根据数据库中次key对应的secret进行HS256加密，与token中的第三段字符串进行比对，不一致返回403。 Jwt token生成验证 引用 传说中的jwt 基于 JWT + Refresh Token 的用户认证实践 [采用JWT有效期内刷新Token方案]","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"http://www.yipinxieli.com/tags/jwt/"}]},{"title":"Eclipse Memory Analysis使用","slug":"jvm-eclipse","date":"2022-02-21T08:40:20.000Z","updated":"2022-02-22T02:24:01.642Z","comments":true,"path":"2022/02/21/jvm-eclipse/","link":"","permalink":"http://www.yipinxieli.com/2022/02/21/jvm-eclipse/","excerpt":"Eclipse Memory Analyzer是一个快速而功能丰富的Java堆分析器，可帮助您查找内存泄漏并减少内存消耗。使用内存分析器分析数亿个对象的生产性堆转储，快速计算保留的对象大小，查看谁阻止垃圾收集器收集对象，运行报告以自动提取泄漏的嫌疑人。","text":"Eclipse Memory Analyzer是一个快速而功能丰富的Java堆分析器，可帮助您查找内存泄漏并减少内存消耗。使用内存分析器分析数亿个对象的生产性堆转储，快速计算保留的对象大小，查看谁阻止垃圾收集器收集对象，运行报告以自动提取泄漏的嫌疑人。 Eclipse Memory Analyzer 安装 下载Eclipse并安装，下载地址：https://www.eclipse.org/downloads/。 在Eclipse help -&gt; Eclipse Marketplace下搜索Memory.找到图中的软件，默认安装就可以。 测试代码 package org.fenixsoft.jvm.chapter2; import java.util.ArrayList; import java.util.List; &#x2F;** * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError * * @author zzm *&#x2F; public class HeapOOM &#123; static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list &#x3D; new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125; &#125; VM options配置 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;d:\\test.hprof HeapDumpOnOutOfMemoryError 内存溢出时dump文件保存在HeapDumpPath指定的位置，-XX:HeapDumpPath&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat 这样可以只指定保持的目录 -Xms20m 指定JVM初始内存为20m，-Xmx20m 指定JVM最大可用内存为20m idea中异常信息打印： org.fenixsoft.jvm.chapter2.HeapOOM java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid21692.hprof ... Heap dump file created [28257710 bytes in 0.164 secs] Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at org.fenixsoft.jvm.chapter2.HeapOOM.main(HeapOOM.java:20) Process finished with exit code 1 分析 在Eclipse Memory Analyzer试图中，选择File -&gt; Open Heap Dump Overview页面 在窗口上方的位置可以看到 heapDump 的 size，以及类、对象和类加载器的数量。在窗口中最醒目的饼图直观地显示了 dump 中最大的几个对象。鼠标光标划过饼图中代表某个对象的区块时可以在左侧 Inspector 窗口中看到对象的细节，在区块上点击鼠标左键可以通过菜单项钻取到关于其对应的对象更多的细节。 我们可以看到占用很大一部分内存的有几个深色的饼区，这些就可以当做我们稍后着重看的地方 这里看到最大的那个占用内存的对象，对象名称，Shallow Size也就是本身在堆内存中120B并不大，但是Retained Size有15.5M，说明这个大对象中包含的引用对象很多。 Histogram 点开Histogram，点击Shallow Heap或Retained Heap排序，可以看见前排占用大量空间的有哪些 Shallow Heap浅堆：java对象占用的内存 Retained Heap深堆：java对象及对象引用的类占用的内存 ，jvm gc回收时释放的内存 Retained Heap深堆大于等于Shallow Heap浅堆 如果想看这个具体有哪些对象，可以点击这个右键-&gt;show objects by class -&gt; by outgoing Reference Incomming Reference 指的是引用当前对象的外部对象； Outgoing Reference 指的是当前对象引用的外部对象。对象的 incomming reference 保证对象处于 alive 从而免于被垃圾回收掉。Outgoing reference 则展示了对象的具体内容， 有助于我们发现对象的用处。 比如可以看到Object[]这个对象本身就很大，它的引用外部对象很小，说明它的内存主要是由于本身定义的过大引起的。第二个对象就是由于引用外部对象过多引起的。 Dominator Tree Dominator Tree 展示了 Heap Dump 中最大的几个对象。 如果 dominator tree 中对象的父节点被移除的话那么， 那么相应对象及其后代节点也面临被回收的状态。 如果想探究一个对象持有了哪些对象并使之处于 alive， Dominator Tree 会是个很有用的工具。 此外还可以在 Dominator Tree 上按照 classloader 或 package 进行分组， 从而简化分析的过程。 可以点击左边你的三角展开查看持有的alive对象。 Top Consumers Top Consumer 与Override页类似，Top Consumer 页按照对象、类、 类加载器和包也分别提供了对应的类似图表信息 Leak Suspects 通过前面简单的了解，我们大致了解了什么地方的内存比较占用高，最后这个报告是Mat帮我们分析的可能怀疑内存泄露的地方 引用 Eclipse Memory Analyzer入门学习笔记 Eclipse Memory Analysis的安装和使用+分析","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"}]},{"title":"ps命令","slug":"linux-ps","date":"2022-02-20T14:32:20.000Z","updated":"2022-02-19T18:02:25.016Z","comments":true,"path":"2022/02/20/linux-ps/","link":"","permalink":"http://www.yipinxieli.com/2022/02/20/linux-ps/","excerpt":"Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。","text":"Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。 Linux ps 命令 语法 ps [options][--help] 常用参数 -A 列出所有的进程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 au(x) 输出格式 : USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER: 行程拥有者 PID: pid %CPU: 占用的 CPU 使用率 %MEM: 占用的记忆体使用率 VSZ: 占用的虚拟记忆体大小 RSS: 占用的记忆体大小 TTY: 终端的次要装置号码 (minor device number of tty) STAT: 该行程的状态: D: 无法中断的休眠状态 (通常 IO 的进程) R: 正在执行中 S: 静止状态 T: 暂停执行 Z: 不存在但暂时无法消除 W: 没有足够的记忆体分页可分配 &lt;: 高优先序的行程 N: 低优先序的行程 L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I&#x2F;O) START: 行程开始时间 TIME: 执行的时间 COMMAND:所执行的指令 应用举例 ps -l只能查看自己bash的进程 work@authority-api-v1-6944b5848b-6x5d2:~$ ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 4 S 1000 1519 0 0 80 0 - 5283 wait pts&#x2F;0 00:00:00 bash 0 R 1000 1536 1519 0 80 0 - 7486 - pts&#x2F;0 00:00:00 ps work@authority-api-v1-6944b5848b-6x5d2:~$ ps aux所有系统运行的进程，按照PID的顺序来排序显示 work@authority-api-v1-6944b5848b-6x5d2:~$ ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND work 1 0.0 0.0 4280 64 ? Ss Feb15 0:00 &#x2F;bin&#x2F;sh -c PROJECT_DIR&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api $PROJECT_DIR&#x2F;bin&#x2F;bootstrap work 6 0.0 0.0 19728 992 ? S Feb15 0:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;bootstrap run work 16 0.0 0.0 19880 1152 ? S Feb15 0:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;..&#x2F;&#x2F;lib&#x2F;authority-api.jar run work 47 0.8 0.3 7494192 686500 ? Sl Feb15 56:13 &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;true - work 1519 0.0 0.0 21132 4696 pts&#x2F;0 Ss 00:56 0:00 bash work 1544 0.0 0.0 38384 3072 pts&#x2F;0 R+ 01:35 0:00 ps aux 查找指定进程 work@authority-api-v1-6944b5848b-6x5d2:~$ ps -ef | grep java| grep auth work 47 16 0 Feb15 ? 00:56:13 &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;true -DLOG_PATH&#x3D;&#x2F;mnt&#x2F;logs&#x2F;authority-api -server -XX:MaxRAMPercentage&#x3D;30.0 -XX:InitialRAMPercentage&#x3D;30.0 -XX:MinRAMPercentage&#x3D;30.0 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;mnt&#x2F;logs&#x2F;authority-api&#x2F;jvm -XX:ErrorFile&#x3D;&#x2F;mnt&#x2F;logs&#x2F;authority-api&#x2F;jvm&#x2F;jvm_err.log -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:ConcGCThreads&#x3D;2 -XX:ParallelGCThreads&#x3D;2 -XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark -XX:+CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction&#x3D;70 -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;1 -XX:GCLogFileSize&#x3D;50M -verbose:gc -XX:+PrintHeapAtGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -Xloggc:&#x2F;mnt&#x2F;logs&#x2F;authority-api&#x2F;jvm&#x2F;gc.log -javaagent:&#x2F;usr&#x2F;local&#x2F;jmx-exporter&#x2F;jmx_prometheus_javaagent-0.14.0.jar&#x3D;9990:&#x2F;usr&#x2F;local&#x2F;jmx-exporter&#x2F;prometheus-jmx-config.yaml -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -jar &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;lib&#x2F;authority-api.jar --server.address&#x3D;0.0.0.0 --spring.config.location&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;conf&#x2F; --spring.profiles.active&#x3D;testing --logging.config&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;conf&#x2F;log4j2.yml 显示指定用户信息 work@authority-api-v1-6944b5848b-6x5d2:~$ ps -u work PID TTY TIME CMD 1 ? 00:00:00 sh 6 ? 00:00:00 bootstrap 16 ? 00:00:00 authority-api.j 47 ? 00:56:13 java 1519 pts&#x2F;0 00:00:00 bash 1549 pts&#x2F;0 00:00:00 ps work@authority-api-v1-6944b5848b-6x5d2:~$ 显示所有进程信息，连同命令行 work@authority-api-v1-6944b5848b-6x5d2:~$ ps -ef UID PID PPID C STIME TTY TIME CMD work 1 0 0 Feb15 ? 00:00:00 &#x2F;bin&#x2F;sh -c PROJECT_DIR&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api $PROJECT_DIR&#x2F;bin&#x2F;bootstrap run work 6 1 0 Feb15 ? 00:00:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;bootstrap run work 16 6 0 Feb15 ? 00:00:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;..&#x2F;&#x2F;lib&#x2F;authority-api.jar run work 47 16 0 Feb15 ? 00:56:13 &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;true -DLOG_PATH&#x3D;&#x2F;mnt&#x2F; work 1519 0 0 00:56 pts&#x2F;0 00:00:00 bash work 1550 1519 0 01:40 pts&#x2F;0 00:00:00 ps -ef work@authority-api-v1-6944b5848b-6x5d2:~$ 根据 CPU 使用来升序排序 work@authority-api-v1-6944b5848b-6x5d2:~$ ps aux --sort -pcpu USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND work 47 0.8 0.3 7494192 686500 ? Sl Feb15 56:14 &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;true - work 1 0.0 0.0 4280 64 ? Ss Feb15 0:00 &#x2F;bin&#x2F;sh -c PROJECT_DIR&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api $PROJECT_DIR&#x2F;bin&#x2F;bootstrap work 6 0.0 0.0 19728 992 ? S Feb15 0:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;bootstrap run work 16 0.0 0.0 19880 1152 ? S Feb15 0:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;..&#x2F;&#x2F;lib&#x2F;authority-api.jar run work 1519 0.0 0.0 21132 4812 pts&#x2F;0 Ss 00:56 0:00 bash work 1555 0.0 0.0 38384 2984 pts&#x2F;0 R+ 01:45 0:00 ps aux --sort -pcpu work@authority-api-v1-6944b5848b-6x5d2:~$ 根据 内存使用来升序排序 work@authority-api-v1-6944b5848b-6x5d2:~$ ps -aux --sort -pmem USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND work 47 0.8 0.3 7494192 686500 ? Sl Feb15 56:14 &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;true - work 1519 0.0 0.0 21132 4812 pts&#x2F;0 Ss 00:56 0:00 bash work 1558 0.0 0.0 38384 3100 pts&#x2F;0 R+ 01:46 0:00 ps -aux --sort -pmem work 16 0.0 0.0 19880 1152 ? S Feb15 0:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;..&#x2F;&#x2F;lib&#x2F;authority-api.jar run work 6 0.0 0.0 19728 992 ? S Feb15 0:00 &#x2F;bin&#x2F;bash &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;bin&#x2F;bootstrap run work 1 0.0 0.0 4280 64 ? Ss Feb15 0:00 &#x2F;bin&#x2F;sh -c PROJECT_DIR&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api $PROJECT_DIR&#x2F;bin&#x2F;bootstrap work@authority-api-v1-6944b5848b-6x5d2:~$ 我们也可以将它们合并到一个命令，并通过管道显示前10个结果： work@authority-api-v1-6944b5848b-6x5d2:~$ ps aux --sort -pcpu,+pmem | head -n 3 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND work 47 0.8 0.3 7494192 686500 ? Sl Feb15 56:14 &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;true -DLOG_PATH&#x3D;&#x2F;mnt&#x2F;logs&#x2F;authority-api -server -XX:MaxRAMPercentage&#x3D;30.0 -XX:InitialRAMPercentage&#x3D;30.0 -XX:MinRAMPercentage&#x3D;30.0 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;mnt&#x2F;logs&#x2F;authority-api&#x2F;jvm -XX:ErrorFile&#x3D;&#x2F;mnt&#x2F;logs&#x2F;authority-api&#x2F;jvm&#x2F;jvm_err.log -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:ConcGCThreads&#x3D;2 -XX:ParallelGCThreads&#x3D;2 -XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark -XX:+CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction&#x3D;70 -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;1 -XX:GCLogFileSize&#x3D;50M -verbose:gc -XX:+PrintHeapAtGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -Xloggc:&#x2F;mnt&#x2F;logs&#x2F;authority-api&#x2F;jvm&#x2F;gc.log -javaagent:&#x2F;usr&#x2F;local&#x2F;jmx-exporter&#x2F;jmx_prometheus_javaagent-0.14.0.jar&#x3D;9990:&#x2F;usr&#x2F;local&#x2F;jmx-exporter&#x2F;prometheus-jmx-config.yaml -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -jar &#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;lib&#x2F;authority-api.jar --server.address&#x3D;0.0.0.0 --spring.config.location&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;conf&#x2F; --spring.profiles.active&#x3D;testing --logging.config&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api&#x2F;conf&#x2F;log4j2.yml work 1 0.0 0.0 4280 64 ? Ss Feb15 0:00 &#x2F;bin&#x2F;sh -c PROJECT_DIR&#x3D;&#x2F;home&#x2F;work&#x2F;www&#x2F;authority-api $PROJECT_DIR&#x2F;bin&#x2F;bootstrap run work@authority-api-v1-6944b5848b-6x5d2:~$ 引用 10个重要的Linux ps命令实战","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"top命令","slug":"linux-top","date":"2022-02-20T14:32:20.000Z","updated":"2022-02-19T17:03:18.724Z","comments":true,"path":"2022/02/20/linux-top/","link":"","permalink":"http://www.yipinxieli.com/2022/02/20/linux-top/","excerpt":"top 命令用于实时显示系统资源使用情况。它可以显示系统摘要信息，以及内核当前正在管理的进程或线程的列表。 top 命令可以实时动态地查看系统的整体运行情况，是一个非常实用的系统性能和运行信息的监测工具。通过 top 命令所提供的互动式界面，用热键可以管理。","text":"top 命令用于实时显示系统资源使用情况。它可以显示系统摘要信息，以及内核当前正在管理的进程或线程的列表。 top 命令可以实时动态地查看系统的整体运行情况，是一个非常实用的系统性能和运行信息的监测工具。通过 top 命令所提供的互动式界面，用热键可以管理。 Linux top 命令相对于ps为某个时间点的进程状态，top则可以持续的检测进程进行的状态。默认更新进程资源的时间为5秒。可以使用-d来进行修改。top命令默认使用CPU的使用率作为排序的依据，如果要使用内存使用率的话，则按下M键。恢复P键 语法 top [options] 常用参数 -b #以批处理模式操作 -c #显示完整的治命令 -d #屏幕刷新间隔时间 -I #忽略失效过程 -s #保密模式 -S #累积模式 -i&lt;时间&gt; #设置间隔时间 -u&lt;用户名&gt; #指定用户名 -p&lt;进程号&gt; #指定进程 -n&lt;次数&gt; #循环显示的次数 top交互命令 h #显示帮助信息界面 k #终止一个进程 i #忽略闲置和僵死进程，这是一个开关式命令 q #退出程序 r #重新安排一个进程的优先级别 S #切换到累计模式 s #改变两次刷新之间的延迟时间（单位为s），默认值是5s f或者F #从当前显示中添加或者删除项目 o或者O #改变显示项目的顺序 l #切换显示平均负载和启动时间信息 m #切换显示内存信息 t #切换显示进程和CPU状态信息 c #切换显示命令名称和完整命令行 M #根据驻留内存大小进行排序 P #根据CPU使用百分比大小进行排序 T #根据时间&#x2F;累计时间进行排序 w #将当前设置写入~&#x2F;.toprc文件中 应用举例 top -c查看系统整体运行信息 top - 00:44:49 up 565 days, 12:38, 2 users, load average: 0.03, 0.09, 0.13 Tasks: 86 total, 1 running, 85 sleeping, 0 stopped, 0 zombie %Cpu(s): 2.8 us, 0.8 sy, 0.0 ni, 96.0 id, 0.2 wa, 0.0 hi, 0.2 si, 0.0 st KiB Mem : 3881692 total, 118724 free, 1708796 used, 2054172 buff&#x2F;cache KiB Swap: 0 total, 0 free, 0 used. 1892868 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 21399 work 20 0 6004700 1.296g 6752 S 3.7 35.0 639:24.06 &#x2F;home&#x2F;work&#x2F;java-current&#x2F;bin&#x2F;java -Dsun.misc.URLClassPath.disableJarChecking&#x3D;+ 4306 root 10 -10 137372 14500 5284 S 2.0 0.4 2303:51 &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_11_17&#x2F;AliYunDun 24092 root 20 0 795856 40192 7648 S 1.3 1.0 33:05.19 &#x2F;root&#x2F;filebeat-7.4.2-linux-x86_64&#x2F;filebeat -e -c &#x2F;root&#x2F;filebeat-7.4.2-linux-+ 9 root 20 0 0 0 0 S 0.3 0.0 365:09.14 [rcu_sched] 1191 root 20 0 2526540 86844 3320 S 0.3 2.2 4146:08 &#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;jre&#x2F;bin&#x2F;java -Djava.compiler&#x3D;none -XX:-UseGCOverhead+ 1755 work 20 0 84428 29432 996 S 0.3 0.8 1554:04 nginx: worker process 1756 work 20 0 84296 29436 1000 S 0.3 0.8 1479:33 nginx: worker process 1 root 20 0 53708 3144 1852 S 0.0 0.1 7:40.55 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --switched-root --system --deserialize 21 2 root 20 0 0 0 0 S 0.0 0.0 0:00.14 [kthreadd] 3 root 20 0 0 0 0 S 0.0 0.0 6:04.15 [ksoftirqd&#x2F;0] 上述结果信息详细说明 top - 05:59:56 #当前系统时间 up 1 day #系统已经运行了1天 1 user #当前登录用户个数 load average: 0.06, 0.03, 0.05 #系统负载信息 Tasks: 92 total #总进程数 2 running #正在运行的进程数 90 sleeping #休眠的进程数 0 stopped #停止的进程数 0 zombie #冻结的进程数 %Cpu(s): 0.0 us #用户空间占用CPU的百分比 0.3 sy #内核空间占用CPU的百分比 0.0 ni #用户进程空间内改变过优先级的进程占用CPU百分比 99.7 id #空闲CPU百分比 0.0 wa #等待输入输出的CPU时间百分比 0.0 hi #硬中断占用CPU的百分比 0.0 si #软中断占用CPU的百分比 0.0 st #虚拟机占用百分比 KiB Mem : 995684 total #物理内存的总量 473120 free #剩余内存的总量 124960 used #已使用内存的总量 397604 buff&#x2F;cache #内核缓存所使用内存的量 KiB Swap: 2097148 total #交换分区的总量 2097148 free #交换分区剩余的总量 0 used #交换分区已使用的总量 698120 avail Mem #可用内存总量 PID #进程id USER #进程所有者 PR #任务的调度优先级，范围0-31，数值越低，优先级越高 NI #nice值，范围-20到+19，用于调整进程优先级 VIRT #进程所使用的虚拟内存总量（单位 KB） RES #任务已使用的未交换物理内存（单位 KB） SHR #共享内存大小（单位 KB） S #进程状态 &#39; D &#39;&#x3D;不间断的睡眠 &#39; R &#39;&#x3D;运行 &#39; S &#39;&#x3D;睡眠 &#39; T &#39;&#x3D;被跟踪或停止的 &#39; Z &#39;&#x3D;僵尸 %CPU #CPU的使用率 %MEM #内存使用率 TIME+ #CPU时间 COMMAND #进程名称（命令名&#x2F;命令行），显示用于启动任务的命令行或关联程序的名称。 将top命令执行两次，然后将信息存储 work@authority-api-v1-6944b5848b-6x5d2:~$ top -b -n 2 &gt; &#x2F;tmp&#x2F;top.txt 查看指定进程 work@authority-api-v1-6944b5848b-6x5d2:~$ echo $$ 1519 work@authority-api-v1-6944b5848b-6x5d2:~$ top -d 10 -p 1519 top - 01:00:33 up 256 days, 9:29, 0 users, load average: 17.69, 12.52, 12.51 Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie %Cpu(s): 39.3 us, 12.0 sy, 0.0 ni, 45.7 id, 2.5 wa, 0.0 hi, 0.4 si, 0.0 st KiB Mem : 19706059+total, 2849084 free, 94349680 used, 99861824 buff&#x2F;cache KiB Swap: 0 total, 0 free, 0 used. 10241943+avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1519 work 20 0 21132 4352 2608 S 0.0 0.0 0:00.05 bash 引用 每天学一个 Linux 命令（48）：top","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"awk命令","slug":"linux-awk","date":"2022-02-08T14:32:20.000Z","updated":"2022-02-19T16:09:49.957Z","comments":true,"path":"2022/02/08/linux-awk/","link":"","permalink":"http://www.yipinxieli.com/2022/02/08/linux-awk/","excerpt":"awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输(stdin)、一个或多个文件，或其它命令的输出。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。","text":"awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输(stdin)、一个或多个文件，或其它命令的输出。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。 Linux awk 命令工作中遇到一个需求，需要从nginx日志中获取调用方上游IP，需要对nginx日志进行处理，所以学习一下linux命令。 原理 语法 awk [options] &#39;scripts&#39; var&#x3D;value filename 常用参数 -F 指定分隔符（可以是字符串或正则表达式） -f 从脚本文件中读取awk命令 -v var&#x3D;value 赋值变量，将外部变量传递给awk 脚本基本结构 awk &#39;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#39; filename 一个awk脚本通常由BEGIN语句+模式匹配+END语句三部分组成,这三部分都是可选项. 工作原理: 第一步执行BEGIN 语句 第二步从文件或标准输入读取一行，然后再执行pattern语句，逐行扫描文件到文件全部被读取 第三步执行END语句 实例展示 echo &quot;hello &quot; | awk &#39;BEGIN&#123; print &quot;welcome&quot; &#125; END&#123; print &quot;2017-08-08&quot; &#125;&#39; welcome 2017-08-08 echo -e &quot;hello&quot; | awk &#39;BEGIN&#123; print &quot;welcome&quot; &#125; &#123;print&#125; END&#123; print &quot;2017-08-08&quot; &#125;&#39; welcome hello 2017-08-08 #不加print参数时默认只打印当前的行 echo|awk &#39;&#123; a&#x3D;&quot;hello&quot;; b&#x3D;&quot;nihao&quot;; c&#x3D;&quot;mingongge&quot;; print a,b,c; &#125;&#39; hello nihao mingongge #使用print以逗号分隔时，打印则是以空格分界 echo|awk &#39;&#123; a&#x3D;&quot;mgg&quot;; b&#x3D;&quot;mingg&quot;; c&#x3D;&quot;mingongge&quot;; print a&quot; is &quot;b&quot; or &quot;c; &#125;&#39; mgg is mingg or mingongge #awk的print语句中双引号其实就是个拼接作用 echo -e &quot;OK! \\n&quot; # -e 开启转义 内置变量 $0 #当前记录 $1~$n #当前记录的第N个字段 FS #输入字段分隔符（-F相同作用）默认空格 RS #输入记录分割符，默认换行符 NF #字段个数就是列 NR #记录数，就是行号，默认从1开始 OFS #输出字段分隔符，默认空格 ORS #输出记录分割符，默认换行符 外部变量 [root@localhost ~]# a&#x3D;7 [root@localhost ~]# b&#x3D;b [root@localhost ~]# b&#x3D;6 [root@localhost ~]# echo |awk &#39;&#123;print v1*v2 &#125;&#39; v1&#x3D;$a v2&#x3D;$b 42 AWK实例 以:为分隔符打印第二列 work@user-center-api-v1-85689f869-6htbw:&#x2F;mnt&#x2F;logs&#x2F;nginx$ awk -F&quot;:&quot; &#39;&#123;print $2&#125;&#39; &#x2F;etc&#x2F;passwd x x x x x x x x x x x x x x x x x x x x x x 以:分隔打印以work开头行的第三列内容 work@user-center-api-v1-85689f869-6htbw:&#x2F;mnt&#x2F;logs&#x2F;nginx$ awk -F : &#39;&#x2F;^work&#x2F;&#123;print $3&#125;&#39; &#x2F;etc&#x2F;passwd 1000 以:分隔打印以r或者w开头行的第一列内容 work@user-center-api-v1-85689f869-6htbw:&#x2F;mnt&#x2F;logs&#x2F;nginx$ awk -F : &#39;&#x2F;^[rw]&#x2F;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd root www-data work rd 获取nginx日志中的IP地址 日志格式如下： remote_addr=[127.0.0.6] http_x_forward=[172.26.0.131,172.26.0.2] time=[2022-02-06T23:40:01+08:00] request=[POST grep &quot;&#x2F;api&#x2F;v2&#x2F;userinfo&#x2F;get_usernames&quot; access-2022-02-06.log | awk -F&quot; &quot; &#39;&#123;print $2&#125;&#39;| awk -F &quot;[][]&quot; &#39;&#123;print $2&#125;&#39;| awk -F&quot;,&quot; &#39;&#123;print $1&quot;\\n&quot;$2&#125;&#39; | sort -r | uniq -c | more 204 172.26.0.3 228 172.26.0.2 432 172.26.0.131 匹配所有包含root的行 work@user-center-api-v1-85689f869-6htbw:&#x2F;mnt&#x2F;logs&#x2F;nginx$ awk &#39;&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash 以分号作为分隔符，匹配第5个字段是root的行 awk -F: &#39;$5~&#x2F;root&#x2F;&#123;print $0&#125;&#39; passwd 引用 每天一个 Linux 命令（4）：awk","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"Linux中&和&&,|和||","slug":"linux-logic","date":"2022-02-08T14:32:20.000Z","updated":"2022-02-01T15:12:14.918Z","comments":true,"path":"2022/02/08/linux-logic/","link":"","permalink":"http://www.yipinxieli.com/2022/02/08/linux-logic/","excerpt":"Linux中&amp;和&amp;&amp;,|和||","text":"Linux中&amp;和&amp;&amp;,|和|| Linux ls 命令 &amp; &amp; 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp; &amp;&amp; &amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’ | | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l || || 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"docker相关命令","slug":"docker-command","date":"2021-09-14T16:26:54.000Z","updated":"2021-09-15T16:47:10.232Z","comments":true,"path":"2021/09/15/docker-command/","link":"","permalink":"http://www.yipinxieli.com/2021/09/15/docker-command/","excerpt":"","text":"Docker容器命令 docker pull **获取镜像 (image) ** D:\\hexoBlog&gt;docker pull mysql Using default tag: latest latest: Pulling from library&#x2F;mysql a330b6cecb98: Already exists 9c8f656c32b8: Pull complete 88e473c3f553: Pull complete 062463ea5d2f: Pull complete daf7e3bdf4b6: Pull complete 1839c0b7aac9: Pull complete cf0a0cfee6d0: Pull complete 1b42041bb11e: Pull complete 10459d86c7e6: Pull complete b7199599d5f9: Pull complete 1d6f51e17d45: Pull complete 50e0789bacad: Pull complete Digest: sha256:99e0989e7e3797cfbdb8d51a19d32c8d286dd8862794d01a547651a896bcf00c Status: Downloaded newer image for mysql:latest docker.io&#x2F;library&#x2F;mysql:latest docker build 使用 Dockerfile 创建镜像 (image) &#96;&#96;&#96; &gt; ### docker images **列出本地镜像 (image)** &#96;&#96;&#96; bash PS C:\\Users\\wang&gt; docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest ad4c705f24d3 4 days ago 133MB mysql latest 0716d6ebcc1a 11 days ago 514MB docker&#x2F;getting-started latest 083d7564d904 3 months ago 28MB hub.c.163.com&#x2F;library&#x2F;nginx latest 46102226f2fd 4 years ago 109MB docker cp 用于容器与主机之间的数据拷贝 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。 C:\\Users\\wang&gt;docker cp &#x2F;www&#x2F;runoob 9703d:&#x2F;www&#x2F; CreateFile C:\\www: The system cannot find the file specified. C:\\Users\\wang&gt;docker cp &#x2F;www&#x2F;runoob 9703d:&#x2F;www&#x2F; C:\\Users\\wang&gt;docker exec -it 9703d &#x2F;bin&#x2F;bash root@9703dcaf7efc:&#x2F;# cd &#x2F; root@9703dcaf7efc:&#x2F;# ls bin dev entrypoint.sh home lib64 mnt proc run srv tmp var boot docker-entrypoint-initdb.d etc lib media opt root sbin sys usr www root@9703dcaf7efc:&#x2F;# cd www root@9703dcaf7efc:&#x2F;www# ls 1.txt root@9703dcaf7efc:&#x2F;www# cat 1.txt 111111111111111 root@9703dcaf7efc:&#x2F;www# 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中 C:\\Users\\wang&gt;docker cp 9703d:&#x2F;www &#x2F;tmp&#x2F; docker commit 从容器创建一个新的镜像 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS说明： **-a :**提交的镜像作者； **-c :**使用Dockerfile指令来创建镜像； **-m :**提交时的说明文字； **-p :**在commit时，将容器暂停。 C:\\Users\\wang&gt;docker commit -a &quot;wangql&quot; -m &quot;wangSQL&quot; 9703d wangSQL invalid reference format: repository name must be lowercase C:\\Users\\wang&gt;docker commit -a &quot;wangql&quot; -m &quot;wangSQL&quot; 9703d wangsql sha256:9cb7bdcd2ed312f18242775f8f964b7ef860e3fdd1c523842e256e942d9d1be4 C:\\Users\\wang&gt;docker images wangsql REPOSITORY TAG IMAGE ID CREATED SIZE wangsql latest 9cb7bdcd2ed3 9 seconds ago 514MB docker rmi 删除本地一个或多个镜像 (image) C:\\Users\\wang&gt;docker images REPOSITORY TAG IMAGE ID CREATED SIZE &lt;none&gt; &lt;none&gt; 0990594dba3d 38 minutes ago 514MB nginx latest ad4c705f24d3 5 days ago 133MB mysql latest 0716d6ebcc1a 12 days ago 514MB docker&#x2F;getting-started latest 083d7564d904 3 months ago 28MB hub.c.163.com&#x2F;library&#x2F;nginx latest 46102226f2fd 4 years ago 109MB C:\\Users\\wang&gt;docker rmi -f mysql nginx Untagged: mysql:latest Untagged: mysql@sha256:99e0989e7e3797cfbdb8d51a19d32c8d286dd8862794d01a547651a896bcf00c Untagged: nginx:latest Untagged: nginx@sha256:853b221d3341add7aaadf5f81dd088ea943ab9c918766e295321294b035f3f3e docker run 创建一个新的容器并运行一个命令 (container) docker ps 列出正在运行的容器列表 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES da5001f28240 nginx &quot;&#x2F;docker-entrypoint.…&quot; 17 seconds ago Up 16 seconds 80&#x2F;tcp distracted_engelbart 显示所有的容器，包括未运行的 docker ps -a C:\\Users\\wang&gt;docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES da5001f28240 nginx &quot;&#x2F;docker-entrypoint.…&quot; 22 hours ago Exited (255) 13 minutes ago 80&#x2F;tcp distracted_engelbart 30402568e75b nginx &quot;&#x2F;docker-entrypoint.…&quot; 22 hours ago Exited (0) 22 hours ago happy_heyrovsky 08d4e5c65b09 docker&#x2F;getting-started &quot;&#x2F;docker-entrypoint.…&quot; 29 hours ago Exited (0) 29 hours ago pensive_robinson 1760a9cdaee1 hub.c.163.com&#x2F;library&#x2F;nginx &quot;nginx -g &#39;daemon of…&quot; 29 hours ago Exited (255) 29 hours ago 0.0.0.0:8080-&gt;80&#x2F;tcp, :::8080-&gt;80&#x2F;tcp frosty_hopper 2611bfa8785a docker&#x2F;getting-started &quot;&#x2F;docker-entrypoint.…&quot; 29 hours ago Exited (255) 29 hours ago 0.0.0.0:80-&gt;80&#x2F;tcp, :::80-&gt;80&#x2F;tcp priceless_rosalind da9c518b220b hub.c.163.com&#x2F;library&#x2F;nginx &quot;nginx -g &#39;daemon of…&quot; 30 hours ago Exited (0) 30 hours ago heuristic_rubin 790e60c35d23 nginx &quot;&#x2F;docker-entrypoint.…&quot; 3 days ago Exited (137) 3 days ago nginx-test 9ce1de13f46a docker&#x2F;getting-started:latest &quot;&#x2F;docker-entrypoint.…&quot; 3 days ago Exited (0) 3 days ago cool_hodgkin 424e2623c296 docker&#x2F;getting-started &quot;&#x2F;docker-entrypoint.…&quot; 3 days ago Exited (137) 3 days ago cool_fermat C:\\Users\\wang&gt; docker stop 关闭容器 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES da5001f28240 nginx &quot;&#x2F;docker-entrypoint.…&quot; 17 seconds ago Up 16 seconds 80&#x2F;tcp distracted_engelbart D:\\hexoBlog&gt;docker stop da5001 da5001 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker start 启动容器 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES da5001f28240 nginx &quot;&#x2F;docker-entrypoint.…&quot; 17 seconds ago Up 16 seconds 80&#x2F;tcp distracted_engelbart D:\\hexoBlog&gt;docker stop da5001 da5001 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES D:\\hexoBlog&gt;docker start da5001 da5001 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES da5001f28240 nginx &quot;&#x2F;docker-entrypoint.…&quot; 7 minutes ago Up 5 seconds 80&#x2F;tcp distracted_engelbart docker restart 重启容器 D:\\hexoBlog&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES da5001f28240 nginx &quot;&#x2F;docker-entrypoint.…&quot; 7 minutes ago Up 5 seconds 80&#x2F;tcp distracted_engelbart D:\\hexoBlog&gt;docker restart da5001 da5001 docker attach | exec 进入容器内部 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明： **-d :**分离模式: 在后台运行 **-i :**即使没有附加也保持STDIN 打开 **-t :**分配一个伪终端 C:\\Users\\wang&gt;docker exec -it 9703d &#x2F;bin&#x2F;bash root@9703dcaf7efc:&#x2F;# ls bin dev entrypoint.sh home lib64 mnt proc run srv tmp var boot docker-entrypoint-initdb.d etc lib media opt root sbin sys usr root@9703dcaf7efc:&#x2F;# cd &#x2F; root@9703dcaf7efc:&#x2F;# ls bin dev entrypoint.sh home lib64 mnt proc run srv tmp var boot docker-entrypoint-initdb.d etc lib media opt root sbin sys usr root@9703dcaf7efc:&#x2F;# root@9703dcaf7efc:&#x2F;# docker inspect 获取容器/镜像的元数据 docker inspect [OPTIONS] NAME|ID [NAME|ID...] OPTIONS说明： **-f :**指定返回值的模板文件。 **-s :**显示总的文件大小。 **–type :**为指定类型返回JSON。 C:\\Users\\wang&gt;docker inspect mysql [ &#123; &quot;Id&quot;: &quot;e701d96de9775da0bdbe419e368aea0153445fa3d984f0ac99d42cb891260fa6&quot;, &quot;Created&quot;: &quot;2021-09-15T15:17:49.314726Z&quot;, &quot;Path&quot;: &quot;docker-entrypoint.sh&quot;, &quot;Args&quot;: [ &quot;mysqld&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;exited&quot;, &quot;Running&quot;: false, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 0, &quot;ExitCode&quot;: 1, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-09-15T15:17:50.3746439Z&quot;, &quot;FinishedAt&quot;: &quot;2021-09-15T15:17:50.5453195Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0716d6ebcc1a61c5a296fcb187e71f93531e510d4e4400267e2e502103d0194c&quot;, &quot;ResolvConfPath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;e701d96de9775da0bdbe419e368aea0153445fa3d984f0ac99d42cb891260fa6&#x2F;resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;e701d96de9775da0bdbe419e368aea0153445fa3d984f0ac99d42cb891260fa6&#x2F;hostname&quot;, &quot;HostsPath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;e701d96de9775da0bdbe419e368aea0153445fa3d984f0ac99d42cb891260fa6&#x2F;hosts&quot;, &quot;LogPath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;e701d96de9775da0bdbe419e368aea0153445fa3d984f0ac99d42cb891260fa6&#x2F;e701d96de9775da0bdbe419e368aea0153445fa3d984f0ac99d42cb891260fa6-json.log&quot;, &quot;Name&quot;: &quot;&#x2F;mysql&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, 获取正在运行的容器mymysql的 IP C:\\Users\\wang&gt;docker inspect --format &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; 970 172.17.0.2 C:\\Users\\wang&gt; C:\\Users\\wang&gt;docker inspect --format&#x3D;&quot;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&quot; mysql-test 172.17.0.2 docker logs 获取容器的日志 D:\\hexoBlog&gt;docker logs da5001 &#x2F;docker-entrypoint.sh: &#x2F;docker-entrypoint.d&#x2F; is not empty, will attempt to perform configuration &#x2F;docker-entrypoint.sh: Looking for shell scripts in &#x2F;docker-entrypoint.d&#x2F; &#x2F;docker-entrypoint.sh: Launching &#x2F;docker-entrypoint.d&#x2F;10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf &#x2F;docker-entrypoint.sh: Launching &#x2F;docker-entrypoint.d&#x2F;20-envsubst-on-templates.sh &#x2F;docker-entrypoint.sh: Launching &#x2F;docker-entrypoint.d&#x2F;30-tune-worker-processes.sh &#x2F;docker-entrypoint.sh: Configuration complete; ready for start up 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: using the &quot;epoll&quot; event method 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: nginx&#x2F;1.21.3 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: built by gcc 8.3.0 (Debian 8.3.0-6) 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: OS: Linux 5.10.16.3-microsoft-standard-WSL2 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: start worker processes 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: start worker process 32 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: start worker process 33 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: start worker process 34 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: start worker process 35 2021&#x2F;09&#x2F;14 17:21:58 [notice] 1#1: start worker process 36 docker top 查看容器中运行的进程信息 D:\\hexoBlog&gt;docker top da5001 UID PID PPID C STIME TTY TIME CMD root 2073 2053 0 17:30 ? 00:00:00 nginx: master process nginx -g daemon off; uuidd 2125 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2126 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2127 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2128 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2129 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2130 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2131 2073 0 17:30 ? 00:00:00 nginx: worker process uuidd 2132 2073 0 17:30 ? 00:00:00 nginx: worker process docker port 列出指定的容器的端口映射 C:\\Users\\wang&gt;docker run -itd --name mysql-test -p 3333:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql 9703dcaf7efc2614bbec8f89cecab3f3e72285f933154b310bd51e6c7a5127df C:\\Users\\wang&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9703dcaf7efc mysql &quot;docker-entrypoint.s…&quot; 5 seconds ago Up 4 seconds 33060&#x2F;tcp, 0.0.0.0:3333-&gt;3306&#x2F;tcp, :::3333-&gt;3306&#x2F;tcp mysql-test C:\\Users\\wang&gt;docker port 9703d 3306&#x2F;tcp -&gt; 0.0.0.0:3333 3306&#x2F;tcp -&gt; :::3333 docker wait 阻塞运行直到容器停止，然后打印出它的退出代码 docker wait CONTAINER C:\\Users\\wang&gt;docker wait 970 0 C:\\Users\\wang&gt; docker rm 删除容器 C:\\Users\\wang&gt;docker rm zhouzhichao zhouzhichao 链接： https://www.cnblogs.com/lgg20/p/13186776.html","categories":[{"name":"容器","slug":"容器","permalink":"http://www.yipinxieli.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.yipinxieli.com/tags/Docker/"}]},{"title":"postman—使用变量","slug":"tools-postman-variable","date":"2021-09-12T14:18:03.000Z","updated":"2021-09-12T16:47:27.039Z","comments":true,"path":"2021/09/12/tools-postman-variable/","link":"","permalink":"http://www.yipinxieli.com/2021/09/12/tools-postman-variable/","excerpt":"变量允许我们在请求和脚本中存储和重用值。通过将值存储在变量中，我们可以在整个集合、环境和请求中引用它——如果您需要更新该值，您只需在一个地方更改它。使用变量可以提高工作效率，并最大限度地减少出错的可能性。","text":"变量允许我们在请求和脚本中存储和重用值。通过将值存储在变量中，我们可以在整个集合、环境和请求中引用它——如果您需要更新该值，您只需在一个地方更改它。使用变量可以提高工作效率，并最大限度地减少出错的可能性。 Postman(4)—变量了解变量变量是数据的符号表示，允许您访问一个值，而无需在任何需要的地方手动输入它。这在您在多个地方使用相同的值时尤其有用。通过抽象掉一些细节，变量使您的请求更加灵活和可读。 例如，如果您在多个请求中有相同的 URL——但 URL 可能会改变——您可以将它存储在一个变量中。如果 URL 发生变化，您只需要更改变量值，它就会反映在您的整个集合中，无论您在何处使用该变量名称。同样的原则适用于您请求中重复数据的任何部分。 Postman 中的变量是键值对。每个变量名代表它的键，因此引用变量名可以让你访问它的值。 例如，将请求的基本 URL 存储在名为 的变量中base_url，则可以在请求中使用&#123;&#123;base_url&#125;&#125;来引用它。如果基本 URL 值为https://httpbin.org，则对于&#123;&#123;base_url&#125;&#125;/get?customers=new，Postman 会将请求发送到https://httpbin.org/get?customers=new。 变量范围Postman 支持以下变量范围： 全局（Global） 全局变量允许您访问集合、请求、测试脚本和环境之间的数据。全局变量在整个工作区都可用。 集合（Collection） 集合变量在集合中的整个请求中都可用，并且与环境无关，因此不要根据所选环境进行更改。 环境（Environment） 环境变量允许您针对不同环境定制处理，例如本地开发与测试或生产。一次只能激活一个环境。 如果您只有一个环境，使用集合变量会更有效率，但是环境允许您指定基于角色的访问级别。 数据（Data） 数据变量来自外部 CSV 和 JSON 文件，用于定义在通过 Newman 或 Collection Runner 运行集合时可以使用的数据集。 本地（Local） 本地变量是临时的，只能在您的请求脚本中访问。本地变量值仅限于单个请求或集合运行，并且在运行完成后不再可用。 如果您需要一个值来覆盖所有其他变量范围，但不希望该值在执行结束后持续存在，则本地变量是合适的。 如果在两个不同的作用域中声明了同名变量，则将使用作用域最小的变量中存储的值——例如，如果有一个全局变量和一个本地变量都命名为username，则在请求时将使用本地值运行。 要尝试变量，请使用以下步骤： 单击Postman右上角的Environment 快速查看（眼睛按钮），然后单击Globals旁边的add/Edit。 添加一个名为的变量my_variable并为其赋予初始值 —Hello单击保存并关闭环境模式。 打开一个新的请求选项卡并输入https://postman-echo.com/get?var=&#123;&#123;my_variable&#125;&#125;URL。将鼠标悬停在变量名称上，您将看到该值。 发送请求。在响应中，您将看到 Postman 将变量值发送到 API。尝试更改环境快速查看中的值并再次发送请求。 定义变量 请求构造器中定义变量 在请求构建器的任何范围内创建变量，请选择您需要的数据，例如在地址、参数、标头或正文中。 选择设为变量**&gt;**设为新变量。 输入Name，验证Value并从下拉列表中选择一个范围。单击设置变量。 定义全局和环境变量 可以通过Postman左侧选择创建和编辑环境变量，或使用Postman右上角的环境快速浏览进行编辑。 如果您对整个环境具有编辑权限，则可以在环境中添加和编辑变量。如果您只有查看权限，则只能更新现有变量的当前值。您编辑的任何变量都只能由您访问，而您在工作区中协作者无法使用。 定义集合变量 您可以在创建集合时或之后的任何时间添加集合变量。要为现有集合创建或编辑变量，请在Postman 左侧的集合侧栏中选择该集合，然后选择Variables。 指定变量细节 您可以随时添加和编辑变量。您需要为新变量包含的只是一个名称——您可以选择提供一个初始值，但也可以稍后设置它，包括从脚本中设置。使用复选框启用或禁用变量。 当您共享集合或环境时，将共享初始值。当前值是本地的，不同步或共享。 访问变量 可以使用双花括号在整个 Postman 用户界面中引用变量。例如，要在请求身份验证设置中引用名为“username”的变量，您可以使用以下语法并在名称周围加上双花括号： &#123;&#123;username&#125;&#125; 或者，您可以有一个请求正文，通过将其引用括在双引号中来访问变量： &#123; \"customer_id\" : \"&#123;&#123;cust_id&#125;&#125;\" &#125; 当您将鼠标悬停在变量上时，您可以看到其当前状态的概览。当您在请求中键入变量时，Postman 会提示您输入当前定义的任何变量。 如果变量未解析，Postman 会将其突出显示为红色。 记录变量 您可以在请求运行时将变量值记录到Postman Console。从 Postman 左下角的按钮或从“查看”菜单打开控制台。要记录变量的值，请在脚本中使用以下语法： console.log(pm.variables.get(\"variable_key\")); [","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"postman","slug":"postman","permalink":"http://www.yipinxieli.com/tags/postman/"}]},{"title":"postman—请求","slug":"tools-postman-request","date":"2021-09-09T16:21:28.000Z","updated":"2021-09-12T15:05:04.496Z","comments":true,"path":"2021/09/10/tools-postman-request/","link":"","permalink":"http://www.yipinxieli.com/2021/09/10/tools-postman-request/","excerpt":"在 Postman 中发送请求可以检索、添加、删除和更新数据。无论您是在构建或测试自己的 API，还是与第三方 API ，都可以在 Postman 中尝试发送您的请求。","text":"在 Postman 中发送请求可以检索、添加、删除和更新数据。无论您是在构建或测试自己的 API，还是与第三方 API ，都可以在 Postman 中尝试发送您的请求。 Postman(3)—请求构建请求当您发送请求时，Postman 将从 API 服务器收到的响应，让您可以进行可视化的检查、并在必要时对其进行故障排除。 请求方法 POST— 添加新数据 PUT——替换现有数据 PATCH— 更新一些现有的数据字段 DELETE——删除现有数据 发送参数 查询参数被附加到请求 URL 的末尾，?在键值对中跟随并列出，&amp;使用以下语法分隔：?id=1&amp;type=new 路径参数构成请求 URL 的一部分，并使用前面的占位符引用:，如下例所示：/customer/:id 参数不会自动进行 URL 编码。右键单击所选文本，然后选择EncodeURIComponent以手动编码参数值。 接收响应Postman 响应查看器有助于查看API响应的正确性。API 响应由正文、标头和状态代码组成。Postman 在不同的选项卡中组织正文和标题。API 调用的状态代码和完成时间显示在选项卡旁边。 保存响应","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"postman","slug":"postman","permalink":"http://www.yipinxieli.com/tags/postman/"}]},{"title":"postman—账号与设置","slug":"tools-postman-account","date":"2021-09-07T15:42:36.000Z","updated":"2021-09-07T17:02:43.120Z","comments":true,"path":"2021/09/07/tools-postman-account/","link":"","permalink":"http://www.yipinxieli.com/2021/09/07/tools-postman-account/","excerpt":"Postman 帐户允许您同步和备份您的工作，以便您可以从不同的机器访问它。您还可以在您的 API 项目上与其他人协作。","text":"Postman 帐户允许您同步和备份您的工作，以便您可以从不同的机器访问它。您还可以在您的 API 项目上与其他人协作。 Postman(2)—账号与设置注册Postman帐户Postman的账号注册是可选的，没有帐户的Postman 应用程序依然可以使用。注册Postman 帐户方便我们同步和备份工作，我们可以登陆其他的不同的机器继续工作，也可以与其他人协作。 创建帐户 配置帐户当您第一次注册 Postman 帐户时，系统会提示您提供一些有关您自己的信息。输入您的详细信息，然后点击继续。 在这里可以选择创建或加入团队。 当选择登录 Postman 桌面版时，默认浏览器将自动打开一个网页，要求您登录 Postman。 同步您的工作 如果 Postman 无法连接，您可以切换到 Scratch Pad 并在本地工作。 登录 Postman 帐户时，同步可使您的所有 Postman 数据可用。更改（例如编辑、更新、添加或删除）会在与您的帐户关联的所有设备之间同步。 这些实体可以与服务器同步并保存到云端： 收藏 文件夹 要求 回应 标题预设 环境 环境变量 全局变量 收集运行结果 工作区 历史 注意： Postman 将每个帐户的并行使用限制为三个应用程序。 Scratch Pad 是一个您可以在没有连接或登录 Postman 的情况下在本地工作的空间。在 Scratch Pad 中所做的工作不会同步Postman，我们可以稍后将其导出并导入到工作区。 当您打开 Postman 或连接断开时，它会在开始同步之前显示“正在连接”。 单击该图标，我们会看到正在同步的在线状态。弹出窗口将指示有关当前同步状态的更多信息。 如果 Postman 与服务器同步，则右上角您姓名左侧的图标表示Online，并在悬停时显示一个显示In sync的弹出窗口 。 连接 Postman 时，如果遇到同步错误，它将指示错误状态。悬停以查看有关错误的详细信息。","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"postman","slug":"postman","permalink":"http://www.yipinxieli.com/tags/postman/"}]},{"title":"junit5——入门","slug":"junit-introduction","date":"2021-09-06T16:10:59.000Z","updated":"2021-09-08T17:01:14.133Z","comments":true,"path":"2021/09/07/junit-introduction/","link":"","permalink":"http://www.yipinxieli.com/2021/09/07/junit-introduction/","excerpt":"本文档来自于自己对官方文档的学习和翻译。 JUnit 5是JUnit的下一代。目标是为JVM上的开发人员端测试创建一个最新的基础。这包括专注于Java 8及更高版本，以及启用许多不同风格的测试。","text":"本文档来自于自己对官方文档的学习和翻译。 JUnit 5是JUnit的下一代。目标是为JVM上的开发人员端测试创建一个最新的基础。这包括专注于Java 8及更高版本，以及启用许多不同风格的测试。 Junit 5 用户指南 概述 与以前版本的 JUnit 不同，JUnit 5 由来自三个不同子项目的几个不同模块组成。 JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage JUnit Platform为在JVM上启动测试框架提供基础。它还定义了TestEngineAPI, 用来开发在平台上运行的测试框架。此外，平台提供了一个控制台启动器，用于从命令行启动平台，并为Gradle和Maven提供构建插件以及基于JUnit 4的Runner，用于在平台上运行任意TestEngine。 JUnit Jupiter是在JUnit 5中编写测试和扩展的新型[编程模型]和[扩展模型]的组合。Jupiter子项目提供了TestEngine，用于在平台上运行基于Jupiter的测试。 JUnit Vintage提供TestEngine，用于在平台上运行基于JUnit 3和JUnit 4的测试。 JUnit 5 在运行时需要 Java 8（或更高版本）。但是，您仍然可以测试使用以前版本的 JDK 编译的代码。 编写测试 第一个测试用例 package com.example.project; public class Calculator &#123; public int add(int a, int b) &#123; return a + b; &#125; &#125; 测试用例 package com.example.project; import static org.junit.jupiter.api.Assertions.assertEquals; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; class CalculatorTests &#123; @Test @DisplayName(&quot;1 + 1 &#x3D; 2&quot;) void addsTwoNumbers() &#123; Calculator calculator &#x3D; new Calculator(); assertEquals(2, calculator.add(1, 1), &quot;1 + 1 should equal 2&quot;); &#125; &#125; 注解 JUnit Jupiter 支持以下用于配置测试和扩展框架的注解。 除非另有说明，所有核心注释都位于模块中的org.junit.jupiter.api包中junit-jupiter-api。 注解 描述 @Test 表示方法是测试方法。 @ParameterizedTest 表示方法是参数化测试。 @RepeatedTest 表示方法是重复测试的测试模板。 @TestFactory 表示方法是动态测试测试工厂。 @TestTemplate 表示方法是测试用例的模板，旨在根据注册提供程序返回的调用上下文的数量多次调用。这些方法是继承的，除非它们被覆盖。 @TestMethodOrder 用于为注解的测试类配置测试方法执行顺序。 @TestInstance 用于为带注释的测试类配置测试实例生命周期。 @DisplayName 声明测试类或测试方法的自定义显示名称。此类注释不会被继承。 @DisplayNameGeneration 为测试类声明一个自定义显示名称生成器。此类注释是继承的。 @BeforeEach 表示被注解的方法应该在当前类中的每个、、、 或方法之前 执行；类似于 JUnit 4 的. 这些方法是继承的，除非它们被覆盖。 @Test``@RepeatedTest``@ParameterizedTest``@TestFactory``@Before @AfterEach 表示该注释的方法应该被执行之后 每个 @Test，@RepeatedTest，@ParameterizedTest，或@TestFactory方法在当前类; 类似于 JUnit 4 的@After。 @BeforeAll 表示该注释的方法应该被执行之前 所有 @Test，@RepeatedTest，@ParameterizedTest，和@TestFactory方法在当前类; 类似于 JUnit 4 的@BeforeClass. 此类方法是继承的（除非它们被隐藏或覆盖）并且必须是static（除非使用“class“测试实例生命周期）。 @AfterAll 表示该注释的方法应该被执行之后 的所有 @Test，@RepeatedTest，@ParameterizedTest，和@TestFactory方法在当前类; 类似于 JUnit 4 的@AfterClass. 此类方法是继承的（除非它们被隐藏或覆盖）并且必须是static（除非使用“class”[测试实例生命周期]）。 标准测试类 import static org.junit.jupiter.api.Assertions.fail; import static org.junit.jupiter.api.Assumptions.assumeTrue; import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; class StandardTests &#123; @BeforeAll static void initAll() &#123; &#125; @BeforeEach void init() &#123; &#125; @Test void succeedingTest() &#123; &#125; @Test void failingTest() &#123; fail(&quot;a failing test&quot;); &#125; @Test @Disabled(&quot;for demonstration purposes&quot;) void skippedTest() &#123; &#x2F;&#x2F; not executed &#125; @Test void abortedTest() &#123; assumeTrue(&quot;abc&quot;.contains(&quot;Z&quot;)); fail(&quot;test should have been aborted&quot;); &#125; @AfterEach void tearDown() &#123; &#125; @AfterAll static void tearDownAll() &#123; &#125; &#125;","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"postman—入门","slug":"tools-postman-introduction","date":"2021-09-05T17:04:13.000Z","updated":"2021-09-07T15:03:43.019Z","comments":true,"path":"2021/09/06/tools-postman-introduction/","link":"","permalink":"http://www.yipinxieli.com/2021/09/06/tools-postman-introduction/","excerpt":"欢迎使用 Postman 文档！在这里可以找到有关如何在 API 项目中使用 Postman 的官方信息。","text":"欢迎使用 Postman 文档！在这里可以找到有关如何在 API 项目中使用 Postman 的官方信息。 Postman(1)—入门安装和更新Postman 可在网络上的go.postman.co/home上获得，并作为适用于 Mac、Windows（32 位/64 位）和 Linux（32 位/64 位）操作系统的本机桌面应用程序。 要获取最新版本的 Postman 桌面应用程序，请访问 下载页面 选择适用于您操作系统的安装程序。 Postman Chrome 应用程序已弃用 - 如果您使用 Chrome 应用程序，您可以在切换到本机应用程序时保留您的数据，方法是与您登录的 Postman 帐户同步，或者从 Chrome 导出并导入到原生应用。 Postman导航视图 左侧边栏提供对您的集合（collections）、[API]、环境变量(environments)、模拟服务器（mock servers）、监视器（monitors）和请求历史（history）。 顶部工具栏允许您创建工作区（Workspaces）、访问报告（Reports）、探索公共 API 网络（Explore）、在 Postman 中搜索（Search Postman）、查看同步状态和通知、移动和邀请协作者到工作区、捕获请求和 cookie、设置、帐户等。 中心区域是您构建和处理请求的地方。 底部的状态栏允许您显示/隐藏侧边栏、查找和替换（find-and-replace)以及打开左侧的控制台（Console）。在右侧，您可以启动Bootcamp、集合运行器（Runner）、垃圾箱（Trash）、窗格视图以及访问帮助资源。 您还可以在 Postman UI 中拖动以调整窗格的大小。 在右侧面板上，您将看到用于查看文档、评论、代码和请求信息的图标。 查找和替换您可以通过单击 Postman左下角的“查找和替换”或使用键盘快捷键Command + SHIFT + F/来搜索您的 Postman 工作区Control + SHIFT + F。 输入您的搜索字符串并可选择要返回的实体，如有必要，输入替换文本。 Postman 将搜索选项卡、集合和变量。您可以直接从搜索结果中单击以打开记录。 历史通过Postman 左侧的History选项卡访问您在 Postman 中提出的请求的历史记录。如果您已登录 Postman 帐户，您的历史记录将跨设备同步。 标签您可以通过打开选项卡在 Postman 中发送请求 - 单击屏幕中央的**+**，或按Command/Control + T。 发送请求要发送您的第一个 API 请求，请打开 Postman。单击**+**加号按钮打开一个新选项卡。在 URL 字段中输入。点击发送。您将在下方窗格中看到来自服务器的 JSON 数据响应。","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"postman","slug":"postman","permalink":"http://www.yipinxieli.com/tags/postman/"}]},{"title":"mapper层的单元测试","slug":"junit-mapper","date":"2021-08-29T12:54:56.000Z","updated":"2021-08-30T15:04:34.081Z","comments":true,"path":"2021/08/29/junit-mapper/","link":"","permalink":"http://www.yipinxieli.com/2021/08/29/junit-mapper/","excerpt":"学习新技能，针对Mybatis中Mapper的单元测试。","text":"学习新技能，针对Mybatis中Mapper的单元测试。 单元测试 – mapper层的单元测试 使用H2数据库进行单元测试 H2 数据库是一个开源的嵌入型内存数据库，采用纯Java语言实现；程序非常小巧轻便，整个完整的Jar包也只有1.5M左右，很容易集成到项目中。在自动化环境中可能需要大量模拟接口，包括数据存储接口，此时内存数据库是不二之选。本身作为嵌入式数据库并不需要额外的看护成本；在程序退出时，所有数据都能保证完全清除。 MAVEN依赖 &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;&#x2F;groupId&gt; &lt;artifactId&gt;h2&lt;&#x2F;artifactId&gt; &lt;version&gt;1.4.200&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; application.properties(路径：test/resources) spring.datasource.driverClassName&#x3D;org.h2.Driver spring.datasource.url&#x3D;jdbc:h2:mem:db_users;MODE&#x3D;MYSQL;INIT&#x3D;RUNSCRIPT FROM &#39;.&#x2F;src&#x2F;test&#x2F;resources&#x2F;create_table.sql&#39; spring.datasource.username&#x3D; spring.datasource.password&#x3D; mybatis.configuration.map-underscore-to-camel-case&#x3D;true 测试类 package com.puhuijia.dao.mapper; import com.puhuijia.pojo.member.AreaBusiness; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.mybatis.spring.annotation.MapperScan; import org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.Date; @RunWith(SpringRunner.class) @MapperScan(&#123;&quot;com.puhuijia.dao.mapper&quot;&#125;) @SpringBootTest(classes &#x3D; &#123;DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class&#125;) public class MembersMapperTest &#123; @Autowired private AreaBusinessMapper mapper; @Test public void queryProvinceList() &#123; int row &#x3D; mapper.deleteByPrimaryKey(1); Assert.assertEquals(row, 0); AreaBusiness areaBusiness &#x3D; new AreaBusiness(); areaBusiness.setName(&quot;33333&quot;); areaBusiness.setId(1); areaBusiness.setCreateTime(new Date()); areaBusiness.setUpdateTime(new Date()); mapper.insertSelective(areaBusiness); row &#x3D; mapper.deleteByPrimaryKey(1); Assert.assertEquals(row, 1); &#125; &#125; create_table.sql drop table if exists area_business; CREATE TABLE &#96;area_business&#96; ( &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;|20181106&#39;, &#96;name&#96; varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;|20181106&#39;, &#96;create_time&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;|20181106&#39;, &#96;update_time&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;|20181106&#39;, PRIMARY KEY (&#96;id&#96;), KEY &#96;idx_create_time&#96; (&#96;create_time&#96;), KEY &#96;idx_update_time&#96; (&#96;update_time&#96;) ) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;16 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;333&#39; h2数据库 jdbc:h2:mem:DBName;DB_CLOSE_DELAY&#x3D;-1 参数DB_CLOSE_DELAY是要求最后一个正在连接的连接断开后，不要关闭DB，因为下一个case可能还会有新连接进来。 H2与MySQL的一些常见区别 注释：不支持表级别的Comment 索引：H2中的索引是数据库内唯一，MySQL中的索引是每张表唯一 CURRENT_TIMESTAMP： H2不支持记录更新时自动刷新字段时间，也就是不支持语句ON UPDATE CURRENT_TIMESTAMP","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"Windows Docker 安装","slug":"docker-install","date":"2021-08-26T16:00:01.000Z","updated":"2021-09-17T03:51:28.441Z","comments":true,"path":"2021/08/27/docker-install/","link":"","permalink":"http://www.yipinxieli.com/2021/08/27/docker-install/","excerpt":"Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。 因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。","text":"Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。 因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。 Windows Docker 安装Docker Desktop 是 Docker 在 Windows 10 和 macOS 操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。 注意：此方法仅适用于 Windows 10 操作系统专业版、企业版、教育版和部分家庭版！ 官方文档：https://docs.docker.com/ Docker的安装与卸载：https://docs.docker.com/engine/install/ docker官方镜像列表地址：https://hub.docker.com/search?q=&amp;type=image 启动报错 Docker.ApiServices.WSL2.WslKernelUpdateNotInstalledException: 引发类型为“Docker.ApiServices.WSL2.WslKernelUpdateNotInstalledException”的异常。 在 Docker.ApiServices.WSL2.WslShortLivedCommandResult.LogAndThrowIfUnexpectedExitCode(String prefix, ILogger log, Int32 expectedExitCode) 位置 C:\\workspaces\\PR-16070\\src\\github.com\\docker\\pinata\\win\\src\\Docker.ApiServices\\WSL2\\WslCommand.cs:行号 140 在 Docker.Engines.WSL2.WSL2Provisioning.&lt;DeployDistroAsync&gt;d__17.MoveNext() 位置 C:\\workspaces\\PR-16070\\src\\github.com\\docker\\pinata\\win\\src\\Docker.Desktop\\Engines\\WSL2\\WSL2Provisioning.cs:行号 169 --- 引发异常的上一位置中堆栈跟踪的末尾 --- 解决方法:打开网站 https://czf-net.xyz/res/ 下载wsl.msi。安装完成后重启Docker解决！ 版本号查看 D:\\hexoBlog&gt;docker version Client: Cloud integration: 1.0.17 Version: 20.10.8 API version: 1.41 Go version: go1.16.6 Git commit: 3967b7d Built: Fri Jul 30 19:58:50 2021 OS&#x2F;Arch: windows&#x2F;amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.8 API version: 1.41 (minimum version 1.12) Go version: go1.16.6 Git commit: 75249d8 Built: Fri Jul 30 19:52:10 2021 OS&#x2F;Arch: linux&#x2F;amd64 Experimental: false containerd: Version: 1.4.9 GitCommit: e25210fe30a0a703442421b0f60afac609f950a3 runc: Version: 1.0.1 GitCommit: v1.0.1-0-g4144b63 docker-init: Version: 0.19.0 GitCommit: de40ad0 D:\\hexoBlog&gt; Docker 镜像加速 配置阿里云加速 检查加速器是否生效 检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。 D:\\hexoBlog&gt;docker info Client: Context: default Debug Mode: false Plugins: buildx: Build with BuildKit (Docker Inc., v0.6.1-docker) compose: Docker Compose (Docker Inc., v2.0.0-rc.1) scan: Docker Scan (Docker Inc., v0.8.0) Server: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 20.10.8 Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true userxattr: false Logging Driver: json-file Cgroup Driver: cgroupfs Cgroup Version: 1 Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: io.containerd.runtime.v1.linux runc io.containerd.runc.v2 Default Runtime: runc Init Binary: docker-init containerd version: e25210fe30a0a703442421b0f60afac609f950a3 runc version: v1.0.1-0-g4144b63 init version: de40ad0 Security Options: seccomp Profile: default Kernel Version: 4.19.128-microsoft-standard Operating System: Docker Desktop OSType: linux Architecture: x86_64 CPUs: 8 Total Memory: 12.35GiB Name: docker-desktop ID: 4OUU:DRRA:23QZ:DXOD:CRAK:5NOL:XEWB:NODY:FJJI:2D74:656T:PC23 Docker Root Dir: &#x2F;var&#x2F;lib&#x2F;docker Debug Mode: false Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F; Labels: Experimental: false Insecure Registries: 127.0.0.0&#x2F;8 Registry Mirrors: https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F; Live Restore Enabled: false WARNING: No blkio throttle.read_bps_device support WARNING: No blkio throttle.write_bps_device support WARNING: No blkio throttle.read_iops_device support WARNING: No blkio throttle.write_iops_device support WARNING: bridge-nf-call-iptables is disabled WARNING: bridge-nf-call-ip6tables is disabled D:\\hexoBlog&gt; docker run hello-world C:\\Users\\wang&gt;docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https:&#x2F;&#x2F;hub.docker.com&#x2F; For more examples and ideas, visit: https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F; C:\\Users\\wang&gt; 要是看到上面的示例 那就说明 你的Docker部署及运行成功了。 windows10安装Hyper-V 最近需要在windows10上安装Docker Desktop，然而docker Desktop依赖于Hyper-V。自己的电脑上控制面板功能里没有Hyper-V。这里记录一下解决方案。 复制以下代码，然后另存为do.cmd。在文件上右键，以管理员的身份运行。 pushd &quot;%~dp0&quot; dir &#x2F;b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txt for &#x2F;f %%i in (&#39;findstr &#x2F;i . hyper-v.txt 2^&gt;nul&#39;) do dism &#x2F;online &#x2F;norestart &#x2F;add-package:&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot; del hyper-v.txt Dism &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Hyper-V-All &#x2F;LimitAccess &#x2F;ALL 执行的时间有点长，循环出现很多遍，等到执行完毕时，输入Y，重启电脑。 然后打开控制面板，就可以看到已经出现结果了","categories":[{"name":"容器","slug":"容器","permalink":"http://www.yipinxieli.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.yipinxieli.com/tags/Docker/"}]},{"title":"Windows Docker安装Mysql8.0","slug":"docker-mysql","date":"2021-08-26T16:00:01.000Z","updated":"2022-01-29T15:22:49.256Z","comments":true,"path":"2021/08/27/docker-mysql/","link":"","permalink":"http://www.yipinxieli.com/2021/08/27/docker-mysql/","excerpt":"Docker 安装Mysql8.0","text":"Docker 安装Mysql8.0 Docker 安装Mysql访问 MySQL 镜像库地址：https://hub.docker.com/_/mysql?tab=tags。 可以通过 Sort by 查看其他版本的 MySQL，默认是最新版本 mysql:latest 。 此外，我们还可以用 docker search mysql 命令来查看可用版本(windows下无法显示tags)： NAME # 镜像仓库 DESCRIPTION # 镜像描述信息 STARS # 镜像收藏数 OFFICIAL # 是否为docker官方发布的镜像 AUTOMATED # 是否为自动化构建的镜像，关于自动化构建，可以查看官方文档：https:&#x2F;&#x2F;docs.docker.com&#x2F;docker-hub&#x2F;builds&#x2F;#how-automated-builds-work 拉取Mysql镜像 C:\\Users\\wang&gt;docker pull mysql:8.0.28 8.0.28: Pulling from library&#x2F;mysql 6552179c3509: Pull complete d69aa66e4482: Pull complete 3b19465b002b: Pull complete 7b0d0cfe99a1: Pull complete 9ccd5a5c8987: Pull complete 2dab00d7d232: Pull complete 64d3afdccd4a: Pull complete 82148d50b16c: Pull complete 8bb7d73a7d0c: Pull complete 74778cd68a75: Pull complete d7e5f9309140: Pull complete f2e376ecd59f: Pull complete Digest: sha256:92d27b8222bbcf53bc42c70ca7cd1010d6c0527efc61f14980ce77c50932bef4 Status: Downloaded newer image for mysql:8.0.28 docker.io&#x2F;library&#x2F;mysql:8.0.28 查看本地仓库镜像是否下载成功 C:\\Users\\wang&gt;docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 8.0.28 d1dc36cf8d9e 2 days ago 519MB hello-world latest feb5d9fea6a5 4 months ago 13.3kB C:\\Users\\wang&gt;docker images mysql REPOSITORY TAG IMAGE ID CREATED SIZE mysql 8.0.28 d1dc36cf8d9e 2 days ago 519MB 运行docker mysql镜像 docker run -p 3308:3306 --name zsdmysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:8.0.28 上述命令的参数，有如下含义: --name指定了你要取的名字。 -p对应，需要映射出来的端口。比如:3308:3306,意识表示为zsdmysql的容器里面的3306端口对应我外面这个虚拟机的3308端口。 -e是mysql的命令，设置root的密码为123456 -d是运行的镜像，这里是mysql 容器镜像 查看目前运行的容器 C:\\Users\\wang&gt;docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 622fe2b1bf2a mysql:8.0.28 &quot;docker-entrypoint.s…&quot; About a minute ago Up About a minute 33060&#x2F;tcp, 0.0.0.0:3308-&gt;3306&#x2F;tcp, :::3308-&gt;3306&#x2F;tcp zsdmysql 进入MySQL C:\\Users\\wang&gt;docker exec -it zsdmysql bash root@622fe2b1bf2a:&#x2F;# mysql -uroot -p123456 mysql: [Warning] Using a password on the command line interface can be insecure. Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.28 MySQL Community Server - GPL Copyright (c) 2000, 2022, Oracle and&#x2F;or its affiliates. Oracle is a registered trademark of Oracle Corporation and&#x2F;or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; show tables -&gt; ; ERROR 1046 (3D000): No database selected mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) 使用datatrip连接数据库 目录映射 docker run -p 3308:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -v d:&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql:rw -v d:&#x2F;docker&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql:rw -v d:&#x2F;docker&#x2F;mysql&#x2F;mysql-files:&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F; --name mysql8.0 --restart&#x3D;always -d mysql:8.0.28 –restart=always参数能够使我们在重启docker时，自动启动相关容器。 新建d:/docker/mysql/conf/，拷贝配置文件到宿主机： C:\\Users\\wang&gt;docker cp mysql8.0:&#x2F;etc&#x2F;mysql&#x2F;my.cnf d:&#x2F;docker&#x2F;mysql&#x2F;conf&#x2F; 停止容器： docker stop mysql8.0 删除容器： docker rm mysql8.0 重新执行生成容器（增加了对配置文件my.cnf的映射，直接映射，容器启动会有问题，通过执行下面-v后面的映射，最终实现数据持久化，数据存放在宿主机而不是容器内）： docker run -p 3308:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -v d:&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql:rw -v d:&#x2F;docker&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql:rw -v d:&#x2F;docker&#x2F;mysql&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf:rw -v d:&#x2F;docker&#x2F;mysql&#x2F;mysql-files:&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F; --name mysql8.0 --restart&#x3D;always -d mysql:8.0.28 查看mysql8.0容器运行情况 docker ps 进入mysql 根据上面查询到的容器id执行 docker exec -it mysql8.0 bash 连接mysql mysql -uroot -p C:\\Users\\wang&gt;docker exec -it mysql8.0 bash root@c1192171b549:&#x2F;# mysql -uroot -p mysql: [Warning] World-writable config file &#39;&#x2F;etc&#x2F;mysql&#x2F;my.cnf&#39; is ignored. Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 10 Server version: 8.0.28 MySQL Community Server - GPL Copyright (c) 2000, 2022, Oracle and&#x2F;or its affiliates. Oracle is a registered trademark of Oracle Corporation and&#x2F;or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; create database todou -&gt; ; Query OK, 1 row affected (0.05 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | | todou | +--------------------+ 5 rows in set (0.05 sec) mysql&gt; use todou Database changed mysql&gt; create person (id int(11) not null ) -&gt; ; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;person (id int(11) not null )&#39; at line 1 mysql&gt; create table person (id int(11) not null ); Query OK, 0 rows affected, 1 warning (0.06 sec) mysql&gt; show tables; +-----------------+ | Tables_in_todou | +-----------------+ | person | +-----------------+ 1 row in set (0.00 sec) 使用datatrip连接 引用 Docker 安装 MySQL8.0","categories":[{"name":"容器","slug":"容器","permalink":"http://www.yipinxieli.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.yipinxieli.com/tags/Docker/"}]},{"title":"查找相关的命令","slug":"linux-search","date":"2021-08-22T02:48:43.000Z","updated":"2021-08-26T15:47:49.701Z","comments":true,"path":"2021/08/22/linux-search/","link":"","permalink":"http://www.yipinxieli.com/2021/08/22/linux-search/","excerpt":"我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。","text":"我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which命令which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 查找文件、显示命令路径 [wang@localhost ~]$ which tree &#x2F;usr&#x2F;bin&#x2F;tree whereis 命令whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令格式： whereis [-bfmsu][-B &lt;目录&gt;...][-M &lt;目录&gt;...][-S &lt;目录&gt;...][文件...] 参数： -b 只查找二进制文件。 -B&lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。 -m 只查找说明文件。 -M&lt;目录&gt; 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。 -S&lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。 使用指令”whereis”查看指令”bash”的位置 [wang@localhost ~]$ whereis bash bash: &#x2F;usr&#x2F;bin&#x2F;bash &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;bash.1.gz 注意：以上输出信息从左至右分别为查询的程序名、bash路径、bash的man 手册页路径。 #显示bash 命令的二进制程序 [wang@localhost ~]$ whereis -b bash bash: &#x2F;usr&#x2F;bin&#x2F;bash #显示bash 命令的帮助文件 [wang@localhost ~]$ whereis -m bash bash: &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;bash.1.gz #查找源文件 [wang@localhost ~]$ whereis -s bash bash: [wang@localhost ~]$ locate命令Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。 一般情况我们只需要输入 locate your_file_name 即可查找指定文件。 语法locate [-d ][--help][--version][范本样式...] 参数： -b, –basename – 仅匹配路径名的基本名称 -c, –count – 只输出找到的数量 -d, –database DBPATH – 使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db -e, –existing – 仅打印当前现有文件的条目 -1 – 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。 -0, –null – 在输出上带有NUL的单独条目 -S, –statistics – 不搜索条目，打印有关每个数据库的统计信息 -q – 安静模式，不会显示任何错误讯息。 -P, –nofollow, -H – 检查文件存在时不要遵循尾随的符号链接 -l, –limit, -n LIMIT – 将输出（或计数）限制为LIMIT个条目 -n – 至多显示 n个输出。 -m, –mmap – 被忽略，为了向后兼容 -r, –regexp REGEXP – 使用基本正则表达式 –regex – 使用扩展正则表达式 -q, –quiet – 安静模式，不会显示任何错误讯息 -s, –stdio – 被忽略，为了向后兼容 -o – 指定资料库存的名称。 -h, –help – 显示帮助 -i, –ignore-case – 忽略大小写 -V, –version – 显示版本信息 查找和pwd相关的所有文件 [wang@localhost ~]$ locate pwd &#x2F;etc&#x2F;.pwd.lock &#x2F;usr&#x2F;bin&#x2F;pwd &#x2F;usr&#x2F;bin&#x2F;pwdx &#x2F;usr&#x2F;lib&#x2F;modules&#x2F;3.10.0-123.el7.x86_64&#x2F;kernel&#x2F;drivers&#x2F;watchdog&#x2F;hpwdt.ko &#x2F;usr&#x2F;lib64&#x2F;cracklib_dict.pwd &#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;lib-dynload&#x2F;spwdmodule.so &#x2F;usr&#x2F;sbin&#x2F;unix_chkpwd &#x2F;usr&#x2F;share&#x2F;cracklib&#x2F;cracklib-small.pwd &#x2F;usr&#x2F;share&#x2F;cracklib&#x2F;pw_dict.pwd &#x2F;usr&#x2F;share&#x2F;doc&#x2F;krb5-workstation-1.11.3&#x2F;user&#x2F;pwd_mgmt.html &#x2F;usr&#x2F;share&#x2F;help&#x2F;C&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;ca&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;cs&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;de&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;el&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;en_GB&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;es&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;eu&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;fi&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;fr&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;gl&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;hu&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;it&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;ja&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;lv&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;pl&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;ru&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;sl&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;sv&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;te&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;help&#x2F;zh_CN&#x2F;empathy&#x2F;irc-join-pwd.page &#x2F;usr&#x2F;share&#x2F;man&#x2F;man0p&#x2F;pwd.h.0p.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;pwd.1.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;pwdx.1.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1p&#x2F;pwd.1p.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man3&#x2F;lckpwdf.3.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man3&#x2F;ulckpwdf.3.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;unix_chkpwd.8.gz [wang@localhost ~]$ 搜索etc目录下所有以sh开头的文件 [wang@localhost ~]$ locate &#x2F;etc&#x2F;sh &#x2F;etc&#x2F;shadow &#x2F;etc&#x2F;shadow- &#x2F;etc&#x2F;shells [wang@localhost ~]$ 附加说明locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。 locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为： updatedb 默认情况下 updatedb 每天执行一次。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"head命令与tail命令","slug":"linux-head","date":"2021-08-21T17:11:39.000Z","updated":"2021-08-21T18:23:37.524Z","comments":true,"path":"2021/08/22/linux-head/","link":"","permalink":"http://www.yipinxieli.com/2021/08/22/linux-head/","excerpt":"head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。","text":"head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 head命令head 命令可用于查看文件的开头部分的内容，有一个常用的参数 -n 用于显示行数，默认为 10，即显示 10 行的内容。 命令格式： head [参数] [文件] 参数： -q 隐藏文件名 -v 显示文件名 -c&lt;数目&gt; 显示的字节数。 -n&lt;行数&gt; 显示的行数。 [wang@localhost ~]$ head textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 6 4444444444444444 7 5555555555555555 8 6666666666666666 9 10 -- 显示 textfile2 文件的开头 5 行 [wang@localhost ~]$ head -n 5 textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 -- 显示文件前 20 个字节: [wang@localhost ~]$ head -c 20 textfile2 1 1111111111111[wang@localhost ~]$ -- 文件的除了最后n个字节以外的内容 [wang@localhost ~]$ cat textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 6 4444444444444444 7 5555555555555555 8 6666666666666666 9 10 11 99999999999999 eeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeeeeeeeeZZ9 -- 文件的除了最后20个字节以外的内容 [wang@localhost ~]$ head -c -20 textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 6 4444444444444444 7 5555555555555555 8 6666666666666666 9 10 11 99999999999999 eeeeeeeeeeeeeeeeeee eeeeeeeeeeeee[wang@localhost ~]$ -- 输出文件除了最后n行的全部内容 [wang@localhost ~]$ head -n -5 textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 6 4444444444444444 7 5555555555555555 8 6666666666666666 [wang@localhost ~]$ tail命令tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令格式： tail [参数] [文件] 参数： -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&lt;数目&gt; 显示的字节数 -n&lt;行数&gt; 显示文件的尾部 n 行内容 –pid=PID 与-f合用,表示在进程ID,PID死掉之后结束 -q, –quiet, –silent 从不输出给出文件名的首部 -s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 显示文件末尾内容 -- 显示文件最后5行内容 [push_service_gateway-00 push_service]$ tail -n 5 push_service_gateway.log [] 2021-08-22 02:18:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:18:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:19:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:19:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:19:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [rd@线上-基础架构-车源-话务-push_service_gateway-00 push_service]$ -- 循环查看文件内容,一般用于查看日志 [push_service_gateway-00 push_service]$ tail -f push_service_gateway.log [] 2021-08-22 02:17:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:18:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:18:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:18:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:19:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:19:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:19:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 -- 从第5行开始显示文件 [push_service_gateway-00 push_service]$ tail -f -n5 push_service_gateway.log [] 2021-08-22 02:21:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:21:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:22:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:22:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新 [] 2021-08-22 02:22:30 - [INFO] [LocalMonitor:71 watchFile] 非受监控的文件发生变更，无需刷新","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"more命令与less命令","slug":"linux-more","date":"2021-08-21T09:08:36.000Z","updated":"2021-08-21T17:10:37.047Z","comments":true,"path":"2021/08/21/linux-more/","link":"","permalink":"http://www.yipinxieli.com/2021/08/21/linux-more/","excerpt":"Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按 键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。","text":"Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按 键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 Linux more 命令与less命令 more 语法 more [-dlfpcsu] [-num] [+&#x2F;pattern] [+linenum] [fileNames..] 参数 -num 一次显示的行数 -d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声 -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能 -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上） -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容 -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料 -s 当遇到有连续两行以上的空白行，就代换为一行的空白行 -u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同） +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示 +num 从第 num 行开始显示 fileNames 欲显示内容的文档，可为复数个数 常用操作命令： Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more more -s push_service_ws.log 逐页显示日志文件中内容，如有连续两行以上空白行则以一行空白行显示。 [push_service_ws-00 push_service]$ more -s push_service_ws.log [] 2021-08-21 00:00:33 - [INFO] [DefaultDisconnectListener:19 onDisconnect] eefc6553-ddba-403b-be58-6d0e92543680 has disconnected [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:57 doBefore] [推送服务WS][AOP] 请求参数[方法名:removeSession 参数列表:[eefc6553-ddba-403b-be 58-6d0e92543680]] [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:123 removeMethodManage] [推送服务WS][AOP] REMOVE方法移除SESSION KEY [sessionId eefc6553-ddba -403b-be58-6d0e92543680] [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:124 removeMethodManage] [推送服务WS][AOP] REMOVE方法相关REDIS KEY设置完毕[sessionId eefc6553 -ddba-403b-be58-6d0e92543680] [] 2021-08-21 00:00:33 - [INFO] [DefaultDisconnectListener:19 onDisconnect] b441923b-2146-4f00-94b3-e819b5c8b926 has disconnected [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:57 doBefore] [推送服务WS][AOP] 请求参数[方法名:removeSession 参数列表:[b441923b-2146-4f00-94 b3-e819b5c8b926]] [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:123 removeMethodManage] [推送服务WS][AOP] REMOVE方法移除SESSION KEY [sessionId b441923b-2146 -4f00-94b3-e819b5c8b926] more +20 -s push_service_ws.log 从第 20 行开始显示 testfile 之文档内容 [push_service_ws-00 push_service]$ more +20 -s push_service_ws.log [] 2021-08-21 00:04:57 - [INFO] [VerifyListener:36 onData] 8f9b7791-7b30-4ee0-9107-e9b4b8ffdc03 verify token success, token:eyJ0eXAiOiJKV1QiLCJhbG ciOiJIUzI1NiJ9.eyJzdWIiOjYzODcwLCJpc3MiOiJjYzliZDRmNGIxOTQ0YzQwYjFmZDQ3NjhiNDA3ZDkwZCIsImV4cCI6MTYyOTQ3NTU1NywiaWF0IjoxNjI5NDc1NDk3fQ.Y4kiuRU0lOCo t5gbZF_ckTz4JDIRgu14qPFCtNkSVG0 [] 2021-08-21 00:04:57 - [INFO] [SessionManagerAspect:57 doBefore] [推送服务WS][AOP] 请求参数[方法名:add 参数列表:[63870, 8f9b7791-7b30-4ee0-9107- e9b4b8ffdc03]] [] 2021-08-21 00:04:57 - [INFO] [SessionManagerAspect:92 addMethodManage] [推送服务WS][AOP] ADD方法设置REDIS相关KEY完毕 [userId 63870| sessionId 8 f9b7791-7b30-4ee0-9107-e9b4b8ffdc03] [] 2021-08-21 00:04:57 - [INFO] [VerifyListener:36 onData] d9dca042-82bc-494c-b241-8ba1dd70b5b8 verify token success, token:eyJ0eXAiOiJKV1QiLCJhbG ciOiJIUzI1NiJ9.eyJzdWIiOjYzODcwLCJpc3MiOiJjYzliZDRmNGIxOTQ0YzQwYjFmZDQ3NjhiNDA3ZDkwZCIsImV4cCI6MTYyOTQ3NTU1NywiaWF0IjoxNjI5NDc1NDk3fQ.Y4kiuRU0lOCo t5gbZF_ckTz4JDIRgu14qPFCtNkSVG0 从文件中查找第一个出现”addMethodManage”字符串的行，并从该处前两行开始显示输出 [rd@线上-基础架构-车源-话务-push_service_ws-00 push_service]$ more +&#x2F;addMethodManage push_service_ws.log ...skipping [] 2021-08-21 00:04:57 - [INFO] [VerifyListener:36 onData] 3803cbb2-e7a0-469a-b20d-1f4e1a2deb5c verify token success, token:eyJ0eXAiOiJKV1QiLCJhbG ciOiJIUzI1NiJ9.eyJzdWIiOjYzODcwLCJpc3MiOiJjYzliZDRmNGIxOTQ0YzQwYjFmZDQ3NjhiNDA3ZDkwZCIsImlhdCI6MTYyOTQ3NTQ5N30.B9u0T0DbDOFJXHsPUtTnjEr96026UOzqaso imuNm2Gw [] 2021-08-21 00:04:57 - [INFO] [SessionManagerAspect:57 doBefore] [推送服务WS][AOP] 请求参数[方法名:add 参数列表:[63870, 3803cbb2-e7a0-469a-b20d- 1f4e1a2deb5c]] [] 2021-08-21 00:04:57 - [INFO] [SessionManagerAspect:92 addMethodManage] [推送服务WS][AOP] ADD方法设置REDIS相关KEY完毕 [userId 63870| sessionId 3 803cbb2-e7a0-469a-b20d-1f4e1a2deb5c] 设定每屏显示行数 [push_service_ws-00 push_service]$ more -5 push_service_ws.log [] 2021-08-21 00:00:33 - [INFO] [DefaultDisconnectListener:19 onDisconnect] eefc6553-ddba-403b-be58-6d0e92543680 has disconnected [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:57 doBefore] [推送服务WS][AOP] 请求参数[方法名:removeSession 参数列表:[eefc6553-ddba-403b-be 58-6d0e92543680]] [] 2021-08-21 00:00:33 - [INFO] [SessionManagerAspect:123 removeMethodManage] [推送服务WS][AOP] REMOVE方法移除SESSION KEY [sessionId eefc6553-ddba -403b-be58-6d0e92543680] --More--(0%) 一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来 [push_service_ws-00 tmp]$ ls -l | more -5 total 8 srwxr-xr-x 1 root root 0 Feb 12 2020 Aegis-&lt;Guid(5A2C30A2-A87D-490A-9281-6765EDAD7CBA)&gt; drwxr-xr-x 2 root root 4096 Apr 13 2020 hsperfdata_root drwxr-xr-x 2 work work 4096 Jul 8 21:14 hsperfdata_work srwxrwxrwx 1 root root 0 May 24 2017 qtsingleapp-aegisG-46d2 --More-- less 语法 less [参数] 文件 参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &lt;数字&gt; 将”tab”键显示为规定的数字空格 /字符串：向下搜索”字符串”的功能 ?字符串：向上搜索”字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） b 向上翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一页 回车键 滚动一行 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 查看文件 less log2013.log 可以按大写 F，就会有类似 tail -f 的效果，读取写入文件的最新内容， 按 ctrl+C 停止。 可以按 v 进入编辑模型， shift+ZZ 保存退出到 less 查看模式。 ps查看进程信息并通过less分页显示 ps -ef |less 浏览多个文件 less log2013.log log2014.log 说明：输入 ：n后，切换到 log2014.log输入 ：p 后，切换到log2013.log","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"cat命令","slug":"linux-cat","date":"2021-08-16T15:15:47.000Z","updated":"2021-08-16T15:44:23.520Z","comments":true,"path":"2021/08/16/linux-cat/","link":"","permalink":"http://www.yipinxieli.com/2021/08/16/linux-cat/","excerpt":"cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。","text":"cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。 cat命令语法格式cat [-AbeEnstTuv] [--help] [--version] fileName 参数说明：-n 或 –number：由 1 开始对所有输出的行数编号。 -b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。 -s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。 -v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。 -E 或 –show-ends : 在每行结束处显示 $。 -T 或 –show-tabs: 将 TAB 字符显示为 ^I。 -A, –show-all：等价于 -vET。 -e：等价于”-vE”选项； -t：等价于”-vT”选项； 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里： [wang@localhost ~]$ cat textfile2 [wang@localhost ~]$ cat text cat: text: 没有那个文件或目录 [wang@localhost ~]$ cat textfile1 11111111111111111 22222222222222222 3 4444444444444444 5555555555555555 6666666666666666 999999999999999 [wang@localhost ~]$ cat -n textfile1 &gt; textfile2 [wang@localhost ~]$ cat textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 6 4444444444444444 7 5555555555555555 8 6666666666666666 9 10 11 999999999999999 清空 textfile2 文档内容： [wang@localhost ~]$ cat textfile2 1 11111111111111111 2 22222222222222222 3 3 4 5 6 4444444444444444 7 5555555555555555 8 6666666666666666 9 10 11 999999999999999 [wang@localhost ~]$ cat &#x2F;dev&#x2F;null &gt; textfile2 [wang@localhost ~]$ cat textfile2 [wang@localhost ~]$ cat text 把 textfile1 和 textfile2 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里。 [wang@localhost ~]$ cat -nb textfile1 textfile2 &gt; log.log [wang@localhost ~]$ ll 总用量 12 -rw-rw-r--. 1 wang wang 421 8月 16 23:40 log.log drwxrwxr-x. 5 wang wang 36 8月 14 22:57 scf drwxrwxr-x. 4 wang wang 66 8月 15 02:46 test -rw-rw-r--. 1 wang wang 109 8月 16 23:26 textfile1 -rw-rw-r--. 1 wang wang 186 8月 16 23:32 textfile2 drwxrwxr-x. 3 wang wang 53 8月 15 02:38 wangql drwxr-xr-x. 2 wang wang 6 8月 4 00:58 公共 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 模板 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 视频 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 图片 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 文档 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 下载 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 音乐 drwxr-xr-x. 2 wang wang 6 8月 4 00:58 桌面 [wang@localhost ~]$ cat log.log 1 11111111111111111 2 22222222222222222 3 3 4 4444444444444444 5 5555555555555555 6 6666666666666666 7 999999999999999 8 1 11111111111111111 9 2 22222222222222222 10 3 3 11 4 12 5 13 6 4444444444444444 14 7 5555555555555555 15 8 6666666666666666 16 9 17 10 18 11 999999999999999 [wang@localhost ~]$","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"与目录相关的操作命令","slug":"linux-dir","date":"2021-08-14T14:19:07.000Z","updated":"2021-08-15T03:01:13.665Z","comments":true,"path":"2021/08/14/linux-dir/","link":"","permalink":"http://www.yipinxieli.com/2021/08/14/linux-dir/","excerpt":"Linux与目录相关的操作命令学习","text":"Linux与目录相关的操作命令学习 与目录相关的操作命令 mkdir命令 用于创建目录,要求创建目录的用户在当前目录中具有写权限 语法 mkdir dirName 命令参数： -m 设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p 此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v 每次创建新目录都显示信息 [wang@localhost ~]$ ls 公共 模板 视频 图片 文档 下载 音乐 桌面 [wang@localhost ~]$ mkdir wang [wang@localhost ~]$ mkdir wangql -v mkdir: 已创建目录 &quot;wangql&quot; [wang@localhost ~]$ mkdir -pv wang&#x2F;tieniu&#x2F;zhu mkdir: 已创建目录 &quot;wang&#x2F;tieniu&quot; mkdir: 已创建目录 &quot;wang&#x2F;tieniu&#x2F;zhu&quot; [wang@localhost ~]$ mkdir -vp scf&#x2F;&#123;lib&#x2F;,bin&#x2F;,doc&#x2F;&#123;info,product&#125;&#125; mkdir: 已创建目录 &quot;scf&quot; mkdir: 已创建目录 &quot;scf&#x2F;lib&#x2F;&quot; mkdir: 已创建目录 &quot;scf&#x2F;bin&#x2F;&quot; mkdir: 已创建目录 &quot;scf&#x2F;doc&quot; mkdir: 已创建目录 &quot;scf&#x2F;doc&#x2F;info&quot; mkdir: 已创建目录 &quot;scf&#x2F;doc&#x2F;product&quot; rmdir 命令 用于删除空白目录，删除某目录时也必须具有对父目录的写权限 语法 rmdir dirName 命令参数： - p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。 -v 显示指令执行过程 [wang@localhost ~]$ rmdir doc rmdir: 删除 &quot;doc&quot; 失败: 没有那个文件或目录 [wang@localhost ~]$ ls scf test wang wangql 公共 模板 视频 图片 文档 下载 音乐 桌面 [wang@localhost ~]$ rmdir scf&#x2F;doc rmdir: 删除 &quot;scf&#x2F;doc&quot; 失败: 目录非空 [wang@localhost ~]$ rmdir scf&#x2F;doc&#x2F;info [wang@localhost ~]$ rmdir -v scf&#x2F;doc&#x2F;product rmdir: 正在删除目录 &quot;scf&#x2F;doc&#x2F;product&quot; [root@localhost wang]# tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test ├── wang │ └── tieniu │ └── zhu ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 rm命令 删除一个目录中的一个或多个文件或目录，删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r” 语法： rm dirName 命令参数： -f, –force 忽略不存在的文件，从不给出提示。 -i, –interactive 进行交互式删除 -r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v, –verbose 详细显示进行的步骤 [root@localhost wang]# ls scf test wang wangql wang.txt 公共 模板 视频 图片 文档 下载 音乐 桌面 [root@localhost wang]# rm wang.txt rm：是否删除普通空文件 &quot;wang.txt&quot;？y [root@localhost wang]# ls scf test wang wangql 公共 模板 视频 图片 文档 下载 音乐 桌面 [root@localhost wang]# -- 强制删除 [root@localhost wang]# ls scf test wang wangql wang.txt 公共 模板 视频 图片 文档 下载 音乐 桌面 [root@localhost wang]# rm -f wang wang&#x2F; wangql&#x2F; wang.txt [root@localhost wang]# rm -f wang.txt [root@localhost wang]# -- 删除前逐一询问确认 [root@localhost wang]# rm -i wang*.txt rm：是否删除普通空文件 &quot;wang1.txt&quot;？y rm：是否删除普通空文件 &quot;wang2.txt&quot;？y rm：是否删除普通空文件 &quot;wang3.txt&quot;？y [root@localhost wang]# -- 将 wang子目录及子目录中所有档案删除 [root@localhost wang]# mkdir -p wang&#x2F;wang1&#x2F;wang2&#x2F;wang3 [root@localhost wang]# tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test ├── wang │ ├── tieniu │ │ └── zhu │ └── wang1 │ └── wang2 │ └── wang3 ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 20 directories, 0 files [root@localhost wang]# rm -r wang rm：是否进入目录&quot;wang&quot;? y rm：是否进入目录&quot;wang&#x2F;tieniu&quot;? y rm：是否删除目录 &quot;wang&#x2F;tieniu&#x2F;zhu&quot;？y rm：是否删除目录 &quot;wang&#x2F;tieniu&quot;？y rm：是否进入目录&quot;wang&#x2F;wang1&quot;? y rm：是否进入目录&quot;wang&#x2F;wang1&#x2F;wang2&quot;? y rm：是否删除目录 &quot;wang&#x2F;wang1&#x2F;wang2&#x2F;wang3&quot;？y rm：是否删除目录 &quot;wang&#x2F;wang1&#x2F;wang2&quot;？y rm：是否删除目录 &quot;wang&#x2F;wang1&quot;？y rm：是否删除目录 &quot;wang&quot;？y [root@localhost wang]# rm -rf [目录] 一个危险的命令会将目录及子目录中所有档案删除,并且不用一一确认。 mv命令 语法： mv [选项] 源文件或目录 目标文件或目录 命令参数： -b ：若需覆盖文件，则覆盖前先行备份。 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会更新(update) 文件重命名：mv source_file(文件) dest_file(文件) [root@localhost wang]# touch wang.txt [root@localhost wang]# mv wang.txt rename.log [root@localhost wang]# ls rename.log scf test wangql 公共 模板 视频 图片 文档 下载 音乐 桌面 [root@localhost wang]# # 目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名。 [root@localhost test]# touch wang.xtx [root@localhost test]# ls wang.xtx [root@localhost test]# pwd &#x2F;home&#x2F;wang&#x2F;test [root@localhost test]# mv &#x2F;home&#x2F;wang&#x2F;test&#x2F;wang.xtx &#x2F;home&#x2F;wang&#x2F;test&#x2F;rename.txt [root@localhost test]# ls rename.txt [root@localhost test]# 移动文件：mv source_file(文件) dest_directory(目录) [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── wangql │ └── test │ ├── rename.log │ └── rename.txt ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 14 directories, 2 files [wang@localhost ~]$ [wang@localhost ~]$ pwd &#x2F;home&#x2F;wang [wang@localhost ~]$ mv wang&#x2F;* test mv: 无法获取&quot;wang&#x2F;*&quot; 的文件状态(stat): 没有那个文件或目录 [wang@localhost ~]$ mv wangql&#x2F;* test [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ ├── rename.log │ └── rename.txt ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 14 directories, 2 files [wang@localhost ~]$ mv source_directory(目录) dest_directory(目录) 目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ ├── rename.log │ └── rename.txt ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 14 directories, 2 files [wang@localhost ~]$ mv test test11 [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test11 │ ├── rename.log │ └── rename.txt ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 14 directories, 2 files [wang@localhost ~]$ mkdir test [wang@localhost ~]$ mv test11 test [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ └── test11 │ ├── rename.log │ └── rename.txt ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 15 directories, 2 files [wang@localhost ~]$ 移动当前文件夹下的所有文件到上一级目录 mv * ../ [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ └── test11 │ ├── rename.log │ └── rename.txt ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 15 directories, 2 files [wang@localhost ~]$ [wang@localhost ~]$ cd test&#x2F;test11 [wang@localhost test11]$ mv * ..&#x2F; [wang@localhost test11]$ tree -N . 0 directories, 0 files [wang@localhost test11]$ cd [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ ├── rename.log │ ├── rename.txt │ └── test11 ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 15 directories, 2 files [wang@localhost ~]$ cp命令 主要用于复制文件或目录。 参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。 -f：覆盖已经存在的目标文件而不给出提示。 -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。 -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l：不复制文件，只是生成链接文件。 在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。 [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ ├── rename.log │ ├── rename.txt │ └── test11 ├── wangql ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 15 directories, 2 files [wang@localhost ~]$ cp -r test&#x2F;* wangql [wang@localhost ~]$ tree -N . ├── scf │ ├── bin │ ├── doc │ └── lib ├── test │ ├── rename.log │ ├── rename.txt │ └── test11 ├── wangql │ ├── rename.log │ ├── rename.txt │ └── test11 ├── 公共 ├── 模板 ├── 视频 ├── 图片 ├── 文档 ├── 下载 ├── 音乐 └── 桌面 16 directories, 4 files [wang@localhost ~]$ 目标文件存在时，会询问是否覆盖。这是因为cp是cp -i的别名。目标文件存在时，即使加了-f标志，也还会询问是否覆盖。 [root@localhost wang]# cp -r wangql&#x2F;rename.log test cp：是否覆盖&quot;test&#x2F;rename.log&quot;？ y [root@localhost wang]# cp -rf wangql&#x2F;rename.log test cp：是否覆盖&quot;test&#x2F;rename.log&quot;？ y [root@localhost wang]#","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"linux-cd-pwd","slug":"linux-cd-pwd","date":"2021-08-09T16:45:50.000Z","updated":"2021-08-10T16:04:02.668Z","comments":true,"path":"2021/08/10/linux-cd-pwd/","link":"","permalink":"http://www.yipinxieli.com/2021/08/10/linux-cd-pwd/","excerpt":"Linux cd（英文全拼：change directory）命令用于切换当前工作目录。 Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。","text":"Linux cd（英文全拼：change directory）命令用于切换当前工作目录。 Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。 Linux cd命令与pwd 命令cd命令语法：cd [dirName] dirName：要切换的目标目录 使用 cd 或cd ~命令进入当前用户主目录 [wang@localhost ~]$ cd &#x2F; [wang@localhost &#x2F;]$ cd [wang@localhost ~]$ cd &#x2F; [wang@localhost &#x2F;]$ cd ~ [wang@localhost ~]$ 使用cd - 返回进入此目录之前所在的目录 [wang@localhost ~]$ cd &#x2F;bin [wang@localhost bin]$ cd [wang@localhost ~]$ cd - &#x2F;bin [wang@localhost bin]$ pwd命令 用 pwd 命令查看默认工作目录的完整路径 [wang@localhost ~]$ pwd &#x2F;home&#x2F;wang [wang@localhost ~]$ 目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径 [wang@localhost ~]$ cd &#x2F;etc&#x2F;init.d [wang@localhost init.d]$ pwd &#x2F;etc&#x2F;init.d [wang@localhost init.d]$ pwd -P &#x2F;etc&#x2F;rc.d&#x2F;init.d","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"junit-assert","slug":"junit-assert","date":"2021-08-09T14:57:08.000Z","updated":"2021-08-28T09:19:13.808Z","comments":true,"path":"2021/08/09/junit-assert/","link":"","permalink":"http://www.yipinxieli.com/2021/08/09/junit-assert/","excerpt":"Junit为我们提供了一些辅助函数，他们用来帮助我们确定被测试的方法是否按照预期的效果正常工作。","text":"Junit为我们提供了一些辅助函数，他们用来帮助我们确定被测试的方法是否按照预期的效果正常工作。 单元测试 – Assert1、Assert.assertEquals(1423263017788772352L, queryUserResp.getUcid());}报错信息： Ambiguous method call: both ‘Assert.assertEquals(Object, Object)’ and ‘Assert.assertEquals(long, long)’ match 这是因为我们的queryUserResp.getUcid() 返回Long，而不是long。因此编译器很困惑：它应该将两个参数都转换为 Object，还是应该只将 Long 转换为 long？ 2、Json表达式验证器JsonPathResultMatchers jsonPath(String expression, Object ... args)&#x2F;ResultMatcher jsonPath(String expression, Matcher matcher) 3、对Map返回值的校验@Test public void insertSupplierBrandStrategyValid() throws Exception &#123; Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); List&lt;String&gt; sessionList &#x3D; new ArrayList&lt;&gt;(2); String session1 &#x3D; UUID.randomUUID().toString(); String session2 &#x3D; UUID.randomUUID().toString(); sessionList.add(session1); sessionList.add(session2); map.put(&quot;1&quot;, sessionList); when(service.getUserSessions(1)).thenReturn(map); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .get(&quot;&#x2F;manager&#x2F;user&#x2F;1&quot;) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON); MvcResult mvcResult &#x3D; mockMvc.perform(requestBuilder) .andDo(print()) &#x2F;&#x2F;打印输出发出请求的详细信息 .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data.length()&quot;).value(1)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data&quot;, Matchers.hasKey(&quot;1&quot;))) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data&quot;, Matchers.hasEntry(&quot;1&quot;,sessionList ))) .andReturn(); System.out.println(mvcResult.getResponse().getContentAsString()); &#125; 4、对List返回值的校验@Test public void testQueryCityAreaTree() throws Exception &#123; List&lt;CityAreaGroupNode&gt; cityAreaTreeList &#x3D; new ArrayList&lt;&gt;(); List&lt;CityAreaGroupNode&gt; cityAreaChildList &#x3D; new ArrayList&lt;&gt;(); CityAreaGroupNode cityAreaChild1 &#x3D; new CityAreaGroupNode(); cityAreaChild1.setId(1045); cityAreaChild1.setTitle(null); cityAreaChild1.setName(&quot;北京陈冲02&quot;); cityAreaChild1.setType(&quot;area&quot;); cityAreaChild1.setParent(&quot;北京&quot;); cityAreaChild1.setParentId(null); cityAreaChild1.setCity(&quot;北京&quot;); cityAreaChild1.setBusiness(&quot;个卖&quot;); cityAreaChild1.setChildren(null); CityAreaGroupNode cityAreaChild2 &#x3D; new CityAreaGroupNode(); cityAreaChild2.setId(1035); cityAreaChild2.setTitle(null); cityAreaChild2.setName(&quot;北京刘玉广01&quot;); cityAreaChild2.setType(&quot;area&quot;); cityAreaChild2.setParent(&quot;北京&quot;); cityAreaChild2.setParentId(null); cityAreaChild2.setCity(&quot;北京&quot;); cityAreaChild2.setBusiness(&quot;个卖&quot;); cityAreaChild2.setChildren(null); cityAreaChildList.add(cityAreaChild1); cityAreaChildList.add(cityAreaChild2); CityAreaGroupNode cityAreaGroupNode1 &#x3D; new CityAreaGroupNode(); cityAreaGroupNode1.setId(1); cityAreaGroupNode1.setTitle(null); cityAreaGroupNode1.setType(&quot;city&quot;); cityAreaGroupNode1.setParent(null); cityAreaGroupNode1.setName(&quot;北京&quot;); cityAreaGroupNode1.setParentId(null); cityAreaGroupNode1.setBusiness(null); cityAreaGroupNode1.setChildren(cityAreaChildList); cityAreaTreeList.add(cityAreaGroupNode1); Mockito.when(auctionParnerService.queryCityAreaTree()).thenReturn(cityAreaTreeList); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .get(&quot;&#x2F;auction&#x2F;areas&#x2F;cityAreaTree&quot;) .param(&quot;aid&quot;, &quot;966926828067360769&quot;); mockMvc.perform(requestBuilder) .andDo(print()) &#x2F;&#x2F;打印输出发出请求的详细信息 .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data&quot;).isNotEmpty()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data.length()&quot;).value(1)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].id&quot;).value(&quot;1&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].type&quot;).value(&quot;city&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].name&quot;).value(&quot;北京&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children.length()&quot;).value(2)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[0].id&quot;).value(1045)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[0].name&quot;).value(&quot;北京陈冲02&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[0].type&quot;).value(&quot;area&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[0].parent&quot;).value(&quot;北京&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[0].business&quot;).value(&quot;个卖&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[0].children&quot;).isEmpty()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].id&quot;).value(1035)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].name&quot;).value(&quot;北京刘玉广01&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].type&quot;).value(&quot;area&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].parent&quot;).value(&quot;北京&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].business&quot;).value(&quot;个卖&quot;)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].title&quot;).isEmpty()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data[0].children[1].parentId&quot;).isEmpty()) .andReturn(); &#125;","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"tools-maven","slug":"tools-maven","date":"2021-08-09T11:27:53.000Z","updated":"2022-02-28T03:38:28.510Z","comments":true,"path":"2021/08/09/tools-maven/","link":"","permalink":"http://www.yipinxieli.com/2021/08/09/tools-maven/","excerpt":"Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。","text":"Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 maven插件maven控制台中文乱码解决方式： 方式一：项目pom.xml中增加 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.12.4&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;argLine&gt;-Dfile.encoding&#x3D;UTF-8&lt;&#x2F;argLine&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; 方式二：在命令行中执行命令时添加mvn test -Dfile.encoding=UTF-8 pom.xml文件横线解决办法现象： 解决办法：","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://www.yipinxieli.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"ls命令","slug":"linux-ls","date":"2021-08-08T14:32:20.000Z","updated":"2021-08-21T17:13:02.207Z","comments":true,"path":"2021/08/08/linux-ls/","link":"","permalink":"http://www.yipinxieli.com/2021/08/08/linux-ls/","excerpt":"ls（英文全拼：list files）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。","text":"ls（英文全拼：list files）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 Linux ls 命令 语法 ls [-alrtAFR] [name...] 参数 : -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 -r 将文件以相反次序显示(原定依英文字母次序) -t 将文件依建立时间之先后次序列出 -A 同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录) -F 在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;, 目录则加 &quot;&#x2F;&quot; -R 若目录下有文件，则以下之文件亦皆依序列出 列出根目录()下的所有目录 [wang@localhost ~]$ ls &#x2F; bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [wang@localhost ~]$ 列出目前工作目录下所有名称是 a 开头的文件，越新的排越后面 : [root@localhost bin]# ls -lR a* -rwxr-xr-x. 1 root root 107824 6月 18 2014 a2p -rwxr-xr-x. 1 root root 11232 6月 19 2014 abrt-action-analyze-backtrace -rwxr-xr-x. 1 root root 11208 6月 19 2014 abrt-action-analyze-c -rwxr-xr-x. 1 root root 1345 6月 19 2014 abrt-action-analyze-ccpp-local -rwxr-xr-x. 1 root root 6821 6月 19 2014 abrt-action-analyze-core -rwxr-xr-x. 1 root root 11208 6月 19 2014 abrt-action-analyze-oops -rwxr-xr-x. 1 root root 11216 6月 19 2014 abrt-action-analyze-python -rwxr-xr-x. 1 root root 2199 6月 19 2014 abrt-action-analyze-vmcore -rwxr-xr-x. 1 root root 1348 6月 19 2014 abrt-action-analyze-vulnerability -rwxr-xr-x. 1 root root 11248 6月 19 2014 abrt-action-analyze-xorg 将 /bin 目录以下所有目录及文件详细资料列出","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"linux-grep","slug":"linux-grep","date":"2021-08-03T15:04:27.000Z","updated":"2021-10-26T10:33:54.840Z","comments":true,"path":"2021/08/03/linux-grep/","link":"","permalink":"http://www.yipinxieli.com/2021/08/03/linux-grep/","excerpt":"grep用于分析一行信息，如果当中包含我们需要的信息，就会将该行拿出来。","text":"grep用于分析一行信息，如果当中包含我们需要的信息，就会将该行拿出来。 Linux grep 命令语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...] 原始文件 [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590650, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105710], sessionSetnull, time&#x3D;1628392590697, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590700, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [fcc01e59b3474decace4da79c85425fc] 2021-08-08 11:17:34 - [INFO] [MessageController:26 pushMessage] [推送服务gateway] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105371], sessionSetnull, time&#x3D;1628392643858, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - -c: 计算找到查找字符的次数 [wang@localhost ~]$ grep -c &quot;推送服务GATEWAY&quot; wang.txt 8 -i: 忽略大小写 推送服务GATEWAY 与 推送服务gateway [wang@localhost ~]$ grep -i &quot;推送服务GATEWAY&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590650, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105710], sessionSetnull, time&#x3D;1628392590697, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590700, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [fcc01e59b3474decace4da79c85425fc] 2021-08-08 11:17:34 - [INFO] [MessageController:26 pushMessage] [推送服务gateway] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105371], sessionSetnull, time&#x3D;1628392643858, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -n: 输出行号 [wang@localhost ~]$ grep -n &quot;1628392590691&quot; wang.txt 9:[e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -v: 反向选择 [wang@localhost ~]$ grep -v &quot;推送服务GATEWAY]&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [fcc01e59b3474decace4da79c85425fc] 2021-08-08 11:17:34 - [INFO] [MessageController:26 pushMessage] [推送服务gateway] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105371], sessionSetnull, time&#x3D;1628392643858, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - –color=auto: 将查找到的关键字部分加上颜色.CENTOS7中，默认的grep命令已经主动使用–color=auto [wang@localhost ~]$ grep --color &quot;推送服务GATEWAY]&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590650, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105710], sessionSetnull, time&#x3D;1628392590697, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590700, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 -A: 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 [wang@localhost ~]$ grep --color -A1 &quot;推送服务GATEWAY]&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590650, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - -- [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105710], sessionSetnull, time&#x3D;1628392590697, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - -- [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - -- [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590700, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - -- [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [fcc01e59b3474decace4da79c85425fc] 2021-08-08 11:17:34 - [INFO] [MessageController:26 pushMessage] [推送服务gateway] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105371], sessionSetnull, time&#x3D;1628392643858, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -B: 除了显示符合样式的那一行之外，并显示该行之前的内容 [wang@localhost ~]$ grep --color -B1 &quot;推送服务GATEWAY]&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590650, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -- [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105710], sessionSetnull, time&#x3D;1628392590697, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -- [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -- [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590700, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] -- [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 -C: 除了显示符合样式的那一行之外，并显示该行及其前后各n行 [wang@localhost ~]$ grep -C 3 &quot;fcc01e59b3474decace4da79c85425fc&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [fcc01e59b3474decace4da79c85425fc] 2021-08-08 11:17:34 - [INFO] [MessageController:26 pushMessage] [推送服务gateway] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105371], sessionSetnull, time&#x3D;1628392643858, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - grep -E 同时匹配多个关键字–或关系 [wang@localhost ~]$ grep -E &quot;推送服务GATEWAY|e2f306c4e56947e3b2f7b92f77f96de7&quot; wang.txt [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590650, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[105710], sessionSetnull, time&#x3D;1628392590697, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[29987], sessionSetnull, time&#x3D;1628392590691, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [INFO] [MessageController:26 pushMessage] [推送服务GATEWAY] 请求参数 [message HttpInMessage [type&#x3D;publish, from&#x3D;cluefactory, to&#x3D;[106011], sessionSetnull, time&#x3D;1628392590700, content&#x3D;&#123;&#39;id&#39;:&#39;10208726&#39;,&#39;phone&#39;:&#39;19184312877&#39;&#125;]] [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - 同时匹配多个关键字–与关系 [wang@localhost ~]$ grep &quot;推送服务GATEWAY&quot; wang.txt | grep &quot;消息接收者Session为空&quot; [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 复杂场景：将/etc/passwd，将没有出现 root 和nologin的行取出来grep -v root /etc/passwd | grep -v nologin -F : 将样式视为固定字符串的列表 或者使用\\进行转义 [wang@localhost ~]$ grep &quot;\\[推送服务GATEWAY\\] 消息接收者Session为空&quot; wang.txt --color [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [wang@localhost ~]$ grep -F &quot;[推送服务GATEWAY] 消息接收者Session为空&quot; wang.txt --color [e2f306c4e56947e3b2f7b92f77f96de7] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [e991a256b22b4917811182ba1d1582c3] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [6cafbdfab9be4a18a97effbb529cb769] 2021-08-08 11:17:23 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [05377816635f4b8b81a0fe9af7da9891] 2021-08-08 11:17:24 - [ERROR] [MessageServiceImpl:92 redisChannelPush] [推送服务GATEWAY] 消息接收者Session为空 [wang@localhost ~]$ grep &quot;[推送服务GATEWAY] 消息接收者Session为空&quot; wang.txt --color [wang@localhost ~]$ 当查询的数据带有””时,使用grep ‘“createSource”:-1,”‘ usercenter_api.log –color [c1_UserCenter_API-00 usercenter_api]$ grep &#39;&quot;createSource&quot;:-1,&quot;&#39; usercenter_api.log --color [b068b442547d43d1b3c6f09fdda08fa0] 2021-08-24 00:00:00-[350679836] - [INFO] [FindUserBUCRouteService:91 findUserBUC][http-nio-0.0.0.0-8080-exec-8] findUserBUC weighted : 1,argsMapString&#x3D;&#123;&quot;ucid&quot;:&quot;1264820333857214464&quot;&#125;, dialout返回值：&#123;&quot;data&quot;:&#123;&quot;createSource&quot;:-1,&quot;nature&quot;:0,&quot;phone&quot;:&quot;D.Bd8e15f65d7fb6a9bf98a9cdd698052db.QTE1OTAzOTE2NDE0NzU5TmJhZ0VnNUpseVQrVFNNSkRHZXdRPT0&#x3D;&quot;,&quot;sourceType&quot;:-1,&quot;unencryptedPhone&quot;:&quot;15101612659&quot;,&quot;userTypes&quot;:1,&quot;isVip&quot;:0,&quot;status&quot;:1,&quot;ucid&quot;:1264820333857214464&#125;,&quot;errMsg&quot;:&quot;ok&quot;,&quot;version&quot;:0,&quot;errorMsg&quot;:&quot;ok&quot;,&quot;status&quot;:0,&quot;ts&quot;:1629734400164&#125;, elapsed:[1] 精确匹配 grep -w &quot;publis&quot; push_service_ws.log --color 正则表达式 查询相应时间大于3秒的数据 [nginx]$ grep -E &quot;elapsed&#x3D;\\[[3-9]&quot; access-2021-09-01.log --color request&#x3D;[POST &#x2F;facade&#x2F;v2&#x2F;user&#x2F;subordinate_relation_by_condition HTTP&#x2F;1.1] status&#x3D;[200] byte&#x3D;[102628] elapsed&#x3D;[3.111] refer&#x3D;[-] request&#x3D;[POST &#x2F;facade&#x2F;v2&#x2F;user&#x2F;subordinate_relation_by_condition HTTP&#x2F;1.1] status&#x3D;[200] byte&#x3D;[102628] elapsed&#x3D;[3.217] refer&#x3D;[-] request&#x3D;[POST &#x2F;facade&#x2F;v2&#x2F;user&#x2F;subordinate_relation_by_condition HTTP&#x2F;1.1] status&#x3D;[200] byte&#x3D;[102628] elapsed&#x3D;[3.098] refer&#x3D;[-] request&#x3D;[POST &#x2F;facade&#x2F;v2&#x2F;user&#x2F;subordinate_relation_by_condition HTTP&#x2F;1.1] status&#x3D;[200] byte&#x3D;[102628] elapsed&#x3D;[3.250] refer&#x3D;[-] request&#x3D;[POST &#x2F;facade&#x2F;v2&#x2F;user&#x2F;subordinate_relation_by_condition HTTP&#x2F;1.1] status&#x3D;[200] byte&#x3D;[102628] elapsed&#x3D;[3.041] refer&#x3D;[-] -r 指定要查找的是目录而非文件时，必须使用此参数 [[authority]$ grep -r &quot;info&quot; &#x2F;mnt&#x2F;logs&#x2F;authority&#x2F; &#x2F;mnt&#x2F;logs&#x2F;authority&#x2F;authority-api-info_2021-10-23.log:[7b40af7650074aeba22420fabbd919a9] 2021-10-23 00:02:47 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 42621 &#x2F;mnt&#x2F;logs&#x2F;authority&#x2F;authority-api-info_2021-10-23.log:[db79ba6c83604231bc34c66814ef4988] 2021-10-23 00:03:17 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 42621 ] 在多个文件中查找 [authority]$ grep &quot;78d869ab3b2d403a8903602c5a717953&quot; authority-api-info.log authority-api-info_2021-10-25.log authority-api-info.log:[78d869ab3b2d403a8903602c5a717953] 2021-10-26 18:15:42 - [INFO] [SlowLogAspect:67 logController] 请求开始 controller UserController.queryUserHierarchy [49089] authority-api-info.log:[78d869ab3b2d403a8903602c5a717953] 2021-10-26 18:15:42 - [INFO] [UserController:45 queryUserHierarchy] query user area group hierarchy and userId&#x3D;49089 authority-api-info.log:[78d869ab3b2d403a8903602c5a717953] 2021-10-26 18:15:42 - [INFO] [SlowLogAspect:73 logController] 请求结束，controller response &#123;&quot;data&quot;:&#123;&#125;, elapse[14ms] grep 与 head结合，返回符合条件前N个 [authority]$ grep &quot;info&quot; authority-api-info.log | head -n1 [69168ac54e4b434cbc756003bbe80fa6] 2021-10-26 00:01:26 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 64061 [authority]$ grep &quot;info&quot; authority-api-info.log | head -n2 [69168ac54e4b434cbc756003bbe80fa6] 2021-10-26 00:01:26 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 64061 [0c2acd74aff6416a942df7fb5793fe9b] 2021-10-26 00:02:11 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 67694 [authority]$ grep &quot;info&quot; authority-api-info.log | head -n3 [69168ac54e4b434cbc756003bbe80fa6] 2021-10-26 00:01:26 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 64061 [0c2acd74aff6416a942df7fb5793fe9b] 2021-10-26 00:02:11 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 67694 [51aba4fa356a4afdbe9c01a5f594e16d] 2021-10-26 00:02:21 - [INFO] [KaController:147 getKaOrPartnerInfoByUserId] Get ka or partner info by user_id : 43750","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"spring-boot-redis","slug":"spring-boot-redis","date":"2021-07-31T17:57:52.000Z","updated":"2021-07-31T18:39:44.536Z","comments":true,"path":"2021/08/01/spring-boot-redis/","link":"","permalink":"http://www.yipinxieli.com/2021/08/01/spring-boot-redis/","excerpt":"记录Springboot整合redis中遇到的问题。","text":"记录Springboot整合redis中遇到的问题。 Springboot整合redis相关配置POM文件 &lt;!--添加父工程依赖--> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.5.0&lt;/version> &lt;relativePath/> &lt;/parent> &lt;!--添加redis相关依赖--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.commons&lt;/groupId> &lt;artifactId>commons-pool2&lt;/artifactId> &lt;/dependency> application.yml # 测试环境 spring: #redis redis: database: 0 host: 127.0.0.1 port: 6379 password: foobared timeout: 5000 # 连接池设置 lettuce: pool: max-idle: 8 max-wait: -1 min-idle: 1 max-active: 8 shutdowntimeout: 100 RedisConfig相关代码 package com.rrc.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import com.rrc.listener.RedisReceiver; import lombok.extern.slf4j.Slf4j; import org.apache.commons.pool2.impl.GenericObjectPoolConfig; import org.springframework.beans.factory.annotation.Value; import org.springframework.cache.interceptor.KeyGenerator; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisPassword; import org.springframework.data.redis.connection.RedisStandaloneConfiguration; import org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; import org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.listener.ChannelTopic; import org.springframework.data.redis.listener.RedisMessageListenerContainer; import org.springframework.data.redis.listener.adapter.MessageListenerAdapter; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Slf4j @Configuration public class RedisConfig &#123; @Value(&quot;$&#123;spring.redis.database&#125;&quot;) private int database; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.password&#125;&quot;) private String password; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int port; @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;) private long timeout; @Value(&quot;$&#123;spring.redis.lettuce.shutdown-timeout&#125;&quot;) private long shutDownTimeout; @Value(&quot;$&#123;spring.redis.lettuce.pool.max-idle&#125;&quot;) private int maxIdle; @Value(&quot;$&#123;spring.redis.lettuce.pool.min-idle&#125;&quot;) private int minIdle; @Value(&quot;$&#123;spring.redis.lettuce.pool.max-active&#125;&quot;) private int maxActive; @Value(&quot;$&#123;spring.redis.lettuce.pool.max-wait&#125;&quot;) private long maxWait; &#x2F;&#x2F;json序列化器 private Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class); @Bean public LettuceConnectionFactory lettuceConnectionFactory() &#123; GenericObjectPoolConfig genericObjectPoolConfig &#x3D; new GenericObjectPoolConfig(); genericObjectPoolConfig.setMaxIdle(maxIdle); genericObjectPoolConfig.setMinIdle(minIdle); genericObjectPoolConfig.setMaxTotal(maxActive); genericObjectPoolConfig.setMaxWaitMillis(maxWait); genericObjectPoolConfig.setTimeBetweenEvictionRunsMillis(100); RedisStandaloneConfiguration redisStandaloneConfiguration &#x3D; new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setDatabase(database); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setPort(port); redisStandaloneConfiguration.setPassword(RedisPassword.of(password)); LettuceClientConfiguration clientConfig &#x3D; LettucePoolingClientConfiguration.builder() .commandTimeout(Duration.ofMillis(timeout)) .shutdownTimeout(Duration.ofMillis(shutDownTimeout)) .poolConfig(genericObjectPoolConfig) .build(); LettuceConnectionFactory factory &#x3D; new LettuceConnectionFactory(redisStandaloneConfiguration, clientConfig); &#x2F;&#x2F; factory.setShareNativeConnection(true); &#x2F;&#x2F; factory.setValidateConnection(false); return factory; &#125; &#x2F;&#x2F;redisTemplate模板提供给其他类对redis数据库进行操作 @Bean(name &#x3D; &quot;redisTemplate&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory redisConnectionFactory) &#123; &#x2F;&#x2F;序列化配置 Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper objectMapper &#x3D; new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectJackson2JsonRedisSerializer.setObjectMapper(objectMapper); RedisTemplate&lt;String, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(keySerializer()); redisTemplate.setHashKeySerializer(keySerializer()); redisTemplate.setValueSerializer(valueSerializer()); redisTemplate.setHashValueSerializer(valueSerializer()); log.debug(&quot;自定义RedisTemplate加载完成&quot;); return redisTemplate; &#125; &#x2F;&#x2F;redis键序列化使用StrngRedisSerializer private RedisSerializer&lt;String&gt; keySerializer() &#123; return new StringRedisSerializer(); &#125; &#x2F;&#x2F;redis值序列化使用json序列化器 private RedisSerializer&lt;Object&gt; valueSerializer() &#123; return new GenericJackson2JsonRedisSerializer(); &#125; &#x2F;&#x2F;缓存键自动生成器 @Bean public KeyGenerator myKeyGenerator() &#123; return (target, method, params) -&gt; &#123; StringBuilder sb &#x3D; new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125;; &#125; &#x2F;** * redis消息监听器容器 * 点赞消息订阅处理器 * * @param collectListenerAdapter 关注消息订阅处理器 * @return *&#x2F; @Bean RedisMessageListenerContainer container(LettuceConnectionFactory redisConnectionFactory, MessageListenerAdapter collectListenerAdapter, MessageListenerAdapter commentListenerAdapter) &#123; RedisMessageListenerContainer container &#x3D; new RedisMessageListenerContainer(); container.setConnectionFactory(redisConnectionFactory); &#x2F;&#x2F; 以下为修改默认的序列化方式，网上大多数消息发布订阅都是String类型,但是实际中数据类型肯定不止String类型 Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer&lt;Object&gt;( Object.class); ObjectMapper objectMapper &#x3D; new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); &#x2F;&#x2F; 收藏主题并绑定消息订阅处理器 collectListenerAdapter.setSerializer(jackson2JsonRedisSerializer); container.addMessageListener(collectListenerAdapter, new ChannelTopic(&quot;TOPIC_COLLECT&quot;)); return container; &#125; &#x2F;** * 收藏消息订阅处理器,并指定处理方法 * * @param receiver * @return *&#x2F; @Bean MessageListenerAdapter commentListenerAdapter(RedisReceiver receiver) &#123; MessageListenerAdapter commentListenerAdapter &#x3D; new MessageListenerAdapter(receiver); &#x2F;&#x2F;消息的反序列化方式 commentListenerAdapter.setSerializer(jackson2JsonRedisSerializer); return commentListenerAdapter; &#125; &#125; 踩坑记录&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;SpringBoot 服务启动完毕&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 2021-08-01 02:16:15.116 [main] INFO org.springframework.boot.availability.ApplicationAvailabilityBean 75 logStateChange - Application availability state ReadinessState changed to ACCEPTING_TRAFFIC 2021-08-01 02:16:15.813 [container-2] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer 651 handleSubscriptionException - Connection failure occurred. Restarting subscription task after 5000 ms 2021-08-01 02:16:20.823 [container-3] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer 651 handleSubscriptionException - Connection failure occurred. Restarting subscription task after 5000 ms 2021-08-01 02:16:25.847 [container-4] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer 651 handleSubscriptionException - Connection failure occurred. Restarting subscription task after 5000 ms 2021-08-01 02:16:30.860 [container-5] ERROR org.springframework.data.redis.listener.RedisMessageListenerContainer 651 handleSubscriptionException - Connection failure occurred. Restarting subscription task after 5000 ms 以上为报错信息看到handleSubscriptionException。刚开始以为自己的发布订阅模式配置有问题，最后发现为密码错误，但是启动Application一直会提示重连，不会有其他的提示信息。 但是写一个简单的单元测试后会发现提示密码错误ERR invalid password Caused by: io.lettuce.core.RedisConnectionException: Unable to connect to 127.0.0.1:6379 at io.lettuce.core.RedisConnectionException.create(RedisConnectionException.java:78) at io.lettuce.core.RedisConnectionException.create(RedisConnectionException.java:56) at io.lettuce.core.AbstractRedisClient.getConnection(AbstractRedisClient.java:330) at io.lettuce.core.RedisClient.connect(RedisClient.java:216) Caused by: io.lettuce.core.RedisCommandExecutionException: ERR invalid password at io.lettuce.core.internal.ExceptionFactory.createExecutionException(ExceptionFactory.java:137)","categories":[{"name":"Spring","slug":"Spring","permalink":"http://www.yipinxieli.com/categories/Spring/"}],"tags":[{"name":"spring-boot-starter-data-redis","slug":"spring-boot-starter-data-redis","permalink":"http://www.yipinxieli.com/tags/spring-boot-starter-data-redis/"}]},{"title":"springEL","slug":"springEL","date":"2021-07-28T15:37:19.000Z","updated":"2021-07-29T16:44:24.316Z","comments":true,"path":"2021/07/28/springEL/","link":"","permalink":"http://www.yipinxieli.com/2021/07/28/springEL/","excerpt":"为了更加灵活,Spring 还提供了表达式语言Spring EL 。通过Spring EL 可以拥有更为强大的运算规则来更好地装配Bean。","text":"为了更加灵活,Spring 还提供了表达式语言Spring EL 。通过Spring EL 可以拥有更为强大的运算规则来更好地装配Bean。 SpringEL表达式Spring表达式语言（简称SpEL）是一个支持查询和操作运行时对象导航图功能的强大的表达式语言。不直接依赖于Spring,可独立使用。底层实现：接口ExpressionParser负责解析表达式字符串。 XML中使用相应的实体定义 package com.rrc.entity; import lombok.Data; @Data public class Customer &#123; private String name; private String telephone; &#125; package com.rrc.config; import com.rrc.entity.Customer; import lombok.Getter; import lombok.Setter; public class ConsumerComponent &#123; @Getter @Setter private Customer customer; @Getter @Setter private String custName; @Getter @Setter private String telephone; &#125; XML配置，在resources目录下新建spring-other.xml。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"customer\" class=\"com.rrc.entity.Customer\"> &lt;property name=\"name\" value=\"张三\"/> &lt;property name=\"telephone\" value=\"13666666666\"/> &lt;/bean> &lt;bean id=\"customerDao\" class=\"com.rrc.config.ConsumerComponent\"> &lt;property name=\"customer\" value=\"#&#123;customer&#125;\">&lt;/property> &lt;property name=\"custName\" value=\"#&#123;customer.name&#125;\">&lt;/property> &lt;property name=\"telephone\" value=\"#&#123;customer.telephone&#125;\">&lt;/property> &lt;/bean> &lt;/beans> 我们在Application中打印ConsumerComponent类下三个属性的值 package com.rrc; import com.rrc.config.ConsumerComponent; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.ImportResource; @Slf4j @SpringBootApplication @ImportResource(locations &#x3D; &quot;classpath:spring-other.xml&quot;) public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(Application.class); ConsumerComponent consumerComponent &#x3D; ctx.getBean(ConsumerComponent.class); log.info(&quot;consumerComponent custName &#123;&#125;&quot;, consumerComponent.getCustName()); log.info(&quot;consumerComponent telephone &#123;&#125;&quot;, consumerComponent.getTelephone()); log.info(&quot;consumerComponent customer &#123;&#125;&quot;, consumerComponent.getCustomer()); &#125; &#125; 2021-07-29 01:02:09.045 [main] INFO com.rrc.Application 21 main - consumerComponent custName 张三 2021-07-29 01:02:09.047 [main] INFO com.rrc.Application 22 main - consumerComponent telephone 13666666666 2021-07-29 01:02:09.047 [main] INFO com.rrc.Application 23 main - consumerComponent customer Customer(name&#x3D;张三, telephone&#x3D;13666666666) JAVA中使用我们把在XML中的customerDao的配置从XML移动到JAVA文件中，相应的修改如下。启动项目之后依旧可以打印出相关的信息。 package com.rrc.config; import com.rrc.entity.Customer; import lombok.Data; import lombok.Getter; import lombok.Setter; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component @Data public class ConsumerComponent &#123; @Value(&quot;#&#123;customer&#125;&quot;) private Customer customer; @Value(&quot;#&#123;customer.name&#125;&quot;) private String custName; @Value(&quot;#&#123;customer.telephone&#125;&quot;) private String telephone; &#125; EL使用场景 方法：EL可以调用另一个对象的方法或者属性 @Value(&quot;#&#123;originBean.getELvalue()&#125;&quot;) private String telephone; package com.rrc.config; import org.springframework.stereotype.Component; @Component public class OriginBean &#123; public String getELvalue() &#123; return &quot;EL METHOD&quot;; &#125; &#125; 构造：EL可以调用new关键字，实现构造方法调用，实例化出对象来 @Value(“#{new int[]{1,2,3}}”) @Value(“#{new 包名.类名()}”) package com.rrc.config; import com.rrc.entity.School; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component @Data public class ConsumerComponent &#123; @Value(&quot;#&#123;originBean.getELvalue()&#125;&quot;) private String telephone; @Value(&quot;#&#123;new int[]&#123;1, 2, 3&#125;&#125;&quot;) private int[] intArray; @Value(&quot;#&#123;new com.rrc.entity.School()&#125;&quot;) private School school; &#125; 操作符 EL支持大多数的算数运算符，@Value(&quot;#&#123;3+4&#125;&quot;) 关系运算符 @Value(&quot;#&#123;1^1&#125;&quot;) 逻辑运算符 @Value(&quot;#&#123;5&gt;3&#125;&quot;) 三元运算符 @Value(&quot;#&#123;1&gt; 2? 0:1&#125;&quot;) 引用： Spring框架——SpringEL","categories":[{"name":"Spring","slug":"Spring","permalink":"http://www.yipinxieli.com/categories/Spring/"}],"tags":[{"name":"springEL","slug":"springEL","permalink":"http://www.yipinxieli.com/tags/springEL/"}]},{"title":"Excel常用操作","slug":"tools-2","date":"2021-07-19T16:05:27.000Z","updated":"2021-09-14T12:24:20.278Z","comments":true,"path":"2021/07/20/tools-2/","link":"","permalink":"http://www.yipinxieli.com/2021/07/20/tools-2/","excerpt":"分享常用的Excel常用操作，提高开发效率。因为老有业务人员让我帮忙导出数据，第一步就是拼SQL，批量操作文件。","text":"分享常用的Excel常用操作，提高开发效率。因为老有业务人员让我帮忙导出数据，第一步就是拼SQL，批量操作文件。 Excel常用操作快捷键EXCEL行列互转复制源数据–右键–选择性粘贴–勾“转置”，确定。 删除单元格内多余的空格和换行符假设数据在A列，在B列输入=TRIM(CLEAN(A1))，然后下拉公式即可 常用快捷键CTRL+SHIFT+↑ 快速定位到行首 CTRL+SHIFT+↓ 快速定位到行尾 SUBSTITUTE函数：对指定的字符串进行替换=substitute(text,old_text,new_text,[instance_num]) =SUBSTITUTE（需要替换的文本，旧文本，新文本，第N个旧文本） 参数Instance_num 可省略，这表示用 new_text（新文本）替换掉所有的old_text（旧文本） 快速填充","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://www.yipinxieli.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-18T17:33:17.834Z","updated":"2021-05-15T13:50:23.921Z","comments":true,"path":"2021/07/19/hello-world/","link":"","permalink":"http://www.yipinxieli.com/2021/07/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Google常用插件","slug":"tools-1","date":"2021-07-16T18:37:10.000Z","updated":"2021-07-17T03:29:49.517Z","comments":true,"path":"2021/07/17/tools-1/","link":"","permalink":"http://www.yipinxieli.com/2021/07/17/tools-1/","excerpt":"分享常用的Google插件，提高开发效率。","text":"分享常用的Google插件，提高开发效率。 Google常用插件 Momentum插件 一个精美而简单的起始页空间，有助于提升我们的工作效率的 每天一碗励志鸡汤 设定每日目标/重点/意图 待办事项列表跟踪任务 查看天气预报 标签页中显示书签栏 从应用商店查找插件，添加到浏览器 首次安装输入昵称 输入邮箱 输入密码 设置每日目标/重点/意图 现在我们就可以实用Momentum插件了，具体的设置都比较简单。 FeHelper前端插件 大家可以根据自己的实际情况添加相应的功能，上图中我只添加了JSON美化和网页截屏。网页截屏我是为了使用其中的滚动截屏工具。","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://www.yipinxieli.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"Git(7) -- git restore","slug":"git6","date":"2021-07-11T16:32:02.000Z","updated":"2021-07-11T16:40:22.898Z","comments":true,"path":"2021/07/12/git6/","link":"","permalink":"http://www.yipinxieli.com/2021/07/12/git6/","excerpt":"","text":"https://blog.csdn.net/albertsh/article/details/104719370/","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"单元测试—Mockito设置方法返回值","slug":"junit5","date":"2021-07-10T09:33:00.000Z","updated":"2021-07-10T13:57:29.824Z","comments":true,"path":"2021/07/10/junit5/","link":"","permalink":"http://www.yipinxieli.com/2021/07/10/junit5/","excerpt":"Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。","text":"Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。 单元测试 – Mockito设置方法返回值1、thenReturn与doReturnthenReturn 用来指定特定函数和参数调用的返回值。 thenReturn 中可以指定多个返回值。在调用时返回值依次出现。若调用次数超过返回值的数量，再次调用时返回最后一个返回值。 doReturn 的作用和thenReturn相同，但使用方式不同(doReturn(1).when(random).nextInt();) @RunWith(MockitoJUnitRunner.class) public class Mocktio &#123; @Mock private ExampleService exampleService; @Test public void test_spy() &#123; MockitoAnnotations.openMocks(this); when(exampleService.add(anyInt(), anyInt())).thenReturn(1, 2, 3); Assert.assertEquals(1, exampleService.add(1, 2)); Assert.assertEquals(2, exampleService.add(9, 7)); Assert.assertEquals(3, exampleService.add(10, 12)); Assert.assertEquals(3, exampleService.add(11, 6)); Assert.assertEquals(3, exampleService.add(7, 3)); &#125; class ExampleService &#123; int add(int a, int b) &#123; System.out.println(&quot;方法调用被执行&quot;); return a+b; &#125; &#125; &#125; 2、thenThrow与doThrowthenThrow用来让函数调用抛出异常。thenThrow 中可以指定多个异常。在调用时异常依次出现。若调用次数超过异常的数量，再次调用时抛出最后一个异常。 对应返回类型是 void 的函数，thenThrow 是无效的，要使用doThrow。doThrow(new RuntimeException(“异常”)).when(exampleService).hello(); @RunWith(MockitoJUnitRunner.class) public class Mocktio &#123; @Mock private ExampleService exampleService; @Test public void test_spy() &#123; MockitoAnnotations.openMocks(this); when(exampleService.add(anyInt(),anyInt())).thenThrow(new RuntimeException(&quot;异常&quot;)); try &#123; exampleService.add(1, 2); Assert.fail(); &#x2F;&#x2F; 上面会抛出异常，所以不会走到这里 &#125; catch (Exception ex) &#123; Assert.assertTrue(ex instanceof RuntimeException); Assert.assertEquals(&quot;异常&quot;, ex.getMessage()); &#125; doThrow(new RuntimeException(&quot;异常&quot;)).when(exampleService).addPrint(1, 2); try &#123; exampleService.addPrint(1, 2); Assert.fail(); &#x2F;&#x2F; 上面会抛出异常，所以不会走到这里 &#125; catch (Exception ex) &#123; Assert.assertTrue(ex instanceof RuntimeException); Assert.assertEquals(&quot;异常&quot;, ex.getMessage()); &#125; &#125; class ExampleService &#123; int add(int a, int b) &#123; System.out.println(&quot;方法调用被执行&quot;); return a+b; &#125; void addPrint(int a, int b) &#123; System.out.println(&quot;方法调用被执行&quot;); &#125; &#125; &#125; 3、thenAnswerthen 和 thenAnswer 的效果是一样的。它们的参数是实现 Answer 接口的对象，在改对象中可以获取调用参数，自定义返回值。 4、引用Mockito 指南 教你使用Mock完成单元测试 springboot test","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"单元测试—Mockito学习","slug":"junit4","date":"2021-07-07T17:19:03.000Z","updated":"2021-07-10T09:34:47.952Z","comments":true,"path":"2021/07/08/junit4/","link":"","permalink":"http://www.yipinxieli.com/2021/07/08/junit4/","excerpt":"Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。","text":"Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。 单元测试 – Mockito入门1、mock()方法org.mockito.Mockito 的 mock 方法可以模拟类和接口，以下代码演示直接在Test方法中对类和接口进行Mock @Test public void test() &#123; List mockList &#x3D; mock(List.class); &#x2F;&#x2F; mock对象的方法返回值默认都是返回类型的默认值。例如返回类型是int，默认返回值是0；类型是一个类，默认返回值是null。 Assert.assertEquals(0, mockList.size()); Assert.assertEquals(null, mockList.get(0)); &#x2F;&#x2F; 调用 mock 对象的写方法，是没有效果的 mockList.add(&quot;a&quot;); &#x2F;&#x2F; 没有指定 size() 方法返回值，这里结果是默认值 Assert.assertEquals(0, mockList.size()); &#x2F;&#x2F; 没有指定 get(0) 返回值，这里结果是默认值 Assert.assertEquals(null, mockList.get(0)); &#x2F;&#x2F; 指定 get(0)时返回 a when(mockList.get(0)).thenReturn(&quot;a&quot;); &#x2F;&#x2F; 没有指定 size() 方法返回值，这里结果是默认值 Assert.assertEquals(0, mockList.size()); &#x2F;&#x2F; 因为上面指定了 get(0) 返回 a，所以这里会返回 a Assert.assertEquals(&quot;a&quot;, mockList.get(0)); &#x2F;&#x2F; 没有指定 get(1) 返回值，这里结果是默认值 Assert.assertEquals(null, mockList.get(1)); &#x2F;&#x2F; 指定 size()返回123 when(mockList.size()).thenReturn(123); Assert.assertEquals(123, mockList.size()); &#125; 2、@Mock 注解@Mock 注解可以理解为对 mock 方法的一个替代。使用该注解时，要使用MockitoAnnotations.openMocks 方法，让注解生效。所以相对于1中的单测，会变成如下的形式。 import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import java.util.List; import static org.mockito.Mockito.when; public class Mocktio &#123; @Mock private List mockList; @Before public void setUp() &#123; MockitoAnnotations.openMocks(this); &#125; @Test public void test() &#123; &#x2F;&#x2F; mock 对象的方法的返回值默认都是返回类型的默认值。例如返回类型是一个类，默认返回值是 null。 Assert.assertEquals(0, mockList.size()); Assert.assertEquals(null, mockList.get(0)); &#x2F;&#x2F; 调用 mock 对象的写方法，是没有效果的 mockList.add(&quot;a&quot;); &#x2F;&#x2F; 没有指定 size() 方法返回值，这里结果是默认值 Assert.assertEquals(0, mockList.size()); &#x2F;&#x2F; 没有指定 get(0) 返回值，这里结果是默认值 Assert.assertEquals(null, mockList.get(0)); &#x2F;&#x2F; 指定 get(0)时返回 a when(mockList.get(0)).thenReturn(&quot;a&quot;); &#x2F;&#x2F; 没有指定 size() 方法返回值，这里结果是默认值 Assert.assertEquals(0, mockList.size()); &#x2F;&#x2F; 因为上面指定了 get(0) 返回 a，所以这里会返回 a Assert.assertEquals(&quot;a&quot;, mockList.get(0)); &#x2F;&#x2F; 没有指定 get(1) 返回值，这里结果是默认值 Assert.assertEquals(null, mockList.get(1)); &#x2F;&#x2F; 指定 size()返回123 when(mockList.size()).thenReturn(123); Assert.assertEquals(123, mockList.size()); &#125; &#125; 3、MockitoJUnitRunnerMockitoAnnotations.initMocks 的一个替代方案是使用 MockitoJUnitRunner ，具体的代码变形为 import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.junit.MockitoJUnitRunner; import java.util.List; import static org.mockito.Mockito.when; @RunWith(MockitoJUnitRunner.class) public class Mocktio &#123; @Mock private List mockList; @Test public void test() &#123; &#x2F;&#x2F; mock 对象的方法的返回值默认都是返回类型的默认值。例如返回类型是一个类，默认返回值是 null。 Assert.assertEquals(0, mockList.size()); Assert.assertEquals(null, mockList.get(0)); &#x2F;&#x2F; 调用 mock 对象的写方法，是没有效果的 mockList.add(&quot;a&quot;); &#x2F;&#x2F; 没有指定 size() 方法返回值，这里结果是默认值 Assert.assertEquals(0, mockList.size()); &#x2F;&#x2F; 没有指定 get(0) 返回值，这里结果是默认值 Assert.assertEquals(null, mockList.get(0)); &#x2F;&#x2F; 指定 get(0)时返回 a when(mockList.get(0)).thenReturn(&quot;a&quot;); &#x2F;&#x2F; 没有指定 size() 方法返回值，这里结果是默认值 Assert.assertEquals(0, mockList.size()); &#x2F;&#x2F; 因为上面指定了 get(0) 返回 a，所以这里会返回 a Assert.assertEquals(&quot;a&quot;, mockList.get(0)); &#x2F;&#x2F; 没有指定 get(1) 返回值，这里结果是默认值 Assert.assertEquals(null, mockList.get(1)); &#x2F;&#x2F; 指定 size()返回123 when(mockList.size()).thenReturn(123); Assert.assertEquals(123, mockList.size()); &#125; &#125; 4、参数匹配&#x2F;&#x2F; 可以使用 Mockito.anyInt() 匹配所有类型为 int 的参数 when(mockList.get(anyInt())).thenReturn(&quot;a&quot;); Assert.assertEquals(&quot;a&quot;, mockList.get(0)); Assert.assertEquals(&quot;a&quot;, mockList.get(1)); mockito 有多种匹配函数，部分如下： 函数名 匹配类型 any() 所有对象类型 anyInt() 基本类型 int、非 null 的 Integer 类型 anyChar() 基本类型 char、非 null 的 Character 类型 anyShort() 基本类型 short、非 null 的 Short 类型 anyBoolean() 基本类型 boolean、非 null 的 Boolean 类型 anyDouble() 基本类型 double、非 null 的 Double 类型 anyFloat() 基本类型 float、非 null 的 Float 类型 anyLong() 基本类型 long、非 null 的 Long 类型 anyByte() 基本类型 byte、非 null 的 Byte 类型 anyString() String 类型(不能是 null) anyList() List&lt;T&gt; 类型(不能是 null) anyMap() Map&lt;K, V&gt;类型(不能是 null) anyCollection() Collection&lt;T&gt;类型(不能是 null) anySet() Set&lt;T&gt;类型(不能是 null) any(Class&lt;T&gt; type) type类型的对象(不能是 null) isNull() null notNull() 非 null 5、@Spy 注解spy 和 mock不同，不同点是： spy 的参数是对象示例，mock 的参数是 class。 被 spy修饰的对象，调用其方法时默认会走真实方法。mock 对象不会。 @RunWith(MockitoJUnitRunner.class) public class Mocktio &#123; @Mock private ExampleService spyExampleService; @Test public void test_spy() &#123; &#x2F;&#x2F;Assert.assertEquals(3, spyExampleService.add(1, 2)); when(spyExampleService.add(1, 2)).thenReturn(10); Assert.assertEquals(10, spyExampleService.add(1, 2)); &#125; class ExampleService &#123; int add(int a, int b) &#123; System.out.println(&quot;方法调用被执行&quot;); return a+b; &#125; &#125; &#125; &#x2F;&#x2F; Console打印为空 &#x2F;&#x2F;如果我们将@Mock注解替换为@Spy 去除单行注释&#x2F;&#x2F;Assert.assertEquals(3, spyExampleService.add(1, 2)); COnsole打印： 方法调用被执行 方法调用被执行","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"单元测试—Mockito的使用","slug":"junit3","date":"2021-07-07T16:32:41.000Z","updated":"2021-07-13T15:52:50.398Z","comments":true,"path":"2021/07/08/junit3/","link":"","permalink":"http://www.yipinxieli.com/2021/07/08/junit3/","excerpt":"Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。","text":"Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。 单元测试 – Mockito的使用需要测试的方法如下： public void recallMessage(RecallMessageDTO recallMessageDTO) &#123; log.info(&quot;[融云][单条消息撤回]请求参数: [recallMessageDTO&#x3D;&#123;&#125;]&quot;, recallMessageDTO); RecallMessage recallMessage &#x3D; new RecallMessage() .setSenderId(recallMessageDTO.getFromUserId()) .setTargetId(recallMessageDTO.getTargetId()) .setuId(recallMessageDTO.getMessageUID()) .setSentTime(recallMessageDTO.getSentTime()) .setIsAdmin(recallMessageDTO.getIsAdmin()) .setIsDelete(recallMessageDTO.getIsDelete()) .setExtra(recallMessageDTO.getExtra()) .setDisablePush(recallMessageDTO.getDisablePush()); Result result &#x3D; null; try&#123; result &#x3D; rongCloud.message.msgPrivate.recall(recallMessage); log.info(&quot;[融云][单条消息撤回]请求结果: [result&#x3D;&#123;&#125;]&quot;, result); if (Objects.isNull(result)) &#123; throw new BusinessException(&quot;[融云][单条消息撤回]请求异常&quot;); &#125; if (!RongCloudCodeEnum.SUCCESS.getCode().equals(result.getCode())) &#123; throw new BusinessException(String.format(&quot;融云聊天室单条消息撤回失败: %s&quot;, result.getErrorMessage())); &#125; &#125; catch (Exception e) &#123; log.error(&quot;[融云][单条消息撤回]请求失败：[recallMessageDTO&#x3D;&#123;&#125;]&quot;, recallMessageDTO, e); throw new BusinessException(&quot;[融云][单条消息撤回]异常&quot;, e); &#125; &#125; 这个方法竟然是我写的，现在一看真是垃圾。try-catch这是干了啥抹杀了作案现场，含泪以他做一下单元测试吧。 在上边的方法中有以下情况需要考虑 result返回值为空的情况 result返回值不是success的情况 rongCloud调用异常的情况 方法正常执行 针对rongCloud的情况，我们需要Mock message和private并赋值给rongCloud。 相应的单元测试代码如下： public class RongCloudServiceTest &#123; @InjectMocks private RongCloudService rongCloudService; @Mock private RongCloud rongCloud; @Rule public ExpectedException thrown&#x3D; ExpectedException.none(); @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); Private privateMsg &#x3D; Mockito.mock(Private.class); Message message &#x3D; Mockito.mock(Message.class); message.msgPrivate &#x3D; privateMsg; rongCloud.message &#x3D; message; &#125; @Test public void recallMessage() throws Exception &#123; Mockito.when(rongCloud.message.msgPrivate.recall(Mockito.any(RecallMessage.class))) .thenReturn(new ResponseResult(RongCloudCodeEnum.SUCCESS.getCode(), RongCloudCodeEnum.SUCCESS.getValue())); rongCloudService.recallMessage(new RecallMessageDTO()); &#125; @Test public void recallMessageNull() throws Exception &#123; thrown.expect(BusinessException.class); thrown.expectMessage(&quot;[融云][单条消息撤回]异常&quot;); Mockito.when(rongCloud.message.msgPrivate.recall(Mockito.any(RecallMessage.class))).thenReturn(null); rongCloudService.recallMessage(new RecallMessageDTO()); &#125; @Test public void recallMessageError() throws Exception &#123; thrown.expect(BusinessException.class); thrown.expectMessage(&quot;[融云][单条消息撤回]异常&quot;); Mockito.when(rongCloud.message.msgPrivate.recall(Mockito.any(RecallMessage.class))) .thenReturn(new ResponseResult(RongCloudCodeEnum.SERVER_ERROR.getCode(), RongCloudCodeEnum.SERVER_ERROR.getValue())); rongCloudService.recallMessage(new RecallMessageDTO()); &#125; @Test public void recallMessageException() throws Exception &#123; thrown.expect(BusinessException.class); thrown.expectMessage(&quot;[融云][单条消息撤回]异常&quot;); Mockito.when(rongCloud.message.msgPrivate.recall(Mockito.any(RecallMessage.class))).thenThrow(new ConnectException(&quot;连接超时&quot;)); rongCloudService.recallMessage(new RecallMessageDTO()); &#125; &#125; private方法如何做单元测试 需要测试的方法如下： private Map&lt;String, Set&lt;String&gt;&gt; getChannelSession(List&lt;Integer&gt; to) &#123; Map&lt;String, Set&lt;String&gt;&gt; channelSession &#x3D; new HashMap&lt;&gt;(4); to.stream().filter(Objects::nonNull).forEach(recevier -&gt; &#123; Set&lt;String&gt; sessionSet &#x3D; redisTemplate.opsForSet().members(PushConstant.REDIS_SERVICE_USERID + recevier); sessionSet.stream().filter(StringUtils::isNotEmpty).forEach(session -&gt; &#123; String channel &#x3D; (String) redisTemplate.opsForHash().get(REDIS_SERVICE_SESSSION + session, &quot;channel&quot;); if (StringUtils.isNotEmpty(channel)) &#123; if (channelSession.containsKey(channel)) &#123; Set&lt;String&gt; pushSessionSet &#x3D; channelSession.get(channel); pushSessionSet.add(session); &#125; else &#123; Set&lt;String&gt; pushSessionSet &#x3D; new HashSet&lt;&gt;(); pushSessionSet.add(session); channelSession.put(channel, pushSessionSet); &#125; &#125; &#125;); &#125;); return channelSession; &#125; 涉及到的Redis中的数据类型为： 我写的单元测试类如下： @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest public class MessageServiceImplTest &#123; @InjectMocks private MessageServiceImpl messageService; @Mock private RedisTemplate redisTemplate; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); &#125; @Test public void testConvertPackageUsageNoData() &#123; Mockito.when(redisTemplate.opsForSet()).thenReturn(Mockito.mock(SetOperations.class)); Mockito.when(redisTemplate.opsForHash()).thenReturn(Mockito.mock(HashOperations.class)); Set&lt;String&gt; set1 &#x3D; new HashSet&lt;&gt;(); set1.add(&quot;4fd23740-4365-46d3-8ce7-f2dc9abd0a2b&quot;); set1.add(&quot;470bec5c-767f-4fde-aea7-4a43449353a4&quot;); Set&lt;String&gt; set2 &#x3D; new HashSet&lt;&gt;(); set2.add(&quot;1cefae25-29bc-4250-890b-a2eb7e36fd11&quot;); set2.add(&quot;a7174444-5327-4f6e-8205-8083c3030747&quot;); Mockito.when(redisTemplate.opsForSet().members(PushConstant.REDIS_SERVICE_USERID + 1)).thenReturn(set1); Mockito.when(redisTemplate.opsForSet().members(PushConstant.REDIS_SERVICE_USERID + 2)).thenReturn(set2); Mockito.when(redisTemplate.opsForHash().get(REDIS_SERVICE_SESSSION + &quot;4fd23740-4365-46d3-8ce7-f2dc9abd0a2b&quot;, &quot;channel&quot;)).thenReturn(&quot;122.168.0.130:30002&quot;); Mockito.when(redisTemplate.opsForHash().get(REDIS_SERVICE_SESSSION + &quot;470bec5c-767f-4fde-aea7-4a43449353a4&quot;, &quot;channel&quot;)).thenReturn(&quot;122.168.0.131:30002&quot;); Mockito.when(redisTemplate.opsForHash().get(REDIS_SERVICE_SESSSION + &quot;1cefae25-29bc-4250-890b-a2eb7e36fd11&quot;, &quot;channel&quot;)).thenReturn(&quot;122.168.0.130:30002&quot;); Mockito.when(redisTemplate.opsForHash().get(REDIS_SERVICE_SESSSION + &quot;a7174444-5327-4f6e-8205-8083c3030747&quot;, &quot;channel&quot;)).thenReturn(&quot;122.168.0.131:30002&quot;); List&lt;Integer&gt; toUser &#x3D; new ArrayList&lt;&gt;(2); toUser.add(1); toUser.add(2); Map&lt;String, Set&lt;String&gt;&gt; map &#x3D; ReflectionTestUtils.invokeMethod(messageService, &quot;getChannelSession&quot;, toUser); Assert.assertNotNull(map); Assert.assertTrue(!map.isEmpty()); Assert.assertEquals(2, map.size()); Assert.assertTrue(map.containsKey(&quot;122.168.0.130:30002&quot;)); Assert.assertTrue(map.containsKey(&quot;122.168.0.131:30002&quot;)); Assert.assertEquals(2, map.get(&quot;122.168.0.130:30002&quot;).size()); Assert.assertEquals(2, map.get(&quot;122.168.0.131:30002&quot;).size()); &#125; &#125; 这时候就存在一个问题，如果我们需要测试的方法很多，我们需要在所有的方法中写入以下代码： ​ Mockito.when(redisTemplate.opsForSet()).thenReturn(Mockito.mock(SetOperations.class));​ Mockito.when(redisTemplate.opsForHash()).thenReturn(Mockito.mock(HashOperations.class)); 而我们正确的方式应该时Mock整个RedisTemplate类 @Component public class RedisTemplateSpy implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (&quot;redisTemplate&quot;.equals(beanName)) &#123; RedisTemplate redisTemplate &#x3D; Mockito.mock(RedisTemplate.class); ValueOperations valueOperations &#x3D; Mockito.mock(ValueOperations.class); SetOperations setOperations &#x3D; Mockito.mock(SetOperations.class); HashOperations hashOperations &#x3D; Mockito.mock(HashOperations.class); ListOperations listOperations &#x3D; Mockito.mock(ListOperations.class); ZSetOperations zSetOperations &#x3D; Mockito.mock(ZSetOperations.class); Mockito.when(redisTemplate.opsForSet()).thenReturn(setOperations); Mockito.when(redisTemplate.opsForValue()).thenReturn(valueOperations); Mockito.when(redisTemplate.opsForHash()).thenReturn(hashOperations); Mockito.when(redisTemplate.opsForList()).thenReturn(listOperations); Mockito.when(redisTemplate.opsForZSet()).thenReturn(zSetOperations); RedisOperations redisOperations &#x3D; Mockito.mock(RedisOperations.class); RedisConnection redisConnection &#x3D; Mockito.mock(RedisConnection.class); RedisConnectionFactory redisConnectionFactory &#x3D; Mockito.mock(RedisConnectionFactory.class); Mockito.when(redisTemplate.getConnectionFactory()).thenReturn(redisConnectionFactory); Mockito.when(valueOperations.getOperations()).thenReturn(redisOperations); Mockito.when(redisTemplate.getConnectionFactory().getConnection()).thenReturn(redisConnection); return redisTemplate; &#125; return bean; &#125; &#125; 我们在需要使用RedisTemplate的地方直接引用即可，因为我们已经在上面的方法中实现了RedisTemplate的Mock。 @Autowired private RedisTemplate redisTemplate; 返回值校验 我们对接口http://localhost:8080/manager/user/55424进行单元测试 @RequestMapping(value &#x3D; &quot;&#x2F;user&#x2F;&#123;userId&#125;&quot;, method &#x3D; &#123; RequestMethod.GET &#125;) public Response&lt;Map&lt;String, List&lt;String&gt;&gt;&gt; getUser(@PathVariable Integer userId) &#123; log.info(&quot;[推送服务GATEWAY] 获取推送服务上单个WS用户 请求参数 [userId &#123;&#125;]&quot;, userId); Map&lt;String, List&lt;String&gt;&gt; sessionInfo &#x3D; managerService.getUserSessions(userId); return Response.ok(sessionInfo); &#125; 返回值为： &#123; &quot;version&quot;: 0, &quot;status&quot;: 0, &quot;errMsg&quot;: &quot;ok&quot;, &quot;errorMsg&quot;: &quot;ok&quot;, &quot;ts&quot;: 1626188639683, &quot;data&quot;: &#123; &quot;55424&quot;: [ &quot;7c921ff9-9a76-4ad8-92e4-02de140b40ad&quot; ] &#125; &#125; 相应的单元测试类为： @WebMvcTest(&#123; ManagerController.class&#125;) public class ManagerControllerTest &#123; private MockMvc mockMvc; @InjectMocks private ManagerController controller; @Mock private ManagerServiceImpl service; @Before public void before() &#123; MockitoAnnotations.initMocks(this); this.mockMvc &#x3D; MockMvcBuilders .standaloneSetup(controller) .build(); &#125; @Test public void insertSupplierBrandStrategyValid() throws Exception &#123; Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); List&lt;String&gt; sessionList &#x3D; new ArrayList&lt;&gt;(2); String session1 &#x3D; UUID.randomUUID().toString(); String session2 &#x3D; UUID.randomUUID().toString(); sessionList.add(session1); sessionList.add(session2); map.put(&quot;1&quot;, sessionList); when(service.getUserSessions(1)).thenReturn(map); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .get(&quot;&#x2F;manager&#x2F;user&#x2F;1&quot;) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON); MvcResult mvcResult &#x3D; mockMvc.perform(requestBuilder) .andDo(print()) &#x2F;&#x2F;打印输出发出请求的详细信息 .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data.length()&quot;).value(1)) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data&quot;, Matchers.hasKey(&quot;1&quot;))) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data&quot;, Matchers.hasEntry(&quot;1&quot;,sessionList ))) .andReturn(); System.out.println(mvcResult.getResponse().getContentAsString()); &#125; &#125;","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"单元测试—参数化测试","slug":"junit2","date":"2021-07-03T14:52:06.000Z","updated":"2021-07-13T15:52:27.093Z","comments":true,"path":"2021/07/03/junit2/","link":"","permalink":"http://www.yipinxieli.com/2021/07/03/junit2/","excerpt":"在写单元测试的时候经常会遇到一种情况，针对某个方法使用多组入参进行测试，这时可以每组入参写一个测试方法，但代码重复率高不优雅，而 junit 从 4.0 开始提供了一种叫做参数化测试的方式专门处理这样情况。","text":"在写单元测试的时候经常会遇到一种情况，针对某个方法使用多组入参进行测试，这时可以每组入参写一个测试方法，但代码重复率高不优雅，而 junit 从 4.0 开始提供了一种叫做参数化测试的方式专门处理这样情况。 单元测试 – 参数化测试普通的参数化测试package com.myz.util; import static org.junit.Assert.*; import java.util.Arrays; import java.util.Collection; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class) public class JunitParameterTest &#123; &#x2F;** * 1.更改默认的运行器为@RunWith(Parameterized.class) * 2.声明变量来存放预期值和结果值 * 3.声明一个返回值为collection的公共静态方法，并使用@Parameters进行修饰 * 4.为测试类声明一个带参数的公共构造函数，并在其中为之声明变量赋值 *&#x2F; int expected&#x3D;0; int input1&#x3D;0; int input2&#x3D;0; @Parameters public static Collection&lt;Object[]&gt; t()&#123;&#x2F;&#x2F;保存参数 return Arrays.asList(new Object[][]&#123; &#123;3,1,2&#125;, &#123;4,2,2&#125; &#125;); &#125; public JunitParameterTest(int expected, int input1, int input2) &#123; this.expected &#x3D; expected; this.input1 &#x3D; input1; this.input2 &#x3D; input2; &#125; @Test public void testAdd()&#123;&#x2F;&#x2F;将参数传入，测试 assertEquals(expected,new Calculate().add(input1, input2)); &#125; &#125; Springboot中的参数化测试 注意 JUnit4 不支持多个 Runner，用了 @RunWith(Parameterized.class) 之后就没法再用 @RunWith(SpringRunner.class)，但是可以通过 @Before 中的 TestContextManager 来实现 SpringRunner 同样的效果 &#x2F;&#x2F; 我们需要测试的方法 @PostMapping(&quot;&#x2F;recall_message&quot;) public Response recallMessage(@RequestBody RecallMessageDTO recallMessageDTO) &#123; log.info(&quot;[聊天室][单条消息撤回]请求参数:[recallMessageDTO&#123;&#125;]&quot;, recallMessageDTO); recallMessageDTO.valid(); sendMessageService.recallMessage(recallMessageDTO); return Response.ok(); &#125; 在RecallMessageDTO中定义了一个valid方法 public void valid() &#123; if (StringUtils.isEmpty(fromUserId)) &#123; throw new BusinessException(&quot;消息发送人ID不能为空&quot;); &#125; if (StringUtils.isEmpty(targetId)) &#123; throw new BusinessException(&quot;消息接收人ID不能为空&quot;); &#125; ... 我们在测试valid()方法的时候，如果每种情况都写一个测试方法的话很不优雅，因为RecallMessageDTO中的valid()方法有很多的属性需要检验。这个时候我们就可以使用参数化测试了。 @RunWith(Parameterized.class) @SpringBootTest(classes &#x3D; Application .class) public class TimlineServiceTest &#123; @InjectMocks private SendMessageService sendMessageService; private TestContextManager testContextManager; private RecallMessageDTO recallMessageDTO; private String message; @Rule public ExpectedException thrown&#x3D; ExpectedException.none(); private ObjectMapper objectMapper; @InjectMocks private MessageController controller; private MockMvc mockMvc; &#x2F;&#x2F;参数数组，数组中每个元素将会被用来构造一个入参实例，每个入参实例对应一个测试用例， @Parameterized.Parameters public static Collection&lt;Object[]&gt; data() &#123; Object[][] objects &#x3D; &#123; &#123;&quot;&quot;, &quot;&quot;, &quot;消息发送人ID不能为空&quot;&#125;, &#123;&quot;fb_1904&quot;, &quot;&quot;, &quot;消息接收人ID不能为空&quot;&#125; &#125;; return Arrays.asList(objects); &#125; &#x2F;&#x2F;构造函数，使用上面的参数数组初始化入参 public TimlineServiceTest(String fromUserId, String targetId, String message) &#123; recallMessageDTO &#x3D; new RecallMessageDTO(); recallMessageDTO.setFromUserId(fromUserId); recallMessageDTO.setTargetId(targetId); this.message &#x3D; message; &#125; &#x2F;&#x2F;功能相当于 @RunWith(SpringRunner.class) ，否则无法注入bean，这里同时还可以给入参初始化一些固定值 @Before public void setUp() throws Exception &#123; &#x2F;&#x2F; equals to @RunWith(SpringRunner.class) in case that JUnit4 doesn’t accept multiple runners this.testContextManager &#x3D; new TestContextManager(getClass()); &#x2F;&#x2F;this.testContextManager.prepareTestInstance(this); MockitoAnnotations.initMocks(this); objectMapper &#x3D; new ObjectMapper(); objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE); MappingJackson2HttpMessageConverter convert &#x3D; new MappingJackson2HttpMessageConverter(objectMapper); this.mockMvc &#x3D; MockMvcBuilders .standaloneSetup(controller) &#x2F;&#x2F;.setControllerAdvice(new GlobalExceptionResolver()) .setMessageConverters(convert) .build(); &#125; &#x2F;&#x2F;单元测试方法体 @Test public void tst() throws Exception &#123; thrown.expect(NestedServletException.class); thrown.expectMessage(message); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .post(&quot;&#x2F;v1&#x2F;recall_message&quot;) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(recallMessageDTO)); MvcResult mvcResult &#x3D; mockMvc.perform(requestBuilder) .andDo(print()) &#x2F;&#x2F;打印输出发出请求的详细信息 .andExpect(status().isOk()) .andReturn(); &#125; &#125;","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"单元测试—模拟方法异常执行","slug":"junit1","date":"2021-07-03T14:51:58.000Z","updated":"2021-07-03T15:19:13.349Z","comments":true,"path":"2021/07/03/junit1/","link":"","permalink":"http://www.yipinxieli.com/2021/07/03/junit1/","excerpt":"面向领导编程，公司开始使用SonarQube做代码检查了。又逼着自己学习新技能。","text":"面向领导编程，公司开始使用SonarQube做代码检查了。又逼着自己学习新技能。 单元测试 -- 模拟方法异常执行 使用@Test及其属性expected 只能校验异常类型，没法校验异常信息 @Test(expected &#x3D; NestedServletException.class) public void recallMessageError1() throws Exception &#123; RecallMessageDTO recallMessageDTO &#x3D; new RecallMessageDTO(); recallMessageDTO.setFromUserId(&quot;&quot;); recallMessageDTO.setTargetId(&quot;1131762050372997120&quot;); recallMessageDTO.setConversationType(ConversationTypeEnum.CONVERSATION_TYPE_1.getType()); recallMessageDTO.setSentTime(&quot;1624368676049&quot;); recallMessageDTO.setMessageUID(&quot;BQ6F-LFPK-87A7-G4SG&quot;); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .post(&quot;&#x2F;v1&#x2F;recall_message&quot;) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(recallMessageDTO)); MvcResult result &#x3D; mockMvc.perform(requestBuilder) &#x2F;&#x2F;执行请求 .andExpect(status().isInternalServerError()) &#x2F;&#x2F;验证服务器内部错误 .andReturn(); &#125; 使用try-catch 可以在一个方法里使用try catch校验各种异常类型 @Test public void recallMessageError2() throws Exception &#123; RecallMessageDTO recallMessageDTO &#x3D; new RecallMessageDTO(); recallMessageDTO.setFromUserId(&quot;&quot;); recallMessageDTO.setTargetId(&quot;1131762050372997120&quot;); recallMessageDTO.setConversationType(ConversationTypeEnum.CONVERSATION_TYPE_1.getType()); recallMessageDTO.setSentTime(&quot;1624368676049&quot;); recallMessageDTO.setMessageUID(&quot;BQ6F-LFPK-87A7-G4SG&quot;); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .post(&quot;&#x2F;v1&#x2F;recall_message&quot;) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(recallMessageDTO)); try&#123; &#x2F;&#x2F;异常处理 MvcResult result &#x3D; mockMvc.perform(requestBuilder) &#x2F;&#x2F;执行请求 .andExpect(status().isInternalServerError()) &#x2F;&#x2F;验证服务器内部错误 .andReturn(); &#125;catch (NestedServletException e) &#123; Assert.assertEquals(&quot;消息发送人ID不能为空&quot;, e.getCause().getMessage()); &#125; &#125; 使用@Rule和ExpectedException ExpectedException从4.7之后才有的，可以让你优雅的测试异常类型和异常信息 @Rule public ExpectedException thrown &#x3D; ExpectedException.none(); @Test public void recallMessageError() throws Exception &#123; &#x2F;&#x2F; 不填写发件人 RecallMessageDTO recallMessageDTO &#x3D; new RecallMessageDTO(); recallMessageDTO.setFromUserId(&quot;&quot;); recallMessageDTO.setTargetId(&quot;1131762050372997120&quot;); recallMessageDTO.setConversationType(ConversationTypeEnum.CONVERSATION_TYPE_1.getType()); recallMessageDTO.setSentTime(&quot;1624368676049&quot;); recallMessageDTO.setMessageUID(&quot;BQ6F-LFPK-87A7-G4SG&quot;); thrown.expect(NestedServletException.class); thrown.expectMessage(&quot;消息发送人ID不能为空&quot;); MockHttpServletRequestBuilder requestBuilder &#x3D; MockMvcRequestBuilders .post(&quot;&#x2F;v1&#x2F;recall_message&quot;) .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(recallMessageDTO)); MvcResult mvcResult &#x3D; mockMvc.perform(requestBuilder) .andDo(print()) &#x2F;&#x2F;打印输出发出请求的详细信息 .andExpect(status().isOk()) .andReturn(); &#125;","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"}]},{"title":"Git(6) -- diff文件差异","slug":"git5","date":"2021-07-01T16:01:27.000Z","updated":"2021-07-10T16:34:16.318Z","comments":true,"path":"2021/07/02/git5/","link":"","permalink":"http://www.yipinxieli.com/2021/07/02/git5/","excerpt":"git diff 命令用来显示已写入暂存区和已经被修改但尚未写入暂存区文件对区别。","text":"git diff 命令用来显示已写入暂存区和已经被修改但尚未写入暂存区文件对区别。 Git(6) -- diff文件差异 尚未缓存的改动 dit diff [file] 我们修改一个文件，不使用git add提交修改。 On branch dev Your branch is ahead of &#39;origin&#x2F;dev&#39; by 1 commit. (use &quot;git push&quot; to publish your local commits) Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .idea&#x2F; no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 此时我们使用git diff命令查看。 diff --git a&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java b&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java index 1ed1709..3d4e933 100644 --- a&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java +++ b&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java @@ -13,7 +13,7 @@ import java.sql.SQLException; &#x2F;** * @Author Wangql - * @Description 3 + * @Description 4 : 查看已缓存的改动： git diff –cached [file] 接上文，此时我们使用git diff --cached查看变更情况却发现没有任何改变。 D:\\IdeaProjects\\Springboot2&gt;git diff --cached D:\\IdeaProjects\\Springboot2&gt; 因为git diff –cached比较的是暂存区和上一次提交(commit)的差异。 我们使用git add将修改的文件加入到暂存区，然后再执行git diff --cached命令。 D:\\IdeaProjects\\Springboot2&gt;git status On branch dev Your branch is ahead of &#39;origin&#x2F;dev&#39; by 1 commit. (use &quot;git push&quot; to publish your local commits) Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java D:\\IdeaProjects\\Springboot2&gt;git diff --cached diff --git a&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java b&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java index 1ed1709..3d4e933 100644 --- a&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java +++ b&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java @@ -13,7 +13,7 @@ import java.sql.SQLException; &#x2F;** * @Author Wangql - * @Description 3 + * @Description 4 : 查看已缓存的与未缓存的所有改动：git diff HEAD 比较的是工作区中的文件与版本库中文件的差异。HEAD指向的是版本库中的当前版本，而file指的是当前工作区中的文件 查看简单的diff结果，可以加上–stat参数 D:\\IdeaProjects\\Springboot2&gt;git diff HEAD --stat ...&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 比较两个历史版本之间的差异git diff SHA1 SHA2 D:\\IdeaProjects\\Springboot2&gt;git diff 0a8bc8533b8be096431db85a45c24f4ffbc039be c92acaabf353d89bc19b74de2bab3e0bfc98e629 diff --git a&#x2F;phj-boot-common&#x2F;.gitignore b&#x2F;phj-boot-common&#x2F;.gitignore new file mode 100644 index 0000000..93ad232 --- &#x2F;dev&#x2F;null +++ b&#x2F;phj-boot-common&#x2F;.gitignore @@ -0,0 +1,93 @@ +&#x2F;target&#x2F; +!.mvn&#x2F;wrapper&#x2F;maven-wrapper.jar + +### STS ### D:\\IdeaProjects\\Springboot2&gt;git diff 0a8bc8533b8be096431db85a45c24f4ffbc039be 82df2f1053e01d4d094c267ced093c34c3d681b1 diff --git a&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java b&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java index 1ed1709..83cfa25 100644 --- a&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java +++ b&#x2F;phj-service-account&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;puhuijia&#x2F;config&#x2F;DruidDBConfig.java @@ -13,7 +13,7 @@ import java.sql.SQLException; &#x2F;** * @Author Wangql - * @Description 3 + * @Description 1 :","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"Git(5) -- commit提交管理","slug":"git4","date":"2021-06-29T15:02:18.000Z","updated":"2021-07-10T16:34:02.407Z","comments":true,"path":"2021/06/29/git4/","link":"","permalink":"http://www.yipinxieli.com/2021/06/29/git4/","excerpt":"Git 提交信息修改： 未push到远程仓库的代码使用以下方法。对于已经将代码push到远程仓库的情况，需要在最后多执行一条强制push到远程仓库：git push --force origin 分支名的命令。","text":"Git 提交信息修改： 未push到远程仓库的代码使用以下方法。对于已经将代码push到远程仓库的情况，需要在最后多执行一条强制push到远程仓库：git push --force origin 分支名的命令。 Git(5) -- commit提交修改 修改最新commit的message 本次操作在IntelliJ IDEA的Terminal命令窗口中完成 使用命令git commit –amend允许您打开编辑器，修改您更改最后一次提交消息。 &#x2F;&#x2F; 查看最近一次的提交记录 D:\\IdeaProjects\\spring-boot-study&gt;git log -n1 commit b73d13300ee6af0b84cb8ee6349a85b6bebf5255 (HEAD -&gt; master) Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 01:26:48 2021 +0800 feat:默认分页起始页从1开始 修改最近的一次 commit message D:\\IdeaProjects\\spring-boot-study&gt;git commit --amend 输入git commit –amend后 按回车进入到 vim编辑器（熟悉LInux的同学已经知道如何编辑退出了） &quot;D:&#x2F;IdeaProjects&#x2F;spring-boot-study&#x2F;.git&#x2F;COMMIT_EDITMSG&quot; [unix] 15L, 535B written feat:默认分页起始页从1开始 修改最近的一次 commit message # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Date: Mon Jun 28 01:26:48 2021 +0800 # # On branch master # Your branch and &#39;origin&#x2F;master&#39; have diverged, # and have 1 and 1 different commits each, respectively. # (use &quot;git pull&quot; to merge the remote branch into yours) # # Changes to be committed: # modified: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java 输入 **i ** 文档变成可编辑状态。在可编辑状态下便可以修改提交状态 **:wq ** 保存并退出 -- INSERT -- IntelliJ IDEA的Terminal命令在操作时发现了一些不方便的地方，导致自己以为命令输入有误 按Esc键之后光标定位到代码编辑器了，导致 :wq 输入到.java文件中了 保存退出后Terminal命令窗口的显示如下图，第一眼以为没退出呢。敲了好几个回车才反应过来，输入 **cls ** 清屏。不要怀疑，一切都是假象。 注意修改注释的时候可能使用的是中文输入法，在输入 :wq 的时候一定要切换到英文 修改老旧commit的message 使用命令git rebase –i commitID允许修改老旧commit的提交消息。 查看最近3次的代码提交 D:\\IdeaProjects\\spring-boot-study&gt;git log -3 commit 70e32372f96345f1447da020c95f5b1d8e40eaf3 (HEAD -&gt; master) Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 01:26:48 2021 +0800 feat:默认分页起始页从1开始 修改最近的一次 commit message commit 0380f63f9c1d4df1309f53fad1728d1e763643f2 Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 feat:集成Redis commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wang@rr.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java 我们选择修改倒数第二次的提交信息作变更，但是我们要选的基base应该为它的上一个commitID：fe056300b80f84a2caf9d92662d94e8e3fe218f1 我们执行命令git rebase –i fe056300b80f84a2caf9d92662d94e8e3fe218f1 pick 8f6f3e2 feat:集成Redis 实现修改历史commit message pick f1b7a7f feat:默认分页起始页从1开始 # Rebase fe05630..f1b7a7f onto fe05630 (2 commands) # # Commands: # p, pick &lt;commit&gt; &#x3D; use commit # r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message # e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending # s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit # f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message # x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell # b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;) # d, drop &lt;commit&gt; &#x3D; remove commit # l, label &lt;label&gt; &#x3D; label current HEAD with a name # t, reset &lt;label&gt; &#x3D; reset HEAD to a label # m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;] # . create a merge commit using the original merge commit&#39;s # . message (or the oneline, if no original merge commit was # . specified). Use -c &lt;commit&gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # D:&#x2F;IdeaProjects&#x2F;spring-boot-study&#x2F;.git&#x2F;rebase-merge&#x2F;git-rebase-todo [unix] (00:52 30&#x2F;06&#x2F;2021) 1,1 Top -- INSERT -- 我们将pick 8f6f3e2 feat:集成Redis 实现修改历史commit message中的pick修改为r。**:wq**保存退出。注释# r, reword &lt;commit&gt; = use commit, but edit the commit message即只修改commit message。 feat:集成Redis 实现修改历史commit message # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Date: Mon Jun 28 00:35:09 2021 +0800 # # interactive rebase in progress; onto fe05630 # Last command done (1 command done): # reword 8f6f3e2 feat:集成Redis 实现修改历史commit message # Next command to do (1 remaining command): # pick f1b7a7f feat:默认分页起始页从1开始 # You are currently editing a commit while rebasing branch &#39;master&#39; on &#39;fe05630&#39;. # # Changes to be committed: # new file: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;aspect&#x2F;RequestParameterAop.java # modified: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;config&#x2F;RedisConfig.java # modified: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;RedisConstant.java # modified: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;listener&#x2F;RedisReceiver.java # modified: src&#x2F;test&#x2F;java&#x2F;Test_1.java # ~ D:&#x2F;IdeaProjects&#x2F;spring-boot-study&#x2F;.git&#x2F;COMMIT_EDITMSG [unix] (00:58 30&#x2F;06&#x2F;2021) 1,1 All -- INSERT -- 以上提示为Please enter the commit message for your changes。我们将feat:集成Redis 实现修改历史commit message修改为feat:集成Redis。**:wq**保存退出。 再次使用git log -3查看commit提交信息，发现除了第二次的commit message改变，相应的commitID也发生了改变。 D:\\IdeaProjects\\spring-boot-study&gt;git log -3 commit b995b18c781edde9df53df82d8312644c25b6f7d (HEAD -&gt; master) Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 01:26:48 2021 +0800 feat:默认分页起始页从1开始 commit e2d0ac8803245313e46389a72dc620a9cbd7eced Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 feat:集成Redis commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wang@rr.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java 连续多个commit整理成1个 使用命令git rebase –i commitID允许将连续多个commit整理成1个commit。 查看最近3次的代码提交 D:\\IdeaProjects\\spring-boot-study&gt;git log -3 commit b995b18c781edde9df53df82d8312644c25b6f7d (HEAD -&gt; master) Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 01:26:48 2021 +0800 feat:默认分页起始页从1开始 commit e2d0ac8803245313e46389a72dc620a9cbd7eced Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 feat:集成Redis commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wang@rr.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java D:\\IdeaProjects\\spring-boot-study&gt;git rebase -i fe056300b80f84a2caf9d92662d94e8e3fe218f1 我们选择将前两个的提交信息进行合并，但是我们要选的基base应该为它的上一个commitID：fe056300b80f84a2caf9d92662d94e8e3fe218f1 我们执行命令git rebase –i fe056300b80f84a2caf9d92662d94e8e3fe218f1 pick e2d0ac8 feat:集成Redis pick b995b18 feat:默认分页起始页从1开始 # Rebase fe05630..b995b18 onto fe05630 (2 commands) # # Commands: # p, pick &lt;commit&gt; &#x3D; use commit # r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message # e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending # s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit # f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message # x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell # b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;) # d, drop &lt;commit&gt; &#x3D; remove commit # l, label &lt;label&gt; &#x3D; label current HEAD with a name # t, reset &lt;label&gt; &#x3D; reset HEAD to a label # m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;] # . create a merge commit using the original merge commit&#39;s # . message (or the oneline, if no original merge commit was # . specified). Use -c &lt;commit&gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # D:&#x2F;IdeaProjects&#x2F;spring-boot-study&#x2F;.git&#x2F;rebase-merge&#x2F;git-rebase-todo [unix] (22:33 30&#x2F;06&#x2F;2021) 1,1 All -- INSERT -- 我们将pick b995b18 feat:默认分页起始页从1开始中的pick修改为s。**:wq**保存退出。注释# s, squash &lt;commit&gt; = use commit, but meld into previous commit。 pick 表示使用本次提交squash,表示将本次提交合并到上一次pick的提交 pick e2d0ac8 feat:集成Redis s b995b18 feat:默认分页起始页从1开始 :wq! [detached HEAD 0dd5958] 合并两次请求 Date: Mon Jun 28 00:35:09 2021 +0800 6 files changed, 145 insertions(+), 7 deletions(-) create mode 100644 src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;aspect&#x2F;RequestParameterAop.java Successfully rebased and updated refs&#x2F;heads&#x2F;master. 再次使用git log -3查看commit提交信息，发现已经合并。 D:\\IdeaProjects\\spring-boot-study&gt;git log -3 commit 0dd595879b8c093992250b6845c1df8fdc8a4f2e (HEAD -&gt; master) Author: 王清雷 &lt;wang@rr.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 合并两次请求 feat:集成Redis feat:默认分页起始页从1开始 commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wang@rr.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java commit a42c966e039d7db874673a55f3dad62c07b3f216 Author: 王清雷 &lt;wang@rr.com&gt; Date: Sun Jun 20 01:36:27 2021 +0800 feat:Redis发布订阅学习","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"Git(4) -- branch分支管理","slug":"git3","date":"2021-06-28T16:28:08.000Z","updated":"2021-07-11T16:08:05.485Z","comments":true,"path":"2021/06/29/git3/","link":"","permalink":"http://www.yipinxieli.com/2021/06/29/git3/","excerpt":"每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。","text":"每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 Git(4) – branch分支管理列出所有分支git branch 没有参数时，git branch 会列出你在本地的分支。 加上-a参数可以查看全部分支(包含本地分支和远程分支)，远程分支会用红色表示出来（如果你开了颜色支持的话） 加上-r参数可以查看远程分支 其中带*号标注的是当前所在的分支 D:\\che\\im-api&gt;git branch 20210421_add_get_user_reward 20210520_manage_chatroom_entry_wangql 20210604_user_reward_chatroom_entry * 20210622_feat_message_recall_wangql 20210622_fix_extra_content_decode_wangql develop master D:\\che\\im-api&gt;git branch -a 20210421_add_get_user_reward 20210520_manage_chatroom_entry_wangql 20210604_user_reward_chatroom_entry * 20210622_feat_message_recall_wangql 20210622_fix_extra_content_decode_wangql develop master remotes&#x2F;origin&#x2F;20210324_init_develop_env remotes&#x2F;origin&#x2F;20210421_add_get_user_reward remotes&#x2F;origin&#x2F;20210520_manage_chatroom_entry_wangql remotes&#x2F;origin&#x2F;20210604_user_reward_chatroom_entry remotes&#x2F;origin&#x2F;20210622_feat_message_recall_wangql remotes&#x2F;origin&#x2F;20210622_fix_extra_content_decode_wangql remotes&#x2F;origin&#x2F;HEAD -&gt; origin&#x2F;develop remotes&#x2F;origin&#x2F;develop remotes&#x2F;origin&#x2F;master D:\\renrenche\\im-api&gt;git branch -r origin&#x2F;20210324_init_develop_env origin&#x2F;20210421_add_get_user_reward origin&#x2F;20210520_manage_chatroom_entry_wangql origin&#x2F;20210604_user_reward_chatroom_entry origin&#x2F;20210622_feat_message_recall_wangql origin&#x2F;20210622_fix_extra_content_decode_wangql origin&#x2F;HEAD -&gt; origin&#x2F;develop origin&#x2F;develop origin&#x2F;master 切换分支git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容。 根据指定版本号创建分支: git checkout -b branchName commitId D:\\renrenche\\im-api&gt;git checkout 20210324_init_develop_env Switched to a new branch &#39;20210324_init_develop_env&#39; Branch &#39;20210324_init_develop_env&#39; set up to track remote branch &#39;20210324_init_develop_env&#39; from &#39;origin&#39;. D:\\renrenche\\im-api&gt;git branch * 20210324_init_develop_env 20210421_add_get_user_reward 20210520_manage_chatroom_entry_wangql 20210604_user_reward_chatroom_entry 20210622_feat_message_recall_wangql 20210622_fix_extra_content_decode_wangql develop master 删除分支git branch -d (branchname)用来删除本地分支 git push origin --delete [branchname]用来删除远端分支，在删除远程分支时，同名的本地分支并不会被删除，所以还需要单独删除本地同名分支 清理本地无效分支(远程已删除本地没删除的分支): git fetch -p D:\\IdeaProjects\\spring-boot-study&gt;git branch master * test test_new D:\\IdeaProjects\\spring-boot-study&gt;git branch -d test_new Deleted branch test_new (was 4914823). D:\\IdeaProjects\\spring-boot-study&gt;git push origin -d test_new remote: Powered by GITEE.COM [GNK-5.0] To https:&#x2F;&#x2F;gitee.com&#x2F;ShanXiXiaoMoTou&#x2F;spring-boot-study.git - [deleted] test_new 常见错误：error: Cannot delete branch ‘XXX’ checked out at ‘XXXXXX’ 在删除分支时，当前分支为在要删除的分支上，则会报以上错误。解决办法就是切换到其他任意分支，再去删除目标分支。 D:\\IdeaProjects\\spring-boot-study&gt;git branch master * test_new D:\\IdeaProjects\\spring-boot-study&gt;git branch -d test_new error: Cannot delete branch &#39;test_new&#39; checked out at &#39;D:&#x2F;IdeaProjects&#x2F;spring-boot-study&#39;","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"redis -- 发布订阅","slug":"redis","date":"2021-06-24T16:37:15.000Z","updated":"2021-07-07T16:43:14.354Z","comments":true,"path":"2021/06/25/redis/","link":"","permalink":"http://www.yipinxieli.com/2021/06/25/redis/","excerpt":"最近在工作中做一个实时推送的需求（消息不需要持久化，允许少量丢失），便使用了Redis的发布订阅模式来开发。顺带温习了一下Redis的相关操作。","text":"最近在工作中做一个实时推送的需求（消息不需要持久化，允许少量丢失），便使用了Redis的发布订阅模式来开发。顺带温习了一下Redis的相关操作。 redis – 发布订阅RedisConfig配置@Slf4j @Configuration public class RedisConfig &#123; @Bean(name &#x3D; &quot;redisTemplate&quot;) public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; &#x2F;&#x2F;序列化配置 Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper objectMapper &#x3D; new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); StringRedisSerializer stringRedisSerializer &#x3D; new StringRedisSerializer(); RedisTemplate&lt;String,Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); log.info(&quot;[推送服务WS]自定义RedisTemplate加载完成&quot;); return redisTemplate; &#125; @Bean RedisMessageListenerContainer container(RedisConnectionFactory redisConnectionFactory, MessageListenerAdapter listenerAdapter) &#123; RedisMessageListenerContainer container &#x3D; new RedisMessageListenerContainer(); container.setConnectionFactory(redisConnectionFactory); &#x2F;&#x2F; 以下为修改默认的序列化方式，网上大多数消息发布订阅都是String类型,但是实际中数据类型肯定不止String类型 Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper objectMapper &#x3D; new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); &#x2F;&#x2F; 收藏主题并绑定消息订阅处理器 listenerAdapter.setSerializer(jackson2JsonRedisSerializer); container.addMessageListener(listenerAdapter, new ChannelTopic(PushConfig.PUSH_WS_CHANNEL)); return container; &#125; @Bean MessageListenerAdapter commentListenerAdapter(ChannelReceiverService receiver) &#123; return new MessageListenerAdapter(receiver); &#125; &#125; ChannelReceiverService消息接收类@Slf4j @Service public class ChannelReceiverService implements MessageListener &#123; @Override public void onMessage(org.springframework.data.redis.connection.Message message, byte[] bytes) &#123; String messageBody &#x3D; new String(message.getBody()); String channel &#x3D; new String(message.getChannel()); log.info(&quot;[推送服务WS][消息订阅] Redis Channel 接收到的消息为:[message &#123;&#125; channel &#123;&#125;]&quot;, messageBody, channel); &#x2F;&#x2F; 通过JSON.parseObject将messageBody反序列化为Message对象 Message channelMsg &#x3D; JSON.parseObject((String) JSON.parse(messageBody), new TypeReference&lt;Message&gt;() &#123;&#125;); &#125; &#125; 消息发送redisTemplate.convertAndSend(entry.getKey(), JSON.toJSONString(message)); Redis发布订阅频道信息获取Redis原生命令获取发布订阅频道信息为：pubsub channels [pattern]。但是我在开发的时候使用的客户端是redisTemplate。不支持上述命令。最后使用曲线救国的方式。因为我连接池使用的是jedis，而jedis支持该命令，所以写了个工具类进行转换。 public class RedisChannelUtil &#123; private RedisChannelUtil() &#123; &#125; &#x2F;** * @Author Wangql * @Description 获取Redis中的发布订阅频道名称 redisTemplate不支持此命令 使用底层jedis来执行 * @Date 18:47 2021&#x2F;7&#x2F;1 * @Param [redisTemplate] * @return java.util.List&lt;java.lang.String&gt; **&#x2F; public static List&lt;String&gt; getPushRedisChannels(RedisTemplate redisTemplate) &#123; RedisConnectionFactory connection &#x3D; redisTemplate.getConnectionFactory(); Jedis jedis &#x3D; null; try &#123; jedis &#x3D; (Jedis) connection.getConnection().getNativeConnection(); &#x2F;&#x2F; 使用的带前缀的模糊匹配 return jedis.pubsubChannels(PushConstant.REDIS_SERVICE_CHANNEL + &quot;*&quot;); &#125; finally &#123; if (jedis !&#x3D; null) &#123; jedis.close(); &#125; &#125; &#125; &#125; 注意点： org.springframework.data.redis.listener.ChannelTopic：一个确定的字符串org.springframework.data.redis.listener.PatternTopic：基于模式匹配 在使用ChannelTopic时可以使用pubsub channels [pattern]获取到对应的频道，但是在使用PatternTopic时使用pubsub channels [pattern]就存在获取不到相应频道的情况。使用时一定要注意！！！ 获取Redis服务端信息命令redis:0&gt;info server &quot;# Server redis_version:5.0.10 &#x2F;&#x2F;版本号 redis_git_sha1:1c047b68 redis_git_dirty:0 redis_build_id:76de97c74f6945e9 redis_mode:standalone os:Windows arch_bits:64 multiplexing_api:WinSock_IOCP atomicvar_api:pthread-mutex process_id:5496 run_id:8365b19fdb796f8dc521652e8149a0d5a4f0eab7 tcp_port:6888 uptime_in_seconds:111990 uptime_in_days:1 hz:10 configured_hz:10 lru_clock:14721105 executable:D:\\Program Files\\Redis\\&quot;d:\\program files\\redis\\redis-server.exe&quot; config_file:D:\\Program Files\\Redis\\redis.windows-service.conf &quot;","categories":[{"name":"缓存中间件","slug":"缓存中间件","permalink":"http://www.yipinxieli.com/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.yipinxieli.com/tags/redis/"}]},{"title":"Git(3) -- 查看提交历史","slug":"git2","date":"2021-06-15T16:28:08.000Z","updated":"2021-06-28T02:44:30.585Z","comments":true,"path":"2021/06/16/git2/","link":"","permalink":"http://www.yipinxieli.com/2021/06/16/git2/","excerpt":"Git 提交历史一般常用两个命令： git log - 查看历史提交记录。 git blame - 以列表形式查看指定文件的历史修改记录。","text":"Git 提交历史一般常用两个命令： git log - 查看历史提交记录。 git blame - 以列表形式查看指定文件的历史修改记录。 Git(3) -- 查看提交历史 git log在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。 git log 默认查看当前分支的提交历史 通过以下可以看到当前为master分支 通过：处上下键可以查看更早的提交历史。 在：处输入q退出历史版本查看 wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git log commit 0380f63f9c1d4df1309f53fad1728d1e763643f2 (HEAD -&gt; master, origin&#x2F;master) Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 feat:集成Redis commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java commit a42c966e039d7db874673a55f3dad62c07b3f216 Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Sun Jun 20 01:36:27 2021 +0800 feat:Redis发布订阅学习 commit aa2a13e24a001e25b84921adaa02914837459053 : 我们可以通过–oneline 选项来查看历史记录的简洁的版本。 wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git log --oneline 0380f63 (HEAD -&gt; master, origin&#x2F;master) feat:集成Redis fe05630 Merge remote-tracking branch &#39;origin&#x2F;master&#39; a42c966 feat:Redis发布订阅学习 aa2a13e feat:commit提交回滚 : 我们可以通过–n[number] 选项来查看最近的几个历史记录版本。 查看最近的两条提交记录 git log -n2 git log -n2 –oneline wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git log -n2 commit 0380f63f9c1d4df1309f53fad1728d1e763643f2 (HEAD -&gt; master, origin&#x2F;master) Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 feat:集成Redis commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git log -n2 --oneline 0380f63 (HEAD -&gt; master, origin&#x2F;master) feat:集成Redis fe05630 Merge remote-tracking branch &#39;origin&#x2F;master&#39; 我们可以通过–all 选项查看所有分支的版本演进历史 wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (2528c1e) $ git log --all commit 943411f8b99e8ab60bf39f03b2e513bf40e66337 (HEAD -&gt; 2528c1e, origin&#x2F;2528c1e) Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Mon Jun 28 01:02:51 2021 +0800 feat:默认分页常量增加 commit 0380f63f9c1d4df1309f53fad1728d1e763643f2 (origin&#x2F;master, master) Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Mon Jun 28 00:35:09 2021 +0800 feat:集成Redis commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; # Conflicts: # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java : 我们可以通过–graph 选项以图形化的形式来查看版本演进历史 wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (2528c1e) $ git log --all --graph * commit 943411f8b99e8ab60bf39f03b2e513bf40e66337 (HEAD -&gt; 2528c1e, origin&#x2F;2528c1e) | Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; | Date: Mon Jun 28 01:02:51 2021 +0800 | | feat:默认分页常量增加 | * commit 0380f63f9c1d4df1309f53fad1728d1e763643f2 (origin&#x2F;master, master) | Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; | Date: Mon Jun 28 00:35:09 2021 +0800 | | feat:集成Redis | * commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 |\\ Merge: a42c966 83f0da7 | | Author: 王清雷 &lt;wangqinglei01@renrenche.com&gt; | | Date: Sun Jun 20 01:37:37 2021 +0800 | | | | Merge remote-tracking branch &#39;origin&#x2F;master&#39; | | | | # Conflicts: | | # src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java | | : 以后补IDEA相关操作 git blamegit blame 命令是以列表形式显示修改记录，如下实例： D:\\IdeaProjects\\spring-boot-study&gt;git blame src\\main\\java\\com\\rrc\\controller\\school\\SchoolController.java ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 1) package com.rrc.controller.school; ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 2) 91fbfe36 (王清雷 2021-06-06 16:19:40 +0800 3) import com.baomidou.mybatisplus.extension.plugins.pagination.Page; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 4) import com.rrc.dto.base.ResultDto; 6c77b894 (qinglei1989 2021-05-25 13:53:52 +0800 5) import com.rrc.service.ISchoolService; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 6) import com.rrc.util.AppUtil; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 7) import com.rrc.vo.SchoolVo; ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 8) import lombok.extern.slf4j.Slf4j; 6c77b894 (qinglei1989 2021-05-25 13:53:52 +0800 9) import org.springframework.beans.factory.annotation.Autowired; 2f195422 (王清雷 2021-06-06 22:38:21 +0800 10) import org.springframework.validation.annotation.Validated; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 11) import org.springframework.web.bind.annotation.*; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 12) d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 13) import javax.validation.Valid; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 14) import javax.validation.constraints.NotBlank; ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 15) ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 16) @RestController d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 17) @RequestMapping(&quot;v1&quot;) ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 18) @Slf4j ^d504062 (qinglei1989 2021-05-23 11:24:30 +0800 19) public class SchoolController &#123; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 20) 6c77b894 (qinglei1989 2021-05-25 13:53:52 +0800 21) @Autowired 6c77b894 (qinglei1989 2021-05-25 13:53:52 +0800 22) private ISchoolService schoolService; 6c77b894 (qinglei1989 2021-05-25 13:53:52 +0800 23) d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 24) @GetMapping(&quot;&#x2F;school&#x2F;&#123;schoolId&#125;&quot;) a5ee4be0 (qinglei1989 2021-05-26 19:45:31 +0800 25) public ResultDto querySchool(@NotBlank(message &#x3D; &quot;schoolId不能为空&quot;) @PathVariable(&quot;schoolId&quot;) Long schoolId) &#123; d684dcf9 (qinglei1989 2021-05-24 14:05:50 +0800 26) :","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"Git(2) -- git操作技巧","slug":"git1","date":"2021-06-15T16:10:41.000Z","updated":"2021-07-11T17:06:01.471Z","comments":true,"path":"2021/06/16/git1/","link":"","permalink":"http://www.yipinxieli.com/2021/06/16/git1/","excerpt":"分享git常用操作技巧。","text":"分享git常用操作技巧。 Git(2) -- 操作技巧 1、文件重命名 &#x2F;&#x2F; 演示将CommonConst.java 重命名为 CommonConstant.java wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ cd src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F; wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant (master) $ git mv CommonConst.java CommonConstant.java wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant (master) $ git status On branch master Your branch and &#39;origin&#x2F;master&#39; have diverged, and have 1 and 1 different commits each, respectively. (use &quot;git pull&quot; to merge the remote branch into yours) Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) renamed: CommonConst.java -&gt; CommonConstant.java 2、git reset –hard HEAD^后显示more D:\\IdeaProjects\\spring-boot-study&gt;git reset --HEAD^ More? More? error: unknown option &#96;HEAD 我们可以选择直接打开一个cmd窗口，在里边输入一个^,发现也弹出了More。通过下边的dir命令大概大家已经发现了^符号的含义—用来连接两端命令的。每当^符号出现的时候，系统会认为后面还会有命令，所以会提示两次more? 来询问用户输入下一步的命令。另外，在cmd环境中^也以转义字符的身份出现。^符号也会用在一些特定字符前面用来输出，例如您想让命令输出&gt;号，输出的命令必须为Echo ^&gt; C:\\Users\\wang\\Pictures&gt;^ More? More? C:\\Users\\wang\\Pictures&gt;di^ More? r 驱动器 C 中的卷是 Windows 卷的序列号是 0265-6A69 C:\\Users\\wang\\Pictures 的目录 2021&#x2F;04&#x2F;17 10:13 &lt;DIR&gt; . 2021&#x2F;04&#x2F;17 10:13 &lt;DIR&gt; .. 2020&#x2F;06&#x2F;21 18:46 &lt;DIR&gt; Camera Roll 2021&#x2F;01&#x2F;14 16:18 &lt;DIR&gt; Feedback 2020&#x2F;06&#x2F;21 18:46 &lt;DIR&gt; Saved Pictures 0 个文件 0 字节 5 个目录 21,613,289,472 可用字节 C:\\Users\\wang\\Pictures&gt;dir 驱动器 C 中的卷是 Windows 卷的序列号是 0265-6A69 C:\\Users\\wang\\Pictures 的目录 2021&#x2F;04&#x2F;17 10:13 &lt;DIR&gt; . 2021&#x2F;04&#x2F;17 10:13 &lt;DIR&gt; .. 2020&#x2F;06&#x2F;21 18:46 &lt;DIR&gt; Camera Roll 2021&#x2F;01&#x2F;14 16:18 &lt;DIR&gt; Feedback 2020&#x2F;06&#x2F;21 18:46 &lt;DIR&gt; Saved Pictures 0 个文件 0 字节 5 个目录 21,613,158,400 可用字节 ^作为转义字符的作用 C:\\Users\\wang\\Pictures&gt;echo &gt; 命令语法不正确。 C:\\Users\\wang\\Pictures&gt;echo ^&gt; &gt; 所以对应于我们标题的问题，我们可以有两种写法 加引号：git reset –hard “HEAD^” 加一个转义^：git reset –hard HEAD^^ 当然对于git reset命令，我们可以使用git reset --hard HEAD~ 或者 git reset --hard HEAD~1来代替HEAD^ 3、删除文件","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"Git(1) -- 入门知识","slug":"git","date":"2021-06-13T16:09:29.000Z","updated":"2021-07-14T17:12:28.876Z","comments":true,"path":"2021/06/14/git/","link":"","permalink":"http://www.yipinxieli.com/2021/06/14/git/","excerpt":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git(1)—基础知识 1、git仓库 git init 命令用于在目录中创建Git仓库。在目录中执行 git init 后你可以看到在你的项目中生成了 .git 这个子目录，这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。 git init your_project 新建项目直接用GIT管理，会在当前路径下创建和your_project同名的文件夹 **.git默认是隐藏的，可以用 ls -a 命令查看 ** $ git init Initialized empty Git repository in D:&#x2F;git学习&#x2F;.git&#x2F; git clone [url]克隆远程仓库 $ git clone https:&#x2F;&#x2F;gitee.com&#x2F;ShanXiXiaoMoTou&#x2F;spring-boot-study.git Cloning into &#39;spring-boot-study&#39;... remote: Enumerating objects: 75, done. remote: Counting objects: 100% (75&#x2F;75), done. remote: Compressing objects: 100% (59&#x2F;59), done. remote: Total 75 (delta 1), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (75&#x2F;75), 27.85 KiB | 1.99 MiB&#x2F;s, done. Resolving deltas: 100% (1&#x2F;1), done. 2、设置用户信息 设置全局用户信息(对当前用户的所有仓库有效) git config --global user.name your_username git config --global user.email your_email 设置局部仓库用户信息(只对某个仓库有效) git config --local user.name your_username git config --local user.email your_email 3、Git 工作区、暂存区和版本库 Workspace： 工作区，就是你平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 本地仓库，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 4、 Git工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) 5、文件的四种状态 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制。通过git add 状态变为Staged。 Unmodify: 文件已入库未修改。 如果被修改会变为Modified。如果使用git rm移出版本库,成为Untracked文件。 Modified: 文件已修改。通过git add可进入暂存staged状态, 使用git checkout覆盖当前修改返回到unmodify状态。 Staged: 暂存状态。 执行git commit提交变为Unmodify状态。执行git reset HEAD filename取消暂存变为Modified。 6、Git提交与修改 git add 将该文件添加到暂存区 命令 作用 git add [file1] [file2] … 添加一个或多个文件到暂存区 git add [dir] 添加指定目录到暂存区，包括子目录 git add . 添加当前目录下的所有文件到暂存区 wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git status -s ?? src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F; wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git add . warning: LF will be replaced by CRLF in src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java. The file will have its original line endings in your working directory wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git status On branch master Your branch is up to date with &#39;origin&#x2F;master&#39;. Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java git commit 提交暂存区到本地仓库 命令 作用 git commit -m [message] 提交暂存区到本地仓库中: git commit [file1] [file2] … -m [message] 提交暂存区的指定文件到仓库区 git commit -a -a 参数设置修改文件后不需要执行 git add 命令，直接来提交 注：此时提交代码使用的用户信息就是我们在开始钱设置的用户信息（用户名和邮箱） wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git commit -m &quot;feat:删除标志位代码增加&quot; [master 761e5f6] feat:删除标志位代码增加 1 file changed, 20 insertions(+) create mode 100644 src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git reset --soft HEAD^ wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git status On branch master Your branch is up to date with &#39;origin&#x2F;master&#39;. Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F;CommonConst.java git reset 回退版本，可以指定退回某一次提交的版本 git reset [–soft | –mixed | –hard] [HEAD] 撤销git commit操作 git reset –soft HEAD^ HEAD^的意思是上一个版本，也可以写成HEAD~1。如果你进行了2次commit，想都撤回，可以使用HEAD~2 –mixed（默认参数） git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 不删除工作空间改动代码，撤销commit，并且撤销git add . 操作 –soft不删除工作空间改动代码，撤销commit，不撤销git add . –hard删除工作空间改动代码，撤销commit，撤销git add .注意完成这个操作后，就恢复到了上一次的commit状态。 $ git status On branch master Your branch is ahead of &#39;origin&#x2F;master&#39; by 1 commit. (use &quot;git push&quot; to publish your local commits) nothing to commit, working tree clean wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git reset head^ wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git status On branch master Your branch is up to date with &#39;origin&#x2F;master&#39;. Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F; nothing added to commit but untracked files present (use &quot;git add&quot; to track) 取消之前 git add 添加，但不希望包含在下一提交快照中的缓存 git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 git reset HEAD 文件名 就是对某个文件进行撤销了 wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git reset Head wang@LAPTOP-4HQAPUSB MINGW64 &#x2F;d&#x2F;IdeaProjects&#x2F;spring-boot-study (master) $ git status On branch master Your branch is up to date with &#39;origin&#x2F;master&#39;. Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) src&#x2F;main&#x2F;java&#x2F;com&#x2F;rrc&#x2F;constant&#x2F; nothing added to commit but untracked files present (use &quot;git add&quot; to track) 撤销对远程仓库的push操作 获取需要回退的版本号 执行 git reset –-soft &lt;版本号&gt; ，重置至指定版本的提交，达到撤销提交的目的 执行 git push origin 分支名 –-force ，强制提交当前版本号，完成push撤销 D:\\IdeaProjects\\spring-boot-study&gt;git log commit 6c8685349e4fb3fefbb1d4cf2be351e4e2a61a70 (HEAD -&gt; master, origin&#x2F;master) Author: 王清雷 &lt;wangqing@ren.com&gt; Date: Wed Jun 23 00:06:29 2021 +0800 feat:测试回滚操作 commit fe056300b80f84a2caf9d92662d94e8e3fe218f1 Merge: a42c966 83f0da7 Author: 王清雷 &lt;wangqing@ren.com&gt; Date: Sun Jun 20 01:37:37 2021 +0800 Merge remote-tracking branch &#39;origin&#x2F;master&#39; D:\\IdeaProjects\\spring-boot-study&gt;git reset --soft fe056300b80f84a2caf9d92662d94e8e3fe218f1 D:\\IdeaProjects\\spring-boot-study&gt;git push origin master --force Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 To https:&#x2F;&#x2F;github.com&#x2F;qinglei1989&#x2F;spring-boot-study.git + 6c86853...fe05630 master -&gt; master (forced update)","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"}]},{"title":"VirtualBox上安装CentOS7","slug":"linux0","date":"2021-06-13T16:09:29.000Z","updated":"2021-06-27T15:14:31.675Z","comments":true,"path":"2021/06/14/linux0/","link":"","permalink":"http://www.yipinxieli.com/2021/06/14/linux0/","excerpt":"最近打算学习一下Linux知识，所以准备装个Linux虚拟机玩玩。而VirtualBox是一款免费、开源、高性能的虚拟机软件，可以跨平台运行，支持Windows、Mac、Linux等操作系统。所以我选择使用VirtualBox来安装CentOS7。","text":"最近打算学习一下Linux知识，所以准备装个Linux虚拟机玩玩。而VirtualBox是一款免费、开源、高性能的虚拟机软件，可以跨平台运行，支持Windows、Mac、Linux等操作系统。所以我选择使用VirtualBox来安装CentOS7。 Linux学习1—VirtualBox上安装CentOS7 1、安装VirtualBox 基础环境：宿主机是64位 Windows10操作系统，通过无线网访问网络。 VirtualBox的安装比较简单，此处不做说明。VirtualBox最新版下载地址：Downloads – Oracle VM VirtualBox 本次安装教程使用VirtualBox6.1版来完成 2、下载CentOS7 CentOS7下载地址：Downloads – CentOS7 我没有选择Minimal ISO（最小化安装包），因为自己比较菜，直接下载了CentOS-7.0-1406-x86_64-DVD.iso版本，4个多G。买了一本经典的LINUX课本《鸟哥的LINUX私房菜》，尽量与课本保持一致。 3、初始化虚拟机 点击新建虚拟机，依次输入名称、选择安装目录、选择虚拟机操作系统类型与具体的版本。点击下一步 根据自己的电脑配置选择合适的内存及硬盘大小依次点击下一步 选择存放位置 设置虚拟机能够使用的最大硬盘空间 点击创建就完成了初始化的操作 4、安装虚拟机 启动虚拟机，选择我们开始下载的CentOS7安装包，点击启动 时区选择上海 双击软件选择，在弹出界面中选择GNOME桌面，对于初学者比较友好。 网络选择:选择打开以太网，减少后期对网络的配置，点击完成 备注：必须完成带有黄色感叹号的内容，才能进行下一步，我们点击安装位置后直接点击确定 设置ROOT用户密码 创建一个普通用户 初始化完成进入登录页面，输入密码，即可进入CentOS桌面 注意：进入系统显示的帮助说明不是在浏览器中显示的，顶部不是地址栏 5、注意事项 刚刚安装的虚拟机显示很小，可以打开自动缩放模式，快捷键为Host+C。Host键对应于键盘右边的那个CTRL键 宿主机wifi时的虚拟机网络设置 此时虚拟机可以ping通外网，但是外网访问不到虚拟机。 网卡1连接方式为网络地址转换(nat)，用于访问外网 我们设置网卡2连接方式为仅主机(Host-Only)网络，界面名称选择virtualBox安装后自动生成的以太网卡适配器，用于与宿主机通信 此时重启CentOS虚拟机 使用**MobaXterm**连接虚拟机，输入IP地址、用户名、端口，点击OK，在打开的敞口中输入密码即完成MobaXterm连接VirtualBox 虚拟机中的 CentOS 7 至此，VirtualBox上安装CentOS7大功告成，开始学习。。。 引用文章 知乎—VirtualBox上安装CentOS7 博客园—VirtualBox下安装CentOS7系统","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"}]},{"title":"MyBatis-Plus学习(2)","slug":"MybatisPlus1","date":"2021-06-09T15:04:35.000Z","updated":"2021-06-10T16:23:12.675Z","comments":true,"path":"2021/06/09/MybatisPlus1/","link":"","permalink":"http://www.yipinxieli.com/2021/06/09/MybatisPlus1/","excerpt":"MybatisPlus常用操作的熟悉了解。快速迭代开发技巧熟悉，相关知识点总结记录。后续加入复杂查询及分页等。","text":"MybatisPlus常用操作的熟悉了解。快速迭代开发技巧熟悉，相关知识点总结记录。后续加入复杂查询及分页等。 MyBatis-Plus常用操作 1、主键查询返回实体类 School school &#x3D; schoolMapper.selectById(schoolId); &#x2F;&#x2F; 相应的控制台打印 Creating a new SqlSession SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@52ebdf07] was not registered for synchronization because synchronization is not active JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@4ecf9] will not be managed by Spring &#x3D;&#x3D;&gt; Preparing: SELECT id,school_name,school_address,school_icon,school_establish,create_date,create_user,update_date,update_user,is_delete FROM sys_school WHERE id&#x3D;? AND is_delete&#x3D;1 &#x3D;&#x3D;&gt; Parameters: 1(Long) &lt;&#x3D;&#x3D; Total: 0 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@52ebdf07] 2、非主键查询默认返回List QueryWrapper&lt;School&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;school_address&quot;, &quot;44&quot;); List&lt;School&gt; schoolList &#x3D; schoolMapper.selectList(queryWrapper); &#x2F;&#x2F; 相应的控制台打印 Creating a new SqlSession SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@506c3bdd] was not registered for synchronization because synchronization is not active JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ab856dd] will not be managed by Spring &#x3D;&#x3D;&gt; Preparing: SELECT id,school_name,school_address,school_icon,school_establish,create_date,create_user,update_date,update_user,is_delete FROM sys_school WHERE is_delete&#x3D;1 AND (school_address &#x3D; ?) &#x3D;&#x3D;&gt; Parameters: 44(String) &lt;&#x3D;&#x3D; Columns: id, school_name, school_address, school_icon, school_establish, create_date, create_user, update_date, update_user, is_delete &lt;&#x3D;&#x3D; Row: 4, 44, 44, 55, 2020-09-08 03:11:11, 2021-05-26 11:43:11, 1, 2021-05-26 11:43:11, 1, 1 &lt;&#x3D;&#x3D; Row: 6, 55555, 44, 55, 2021-05-28 11:35:56, 2021-05-28 03:35:57, 1, 2021-05-28 03:35:57, 1, 1 &lt;&#x3D;&#x3D; Row: 7, 8888889, 44, 55, 2021-05-28 15:34:01, 2021-05-28 07:34:01, 1, 2021-05-28 07:34:01, 1, 1 &lt;&#x3D;&#x3D; Total: 3 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@506c3bdd] 3、非主键唯一查询 QueryWrapper&lt;School&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;school_address&quot;, &quot;44&quot;); School schoolList &#x3D; schoolMapper.selectOne(queryWrapper); &#x2F;&#x2F;当根据查询条件返回多个结果时,系统会报异常 org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 &#x2F;&#x2F;如果我们想要根据查询结果取一条的话相应的QueryWrapper拼接如下： QueryWrapper&lt;School&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;school_address&quot;, &quot;44&quot;).last(&quot; limit 1&quot;); School schoolList &#x3D; schoolMapper.selectOne(queryWrapper); &#x2F;&#x2F; 相应的控制台打印 SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@25ba7e55] was not registered for synchronization because synchronization is not active JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@7cb406f8] will not be managed by Spring &#x3D;&#x3D;&gt; Preparing: SELECT id,school_name,school_address,school_icon,school_establish,create_date,create_user,update_date,update_user,is_delete FROM sys_school WHERE is_delete&#x3D;1 AND (school_address &#x3D; ?) limit 1 &#x3D;&#x3D;&gt; Parameters: 44(String) &lt;&#x3D;&#x3D; Columns: id, school_name, school_address, school_icon, school_establish, create_date, create_user, update_date, update_user, is_delete &lt;&#x3D;&#x3D; Row: 4, 44, 44, 55, 2020-09-08 03:11:11, 2021-05-26 11:43:11, 1, 2021-05-26 11:43:11, 1, 1 &lt;&#x3D;&#x3D; Total: 1 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@25ba7e55] 4、查询结果返回指定列 QueryWrapper&lt;School&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;(); queryWrapper.s elect(&quot;id, school_name, school_address&quot;).eq(&quot;school_address&quot;, &quot;44&quot;).last(&quot; limit 1&quot;); School schoolList &#x3D; schoolMapper.selectOne(queryWrapper); SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7526927e] was not registered for synchronization because synchronization is not active JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@1afc5a20] will not be managed by Spring &#x3D;&#x3D;&gt; Preparing: SELECT id, school_name, school_address FROM sys_school WHERE is_delete&#x3D;1 AND (school_address &#x3D; ?) limit 1 &#x3D;&#x3D;&gt; Parameters: 44(String) &lt;&#x3D;&#x3D; Columns: id, school_name, school_address &lt;&#x3D;&#x3D; Row: 4, 44, 44 &lt;&#x3D;&#x3D; Total: 1 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7526927e] 5、查询返回自定义实体 &#x2F;&#x2F; List查询结果使用convert函数进行转换 Page&lt;School&gt; listPage &#x3D; schoolMapper.selectPage(page, queryWrapper); return listPage.convert(obj -&gt; SchoolDto.builder() .id(obj.getId()) .schoolName(obj.getSchoolName()) .schoolAddress(obj.getSchoolAddress()) .schoolIcon(obj.getSchoolIcon()) .schoolEstablish(obj.getSchoolEstablish()) .build()); &#x2F;&#x2F; 使用自定义SQL来返回自定义实体 @Select(&quot;select * from sys_school $&#123;ew.customSqlSegment&#125;&quot;) SchoolDto selectCustomById(@Param(Constants.WRAPPER) Wrapper wrapper); 6、Query封装 &#x2F;&#x2F; lamdaQuery QueryWrapper&lt;School&gt; queryWrapper &#x3D; new QueryWrapper&lt;School&gt;(); if (Optional.ofNullable(schoolVo).isPresent()) &#123; queryWrapper.lambda() .eq(StringUtils.isNotBlank(schoolVo.getSchoolName()), School::getSchoolName, schoolVo.getSchoolName()) .eq(StringUtils.isNotBlank(schoolVo.getSchoolAddress()), School::getSchoolAddress, schoolVo.getSchoolAddress()) .eq(StringUtils.isNotBlank(schoolVo.getSchoolIcon()), School::getSchoolIcon, schoolVo.getSchoolIcon()) .eq(Objects.nonNull(schoolVo.getSchoolEstablish()), School::getSchoolEstablish, schoolVo.getSchoolEstablish()); &#125; &#x2F;&#x2F; query有以下两种写法 QueryWrapper&lt;School&gt; queryWrapper &#x3D; new QueryWrapper&lt;School&gt;(); queryWrapper.eq(StringUtils.isNotBlank(schoolVo.getSchoolName()), &quot;school_name&quot;, schoolVo.getSchoolName()); if (StringUtils.isNotBlank(schoolVo.getSchoolName())) &#123; queryWrapper.eq(&quot;school_name&quot;, schoolVo.getSchoolName()); &#125;","categories":[{"name":"持久层","slug":"持久层","permalink":"http://www.yipinxieli.com/categories/%E6%8C%81%E4%B9%85%E5%B1%82/"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"http://www.yipinxieli.com/tags/MyBatis-Plus/"}]},{"title":"Notepad++数据批量处理技巧","slug":"notepad","date":"2021-06-04T15:14:54.000Z","updated":"2021-07-20T13:34:34.036Z","comments":true,"path":"2021/06/04/notepad/","link":"","permalink":"http://www.yipinxieli.com/2021/06/04/notepad/","excerpt":"Notepad++是Windows下一款很好用的文本编辑器。对于大量文本内容的查找和批量处理很高效。","text":"Notepad++是Windows下一款很好用的文本编辑器。对于大量文本内容的查找和批量处理很高效。 Notepad++实用技巧 查找操作技巧在软件开发过程中，如果我们的代码出现异常，有时候我们需要从日志中提取相应的信息，进行异常补偿。此时我们就可以使用NodePad++的批量操作来快速定位相应的关键信息（比如数据ID等)。 如下例使用Nodepad++打开日志文件，我们在日志文件中使用Ctrl+F查找关键字”axb录音发送延迟队列成功”，然后点击在当前文件中查找按钮进行快速查找。 相应的搜索结果及匹配次数就会显示在Notepad++下方的搜索结果里，如果我们需要进一步的根据搜索结果拿到全部匹配日志中的uniqueId列，我们需要将搜索结果中的记录集复制到一个新文档中继续批量操作 在新文档中，由于日志基本上都是按固定格式排列的，此时我们就可以通过批量操作快速找到我们需要使用的数据。我们依然通过快速获取全部的uniqueId列来进行举例。 批量操作技巧首先我们将光标定位在uniqueId列等号后，此时将文档下拉到尾部，在最后一行的uniqueId列等号后，按住Alt+Shift，再次点击鼠标，此时会有一条闪烁的直线在所有的uniqueId列等号后（说明操作块行选择完成），此时依然按住Alt+Shift，再次将光标定位到uniqueId列，前边完成块的选择，此时文档块为灰色选中状态。 再次按下Ctrl+C复制当前的选中块，在文档中进行黏贴，就完成了全部uniqueId的统计了。 有的时候我们需要根据这些ID来进行SQL的拼接，Nodepad++比较适合少量简单数据的SQL拼接工作，十分方便。我们将光标定位在第一行行首。在最后一行行首按住Alt+Shift，再次点击鼠标。此时会有一条闪烁的直线在所有行行首，我们直接输入语句（INSERT INTO TABLE VALUES (），它会填充到每个行。 至此Nodepad++批量操作的技巧就介绍完毕了。 切记： 先定位行，再定义列，就完成了块的选择操作 先定位行就可以完成批量插入操作 去除不必要的换行和空格有时候我们需要将多行数据转换到一行，可以通过如下操作来实现，如下，我们要将这个SQL转成一行，在Navicat中可以通过简化SQL来实现，在Notepad++中，则通过移除非必需的空白和EOL来实现。 SELECT temp.city as &#39;城市&#39;, users.&#96;name&#96; AS &#39;子账号姓名&#39;, users.mobile as &#39;子账号联系方式&#39;, users.created_at as &#39;账号创建时间&#39;, CASE when users.user_status &#x3D; 2 then &#39;禁用&#39; when users.user_status &#x3D; 3 then &#39;离职&#39; when users.user_status &#x3D; 0 then &#39;正常&#39; when users.user_status &#x3D; 1 then &#39;未激活&#39; end as &#39;账号状态&#39;, temp.group_leader_name AS &#39;主账号姓名&#39;, temp.mobile AS &#39;主账号联系方式&#39; FROM users JOIN ( SELECT gu.user_id, uc.group_leader_id, group_leader_name, uc.city, u.mobile FROM group_user gu JOIN user_city_area_group uc ON gu.group_id &#x3D; uc.id join users u on uc.group_leader_id &#x3D; u.id AND uc.city IN (&#39;长沙&#39;, &#39;广州&#39;) ) temp ON users.user_id &#x3D; temp.user_id SELECT temp.city as &#39;城市&#39;, users.&#96;name&#96; AS &#39;子账号姓名&#39;, users.mobile as &#39;子账号联系方式&#39;, users.created_at as &#39;账号创建时间&#39;, CASE when users.user_status &#x3D; 2 then &#39;禁用&#39; when users.user_status &#x3D; 3 then &#39;离职&#39; when users.user_status &#x3D; 0 then &#39;正常&#39; when users.user_status &#x3D; 1 then &#39;未激活&#39; end as &#39;账号状态&#39;, temp.group_leader_name AS &#39;主账号姓名&#39;, temp.mobile AS &#39;主账号联系方式&#39; FROM users JOIN ( SELECT gu.user_id, uc.group_leader_id, group_leader_name, uc.city, u.mobile FROM group_user gu JOIN user_city_area_group uc ON gu.group_id &#x3D; uc.id join users u on uc.group_leader_id &#x3D; u.id AND uc.city IN (&#39;长沙&#39;, &#39;广州&#39;) ) temp ON users.user_id &#x3D; temp.user_id 行列转换 行转列 Ctrl + F 选择替换 查找目标：填写指定的内容 替换为：\\r\\n 查找模式：正则表达式 单击替换或全部替换按钮 列转行 Ctrl + F 选择替换 查找目标：\\r\\n 替换为：不填写或填写指定的内容 查找模式：正则表达式 单击替换或全部替换按钮","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://www.yipinxieli.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"MyBatis-Plus学习(1)","slug":"MybatisPlus0","date":"2021-06-04T12:46:25.000Z","updated":"2021-08-21T18:23:43.959Z","comments":true,"path":"2021/06/04/MybatisPlus0/","link":"","permalink":"http://www.yipinxieli.com/2021/06/04/MybatisPlus0/","excerpt":"一个Mybatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。","text":"一个Mybatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 MyBatis-Plus了解 MyBatis-Plus特点 无侵入：只做增强不做改变，引入它不会对现有工程产生影响 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 代码，支持模板引擎，自定义配置 内置分页插件：基于 MyBatis 物理分页 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 官方文档地址 Mybatis-Plus与Springboot整合 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;scope&gt;compile&lt;&#x2F;scope&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- 字符串 集合类校验 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 参数校验框架学习 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- mybatis-plus-generator --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- freemarker模板 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;&#x2F;groupId&gt; &lt;artifactId&gt;freemarker&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.30&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;","categories":[{"name":"持久层","slug":"持久层","permalink":"http://www.yipinxieli.com/categories/%E6%8C%81%E4%B9%85%E5%B1%82/"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"http://www.yipinxieli.com/tags/MyBatis-Plus/"}]}],"categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.yipinxieli.com/categories/JAVA/"},{"name":"数据库","slug":"数据库","permalink":"http://www.yipinxieli.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.yipinxieli.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.yipinxieli.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"容器","slug":"容器","permalink":"http://www.yipinxieli.com/categories/%E5%AE%B9%E5%99%A8/"},{"name":"单元测试","slug":"单元测试","permalink":"http://www.yipinxieli.com/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"Spring","slug":"Spring","permalink":"http://www.yipinxieli.com/categories/Spring/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.yipinxieli.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"缓存中间件","slug":"缓存中间件","permalink":"http://www.yipinxieli.com/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"持久层","slug":"持久层","permalink":"http://www.yipinxieli.com/categories/%E6%8C%81%E4%B9%85%E5%B1%82/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.yipinxieli.com/tags/JVM/"},{"name":"mysql","slug":"mysql","permalink":"http://www.yipinxieli.com/tags/mysql/"},{"name":"Thread","slug":"Thread","permalink":"http://www.yipinxieli.com/tags/Thread/"},{"name":"jwt","slug":"jwt","permalink":"http://www.yipinxieli.com/tags/jwt/"},{"name":"Linux","slug":"Linux","permalink":"http://www.yipinxieli.com/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://www.yipinxieli.com/tags/Docker/"},{"name":"postman","slug":"postman","permalink":"http://www.yipinxieli.com/tags/postman/"},{"name":"junit","slug":"junit","permalink":"http://www.yipinxieli.com/tags/junit/"},{"name":"实用工具","slug":"实用工具","permalink":"http://www.yipinxieli.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"spring-boot-starter-data-redis","slug":"spring-boot-starter-data-redis","permalink":"http://www.yipinxieli.com/tags/spring-boot-starter-data-redis/"},{"name":"springEL","slug":"springEL","permalink":"http://www.yipinxieli.com/tags/springEL/"},{"name":"git","slug":"git","permalink":"http://www.yipinxieli.com/tags/git/"},{"name":"redis","slug":"redis","permalink":"http://www.yipinxieli.com/tags/redis/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"http://www.yipinxieli.com/tags/MyBatis-Plus/"}]}